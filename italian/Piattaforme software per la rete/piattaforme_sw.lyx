#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.5cm
\topmargin 1.5cm
\rightmargin 1.5cm
\bottommargin 1.5cm
\headheight 1.5cm
\headsep 1.5cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Piattaforme software per la rete (modulo 1)
\end_layout

\begin_layout Author
Daniele Iamartino
\end_layout

\begin_layout Date
17 Giugno 2012
\end_layout

\begin_layout Part*

\lang english
Materiale di studio
\end_layout

\begin_layout Itemize

\lang english
G.Varghese, 
\emph on
Network Algorthmics
\emph default
, Morgan Kaufmann 2005: Libro basilare per implementare i protocolli utilizzati
 per le reti
\end_layout

\begin_layout Part*
Endnodes
\end_layout

\begin_layout Section*
Bottlenecks - Colli di bottiglia
\end_layout

\begin_layout Standard
Le reti di telecomunicazione sono degli apparati molto complessi.
 Al fine di poter fornire un'interfaccia semplice negli strati superiori
 si introducono spesso delle astrazioni (come ad esempio l'interfaccia a
 socket).
 Spesso però queste astrazioni possono risultare colli di bottiglia e danneggiar
e le prestazioni.
\end_layout

\begin_layout Standard
Su questo gioca la progettazione delle reti: dobbiamo trovare un compromesso
 tra astrazioni e interfacce.
\end_layout

\begin_layout Subsection*
Origine dei bottlenecks
\end_layout

\begin_layout Standard
Solitamente gli endnodes sono progettati per essere 
\emph on
general purpose
\emph default
, strutturati con:
\end_layout

\begin_layout Itemize
Software stratificato per facilità di sviluppo: ad esempio ispirato alla
 pila protocollare ISO/OSI
\end_layout

\begin_layout Itemize
Implementazione di meccanismi di sicurezza e gestione dei permessi con limitazio
ni di accesso.
\end_layout

\begin_layout Itemize
Implementazione di algoritmi e meccanismi generici perché non siamo in grado
 di prevedere la maggior parte delle situazioni.
\end_layout

\begin_layout Standard
Spesso però le implementazioni dei protocolli che abbiamo nei sistemi operativi
 non scalano in grande a causa di alcuni problemi:
\end_layout

\begin_layout Itemize
Copie multiple dei pacchetti in svariate zone (prima nella memoria dell'adattato
re di rete, poi viene copiato varie volte in diversi punti della memoria
 ram).
\end_layout

\begin_layout Itemize
Overhead dovuto a continue chiamate (e quindi interruzioni) da e per il
 sistema operativo.
\end_layout

\begin_layout Itemize
Ci sono diversi timers che vanno regolati (ad esempio il 
\emph on
timer di persistenza
\emph default
 di TCP).
 La scelta di un valore non è semplice e comporta svantaggi gravi se fatta
 in modo errato.
\end_layout

\begin_layout Section*
Definizione di protocollo
\end_layout

\begin_layout Standard
Un protocollo è una macchina a stati finiti.
\end_layout

\begin_layout Standard
Inoltre un protocollo:
\end_layout

\begin_layout Itemize
Deve fare manipolazione di dati
\end_layout

\begin_layout Itemize
Allocare buffers e risorse CPU per fare le operazioni che gli competono
\end_layout

\begin_layout Itemize
Deve poter fare 
\emph on
demultiplexing
\emph default
 al momento della ricezione di un pacchetto
\end_layout

\begin_layout Itemize
Deve poter schedulare delle attività (ad esempio i timer)
\end_layout

\begin_layout Itemize
Si occupa di ricostruire i frammenti
\end_layout

\begin_layout Section*
Considerazioni e metriche per le performance
\end_layout

\begin_layout Standard
Principalmente ci occupiamo di misurare:
\end_layout

\begin_layout Itemize

\series bold
\emph on
Throughput
\series default
\emph default
 (jobs completati al secondo)
\end_layout

\begin_layout Itemize

\series bold
\emph on
Latency
\series default
\emph default
 (tempo necessario a completare un job).
 Nel caso dei protocolli esso è composto dal 
\series bold
tempo di elaborazione
\emph on
 
\series default
\emph default
sommato al 
\series bold
tempo di trasmissione
\series default
.
\end_layout

\begin_layout Standard
Le nostre misure si concentreranno su un nodo locale e non sulla rete in
 generale.
\end_layout

\begin_layout Standard
È importante ricordarsi che un throughput maggiore solitamente significa
 alta latenza, quindi ci troviamo spesso in una situazione di 
\emph on
tradeoff
\emph default
 in cui è necessario scegliere uno dei due.
 La soluzione migliore dipende dall'applicazione che vogliamo realizzare.
\end_layout

\begin_layout Subsection*
Alcune considerazioni sperimentali
\end_layout

\begin_layout Itemize
I collegamenti nei 
\emph on
backbone
\emph default
 sono molto più veloci dei collegamenti di accesso alla rete, a causa dell'ovvia
 quantità di traffico che li deve attraversare.
\end_layout

\begin_layout Itemize
Più del 
\series bold
70% del traffico di Internet è HTTP
\series default
, più del 
\series bold
90% sono connessioni TCP
\series default
.
\end_layout

\begin_layout Itemize
Il 
\series bold
50% dei trasferimenti sono piccoli files (meno di 50KB)
\series default
.
\end_layout

\begin_layout Itemize
Il tempo di andata e ritorno 
\series bold
RTT è molto maggiore rispetto al tempo di propagazione fisica
\series default
 e spesso non sono confrontabili per fare considerazioni.
\end_layout

\begin_layout Itemize
Circa la metà dei pacchetti in rete sono di piccole dimensioni (intorno
 ai 40Byte), questo perché si tratta di acknowledgements.
\end_layout

\begin_layout Section*
Principi generali sull'implementazione
\end_layout

\begin_layout Itemize

\series bold
White Box
\series default
: a lato programmativo conosco com'è fatto il sistema e come è stato implementat
o.
\end_layout

\begin_layout Itemize

\series bold
Cross Layer design
\series default
: manteniamo verso l'utente del servizio la separazione degli strati protocollar
i, tuttavia nell'implementazione vengono riuniti per aumentare le prestazioni
 e sfruttarne la sinergia.
\end_layout

\begin_layout Itemize
Tentiamo di mantenere la modularità senza perdere efficienza.
\end_layout

\begin_layout Itemize
Ci concentriamo sulle routine più importanti e più utilizzate.
 Tentiamo di ottimizzarle al massimo.
 Viste le precedenti considerazioni risulta ovvio che le routine fondamentali
 sono quelle che hanno a che fare con TCP.
\end_layout

\begin_layout Section*
Architettura degli endnodes
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename nodearch.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
Quella in figura è la struttura basilare semplificata dell'architettura
 di un nodo finale tipico che opera in rete.
\end_layout

\begin_layout Standard
Vediamo i componenti:
\end_layout

\begin_layout Itemize

\series bold
CPU
\series default
: Il microprocessore che si occupa di effettuare i calcoli, tutta la parte
 algoritmica del protocollo sfrutta la CPU.
\end_layout

\begin_layout Itemize

\series bold
MMU
\series default
 e 
\series bold
Cache
\series default
: Specialmente in un sistema che opera in rete sono 
\series bold
fondamentali
\series default
 e devono essere studiate su più livelli al fine di ottenere le prestazioni
 migliori.
\end_layout

\begin_layout Itemize

\series bold
System bus
\series default
: Tempo fa era molto più veloce della rete su cui si operava.
 Oggi si può arrivare a dire che in certe condizioni diventi il collo di
 bottiglia del sistema.
\end_layout

\begin_layout Itemize

\series bold
Memory
\series default
: la memoria di sistema, solitamente una RAM.
\end_layout

\begin_layout Itemize

\series bold
Bus adaptor
\series default
: apparato che permette la comunicazione tra il bus di sistema e quello
 di periferica.
\end_layout

\begin_layout Itemize

\series bold
I/O bus
\series default
: Bus di periferica, al giorno d'oggi ha velocità simili a quelle del 
\emph on
system bus
\emph default
.
\end_layout

\begin_layout Itemize

\series bold
Network interface
\series default
: Chiamato anche 
\emph on
adattatore di rete
\emph default
, è la periferica che comunica fisicamente con la rete.
 A volte alcune operazioni (come ad esempio il calcolo del 
\emph on
checksum
\emph default
) vengono fatte direttamente qua per evitare troppi passaggi in RAM.
\end_layout

\begin_layout Standard
I nodi finali sfruttano due proprietà fondamentali:
\end_layout

\begin_layout Itemize
La 
\series bold
località temporale
\series default
: la stessa locazione di memoria è riutilizzata frequentemente.
\end_layout

\begin_layout Itemize
La 
\series bold
località spaziale
\series default
: la prossima locazione di memoria utilizzata sarà molto probabilmente una
 locazione vicina.
\end_layout

\begin_layout Standard
Il processing dei pacchetti sfrutta solo la località spaziale.
\end_layout

\begin_layout Standard
Teniamo conto che, purtroppo, in molti casi questo tipo di architettura
 limita il throughput tra la rete e la memoria.
 Vedremo tra poco perché.
\end_layout

\begin_layout Subsection*
Processing dei pacchetti ricevuti
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename processing.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
Vediamo come funziona il processing dei pacchetti ricevuti su BSD UNIX.
\end_layout

\begin_layout Itemize
L'arrivo di un pacchetto genera un evento di interrupt
\end_layout

\begin_layout Itemize
L'interrupt handler copia il pacchetto dalla memoria dell'adattatore di
 rete ad una coda 
\bar under
condivisa
\bar default
 del kernel in memoria centrale e quindi richiede al sistema operativo un
 thread (
\emph on
soft interrupt
\emph default
)
\end_layout

\begin_layout Itemize
Il 
\emph on
soft interrupt handler
\emph default
 accoda il pacchetto in una coda dei socket all'interno della memoria del
 processo e sveglia il processo.
\end_layout

\begin_layout Subsubsection*
Problema del 
\emph on
livelock
\end_layout

\begin_layout Standard
Quando i pacchetti arrivano troppo velocemente l'adattore di rete genera
 moltissimi interrupts, gli handlers consumano tutta la CPU, le code vanno
 in overflow e dei pacchetti vengono persi.
\end_layout

\begin_layout Subsection*
Il problema delle copie multiple
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename multiple.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Nell'immagine troviamo la struttura base di un server web che deve servire
 leggere pagine presenti su disco e inviarle via rete.
 Indifferentemente dalla strada percorsa, la pagina passa prima dallo 
\series bold
storage
\series default
 (il disco), poi alla 
\series bold
cache
\series default
 del filesystem, poi nel 
\series bold
buffer
\series default
 dell'applicazione server, quindi al 
\series bold
socket buffer
\series default
 del kernel dove operano le routine del TCP/IP e infine il sistema operativo
 la invia all'
\series bold
adattatore di rete
\series default
.
\end_layout

\begin_layout Standard
In tutto vengono fatte almeno 4 copie della stessa informazione:
\end_layout

\begin_layout Itemize
Storage
\end_layout

\begin_layout Itemize
RAM
\end_layout

\begin_layout Itemize
Cache
\end_layout

\begin_layout Itemize
Network adapter
\end_layout

\begin_layout Standard
Se non siamo troppo preoccupati per le prestazioni, questa architettura
 può anche essere accettabile.
 Se invece vogliamo andare alla massima velocità consentita dal livello
 fisico, possiamo ottimizzare questa parte al fine di consumare 
\series bold
meno memoria e meno banda sul bus
\series default
.
 Infatti solo la memoria su disco e sull'adattatore sono veramente indispensabil
i.
\end_layout

\begin_layout Subsection*
Soluzione PIO/DMA al problema delle copie multiple
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename sol1.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
La prima soluzione è permettere alla memoria centrale RAM di scrivere direttamen
te sull'adattatore, spostando quindi la zona di 
\series bold
\emph on
socket buffer
\series default
\emph default
 che prima era in memoria, direttamente sull'adattatore.
 Questo metodo può sfruttare un 
\series bold
PIO 
\series default
(
\emph on
Processor I/O
\emph default
)
\series bold
 
\series default
o 
\begin_inset Quotes eld
\end_inset


\emph on
memory map
\emph default

\begin_inset Quotes erd
\end_inset

 (cioè un mappaggio di una periferica in memoria) oppure un meccanismo simile
 a 
\series bold
DMA
\series default
 (
\emph on
Directed Memory Access
\emph default
)
\end_layout

\begin_layout Standard
Il problema è che per il calcolo del 
\emph on
checksum
\emph default
 dobbiamo fare in modo che se ne occupi la CPU, altrimenti releghiamo all'adatta
tore.
 Un'altra alternativa è calcolare il 
\emph on
checksum
\emph default
 mentre copiamo nel 
\emph on
socket buffer
\emph default
.
\end_layout

\begin_layout Paragraph*
Vantaggi
\end_layout

\begin_layout Itemize
Possiamo fare il 
\emph on
checksum
\emph default
 direttamente nell'adattatore
\end_layout

\begin_layout Itemize
Eliminiamo un po' di passaggi e copie 
\begin_inset Quotes eld
\end_inset

inutili
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Paragraph*
Svantaggi
\end_layout

\begin_layout Itemize
Ci serve molta memoria nell'adattatore.
 Non è detto che il processo utente sia subito pronto a recuperare i pacchetti
 quando arrivano.
\end_layout

\begin_layout Itemize
Può succedere che l'applicazione riceva i dati prima che venga verificato
 il 
\emph on
checksum
\emph default
, lavorando quindi su dati potenzialmente errati.
\end_layout

\begin_layout Itemize
In TCP c'è la prassi di ricevere un segmento in ordine, generare il riscontro
 e consegnare quindi il pacchetto all'utente.
 Sfruttando questa soluzione possiamo scambiare le operazioni, quindi consegnare
 i dati e poi mandare il riscontro.
\end_layout

\begin_layout Subsection*
Soluzione 
\begin_inset Quotes eld
\end_inset


\emph on
copy-on-write
\emph default

\begin_inset Quotes erd
\end_inset

 al problema delle copie multiple
\end_layout

\begin_layout Standard
Alcuni sistemi operativi offrono una funzionalità di 
\series bold
COW
\series default
 (
\emph on
copy-on-write
\emph default
), che permette ad un processo di replicare una pagina virtuale a basso
 costo.
\end_layout

\begin_layout Standard
La pagina di memoria copiata è un puntatore alla stessa copia fisica della
 pagina originale.
\end_layout

\begin_layout Standard
Nel caso in cui la copia virtuale venisse modificata, il sistema operativo
 si occupa di generare una nuova copia fisica (questa operazione deve essere
 teoricamente rara per permettere l'efficienza di questo metodo).
\end_layout

\begin_layout Standard
Questa funzionalità non è disponibile su UNIX e Windows.
 Una soluzione simile è stata implementata nel sistema operativo Solaris
 utilizzando memoria condivisa, ma necessita di cambiare la classica semantica
 della funzionalità 
\emph on
copy
\emph default
 di UNIX.
\end_layout

\begin_layout Subsection*
Soluzione del remote DMA (RDMA)
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename rdma.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Si tratta dello spostare dati tra due memorie attraverso la rete senza coinvolge
re le CPU.
 Vediamo come viene risolto qui il problema.
\end_layout

\begin_layout Standard
L'adattatore di rete deve capire dove mettere i dati in memoria e dobbiamo
 mantenere la sicurezza.
\end_layout

\begin_layout Standard
Questo metodo è largamente utilizzato nei 
\emph on
clusters 
\emph default
e nei 
\emph on
data centers
\emph default
 per spostare dati.
\end_layout

\begin_layout Standard
In particolare viene utilizzato negli stack di protocolli 
\series bold
\emph on
Fiber Channel
\series default
\emph default
 e 
\series bold
\emph on
Infiniband
\series default
\emph default
.
\end_layout

\begin_layout Standard

\series bold
\emph on
ISCSI
\series default
\emph default
 utilizza invece 
\emph on
TCP/IP
\emph default
 e richiedere 
\emph on
TCP
\emph default
 implementato nell'adattatore di rete.
 Il vantaggio principale di 
\emph on
ISCSI
\emph default
 è il costo, molto più basso rispetto alle altre due soluzioni.
\end_layout

\begin_layout Subsubsection*
Meccanismo di funzionamento
\end_layout

\begin_layout Standard
L'applicazione invia dati di rete attraverso il kernel:
\end_layout

\begin_layout Itemize
Il processo fa una 
\emph on
system call
\end_layout

\begin_layout Itemize
Il kernel copia i dati in 
\emph on
kernel space
\end_layout

\begin_layout Itemize
Il kernel processa il pacchetto e lo copia nella memoria dell'adattatore
\end_layout

\begin_layout Standard
Per eliminare una copia dei dati si permette alle applicazioni di inviare/riceve
re i dati direttamente da/a l'adattatore.
 Il sistema operativo dà all'adattatore una lista di pagine di memoria valide
 per ogni applicazione 
\emph on
P
\emph default
.
 Quando una applicazione 
\emph on
P
\emph default
 fa una richiesta per inviare/ricevere una pagina 
\emph on
A
\emph default
,l'adattatore deve controllare se 
\emph on
A
\emph default
 è in nella lista valida.
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename pagevalidation.png
	scale 35

\end_inset


\end_layout

\begin_layout Subsubsection*
Performance della ricerca
\end_layout

\begin_layout Standard
Il problema è: se il set di pagine è una lista lineare, la validazione è
 
\begin_inset Formula $O\left(n\right)$
\end_inset

, dove 
\begin_inset Formula $n$
\end_inset

 è il numero delle pagine.
 Possiamo fare una validazione più veloce?
\end_layout

\begin_layout Standard
Possiamo applicare due principi:
\end_layout

\begin_layout Itemize
Utilizzare strutture dati migliori
\end_layout

\begin_layout Itemize
Passare 
\begin_inset Quotes eld
\end_inset

descrizioni
\begin_inset Quotes erd
\end_inset

 alle interfacce
\end_layout

\begin_layout Standard
Ricordiamoci che l'utilizzo di una tabella di hash in questo caso ha due
 svantaggi:
\end_layout

\begin_layout Itemize
Calcolare l'hash è dispendioso
\end_layout

\begin_layout Itemize
Il caso pessimo non è buono a sufficienza
\end_layout

\begin_layout Subsubsection*
Soluzione
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename sol2.png
	scale 35

\end_inset


\end_layout

\begin_layout Standard
Il set di pagine valide può essere salvato in un array.
 L'applicazione passa un indice a questo array.
 
\end_layout

\begin_layout Subsection*
Problematiche di sicurezza
\end_layout

\begin_layout Standard
Come evitiamo che un processo scriva o legga nella memoria dell'adattatore
 senza essere autorizzato? 
\end_layout

\begin_layout Standard
Un processo può sovrascrivere i dati di altri processi all'interno dell'adattato
re?
\end_layout

\begin_layout Standard
Per questo motivo utilizziamo gli 
\series bold
Application Device Channels
\series default
: l'applicazione dice all'adattatore 
\begin_inset Quotes eld
\end_inset

prendi dalla mia memoria questo blocco di dati
\begin_inset Quotes erd
\end_inset

, oppure 
\begin_inset Quotes eld
\end_inset

copia questo pacchetto che è arrivato nella mia pagina di memoria
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
Per evitare problemi di sicurezza, il sistema operativo carica nella memoria
 dell'adattatore un insieme di numeri di pagina valide.
 L'adattatore dovrà preoccuparsi di verificare che per ogni richiesta la
 pagina indicata sia una pagina valida.
\end_layout

\begin_layout Section*
Timers
\end_layout

\begin_layout Standard
Sono uno strumento onnipresente nell'ambito delle telecomunicazioni.
 Servono in tutti i protocolli.
 Concentrandoci nei protocolli di strato 3 e 4 abbiamo bisogno di timer
 principalmente per:
\end_layout

\begin_layout Itemize
La gestione della 
\series bold
ritrasmissione
\end_layout

\begin_layout Itemize
Eventi di invio dei 
\series bold
riscontri
\series default
.
 
\end_layout

\begin_layout Itemize
Tutto il processo di gestione del 
\series bold
controllo di fusso
\end_layout

\begin_layout Standard
Tutti i sistemi moderni hanno timers 
\series bold
hardware
\series default
 che inviano 
\series bold
interrupts
\series default
.
\end_layout

\begin_layout Standard
Se dovessimo utilizzare per ogni protocollo degli interrupt hardware per
 i timer, la macchina dovrebbe occuparsi praticamente solo della gestione
 dei timer, dato che essi sono molti e molto frequenti.
\end_layout

\begin_layout Standard
Quello che si fa è quindi assegnare una gestione unitaria dei timers.
\end_layout

\begin_layout Standard
Il sistema operativo BSD, nella su implementazione TCP/IP, utilizza 2 timers:
 uno a 
\emph on
200 ms
\emph default
 e uno a 
\emph on
500 ms
\emph default
.
 L'idea è bassa granularità e quindi basso overhead.
\end_layout

\begin_layout Standard
Se ad esempio avessimo un timer che deve scattare a 
\emph on
150 ms
\emph default
 come facciamo? Un metodo brutale è l'approssimazione a 
\emph on
200 ms
\emph default
 per sfruttare il timer già presente.
 Però ci sono applicazioni, tipo quelle multimediali, che necessitano timers
 molto più piccoli (nell'ordine dei 
\emph on
10 ms
\emph default
), quindi abbiamo anche questo problema da risolvere.
 Inoltre non dimentichiamoci che l'RTT può arrivare anche nell'ordine dei
 
\begin_inset Formula $500\mu s$
\end_inset

.
\end_layout

\begin_layout Subsection*
Operazioni tipiche sui timers
\end_layout

\begin_layout Standard
Vediamo ora quali sono le operazioni che posso fare sui timers:
\end_layout

\begin_layout Itemize

\series bold
\emph on
StartTimer(Interval, Id, ExpiryAction) 
\series default
\emph default
: Avvia un timer che scade dopo 
\emph on
Interval
\emph default
.
 Assegnamo un identificatore 
\emph on
Id
\emph default
 e specifichiamo una azione da svolgere quando scade il timer: 
\emph on
ExpiryAction
\emph default
.
\end_layout

\begin_layout Itemize

\series bold
\emph on
StopTimer(Id)
\series default
\emph default
 : Ferma un timer avviato (ad esempio se arriva un pacchetto prima dello
 scadere del timer).
\end_layout

\begin_layout Itemize

\series bold
\emph on
PerTickBookkeeping
\series default
\emph default
 : È una funzione che viene chiama ad ogni step del clock (ogni intervallo
 di tempo 
\begin_inset Formula $T$
\end_inset

, che è la granularità).
\end_layout

\begin_layout Itemize

\series bold
\emph on
ExpiryProcessing
\series default
\emph default
 : È la funzione che viene chiamata quando scade un timer ed esegue le operazion
i indicate in 
\emph on
ExpiryAction
\emph default
.
\end_layout

\begin_layout Standard
Valuteremo la complessità rispetto al numero di timer che vengono lanciati.
\end_layout

\begin_layout Standard
Poiché il numero di timers è proporzionale al numero di connessioni e alla
 velocità di collegamento, al crescere della velocità delle reti, 
\series bold
il numero di timer cresce
\series default
.
 Le primissime versioni di BSD si bloccavano con 7 SYN ricevuti ancora non
 riscontrati.
\end_layout

\begin_layout Subsection*
Prima soluzione: lista
\end_layout

\begin_layout Standard
Tutti i timers li mettiamo in un array scrivendoci dentro il 
\begin_inset Quotes eld
\end_inset

tempo che manca
\begin_inset Quotes erd
\end_inset

, ogni 
\emph on
T
\emph default
 unità di tempo chiamiamo la funzione 
\emph on
PerTickBookkeeping
\emph default
 che decrementa i timer di 
\emph on
T
\emph default
.
\end_layout

\begin_layout Standard
Con questa solzione però ad ogni intervallo di tempo 
\emph on
T
\emph default
 devo:
\end_layout

\begin_layout Itemize
Scorrere tutto l'array
\end_layout

\begin_layout Itemize
Decrementare tutti i valori e verificare che non sia scattato un timer
\end_layout

\begin_layout Itemize
Se scatta un timer devo eseguire le operazioni previste.
\end_layout

\begin_layout Standard
Abbiamo quindi una complessità pari a 
\begin_inset Formula $O\left(n\right)$
\end_inset

 perché devo scorrere tutta la lista.
\end_layout

\begin_layout Subsection*
Seconda soluzione: lista ordinata
\end_layout

\begin_layout Standard
I timer sono in una lista ordinata per tempo di scatto.
 Il tempo corrente viene aggiornato in una cella di memoria separata.
 Nel momento in cui il tempo corrente supera o è uguale al tempo di scatto
 del timer in cima alla lista, compio le operazioni legate a quel timer.
\end_layout

\begin_layout Standard
Il costo di questa soluzione è:
\end_layout

\begin_layout Itemize
Inserimento nella lista ordinata di un nuovo timer (
\series bold
\emph on
StartTimer
\series default
\emph default
) : caso pessimo 
\begin_inset Formula $O\left(n\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Il costo di inserimento 
\bar under
medio
\bar default
 nella lista ordinata dipende in modo forte dalla distribuzione dei dati
 che devo inserire.
\end_layout

\begin_layout Itemize
Il fatto è che non abbiamo una lunga storia (come nel sistema telefonico)
 a cui riferisci per fare valutazioni in merito al traffico da aspettarci.
 Non possiamo quindi prevedere la distribuzione.
\end_layout

\end_deeper
\begin_layout Itemize
Cancellazione della lista ordinata (
\series bold
\emph on
StopTimer
\series default
\emph default
) : 
\begin_inset Formula $O\left(1\right)$
\end_inset

 se la lista è doppiamente linkata.
\end_layout

\begin_layout Itemize
Lookup nella lista (
\series bold
\emph on
PerTickBookkeeping
\series default
\emph default
) : 
\begin_inset Formula $O\left(1\right)$
\end_inset

 assumendo che in diversi cicli di clock non ci sono scadenze di timers.
\end_layout

\begin_layout Standard
Quindi otteniamo in generale un caso pessimo 
\begin_inset Formula $O\left(n\right)$
\end_inset

.
 
\end_layout

\begin_layout Standard
Anche con l'utilizzo di tecniche avanzate (heap sorting o alberi) non si
 va oltre 
\begin_inset Formula $O\left(log\left(n\right)\right)$
\end_inset

.
 Noi in realtà vorremmo 
\begin_inset Formula $O\left(1\right)$
\end_inset

.
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset


\emph on
Di solito si stappa lo spumante con soluzioni sub-lineari
\emph default

\begin_inset Quotes erd
\end_inset

 (cit.)
\end_layout

\begin_layout Subsection*
Timing Wheels
\end_layout

\begin_layout Standard
Il nome deriva da quei contenitori dove ci sono le schede con le indicazioni
 di un orario lavorativo che vengono timbrate a vari orari.
\end_layout

\begin_layout Standard
Noi facciamo la stessa cosa.
 In sostanza sfruttiamo il fatto che il tempo aumenta sempre e non è posssibile
 mettere un timer nel passato.
\end_layout

\begin_layout Standard
Quindi:
\end_layout

\begin_layout Itemize
Costruiamo un array circolare (o 
\begin_inset Quotes eld
\end_inset

coda
\begin_inset Quotes erd
\end_inset

) con un numero di celle uguale ad un qualche valore prefissato 
\emph on
MAXINTERVAL
\emph default
.
\end_layout

\begin_layout Itemize
Facciamo l'importante assunzione di 
\series bold
non fissare scadenze
\series default
 al di là del valore 
\emph on
MAXINTERVAL
\emph default
.
\end_layout

\begin_layout Itemize
Nel primo elemento dell'array abbiamo il prossimo intervallo di tempo.
\end_layout

\begin_layout Itemize
Ogni elemento dell'array contiene una lista di timers che scattano a quell'inter
vallo di tempo.
\end_layout

\begin_layout Standard
Teniamo conto che i timer all'interno delle liste possono anche 
\bar under
non essere ordinati
\bar default
 esattamente in ordine cronologico.
 Potremmo tenere delle liste ordinate ma ci costerebbe.
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset


\emph on
Welcome to the world of tradeoffs
\begin_inset Quotes erd
\end_inset

 (cit.)
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename wheels.png
	scale 25

\end_inset


\end_layout

\begin_layout Standard
Il tempo corrente è una sorta di puntatore ad un elemento dell'array circolare.
\end_layout

\begin_layout Standard
Vediamo i costi di questa soluzione:
\end_layout

\begin_layout Itemize
Inserimento di un nuovo timer (
\series bold
\emph on
StartTimer
\series default
\emph default
) : 
\begin_inset Formula $O\left(1\right)$
\end_inset

 (la lista non è ordinata)
\end_layout

\begin_layout Itemize
Cancellazione di un timer (
\series bold
\emph on
StopTimer
\series default
\emph default
) : 
\begin_inset Formula $O\left(1\right)$
\end_inset

 se la lista è doppiamente linkata
\end_layout

\begin_layout Itemize
Lookup (
\series bold
\emph on
PerTickBookkeeping
\series default
\emph default
) : Spostiamo l'indicatore di inizio dell'array circolare.
 Abbiamo un costo 
\begin_inset Formula $O\left(1\right)$
\end_inset

 più l'eventuale 
\bar under
costo di scatto
\bar default
 del/dei timer.
\end_layout

\begin_layout Standard
Uno degli svantaggi è che richiede parecchio spazio a seconda del valore
 di 
\emph on
MAXINTERVAL.
 
\emph default
Il valore massimo potrebbe essere molto grande e rischiamo di sprecare spazio
 per niente.
\end_layout

\begin_layout Standard
Inoltre in questo modo succede spesso che la maggior parte dei timers sia
 nei primi posti, generando delle liste relativamente lunghe, e rendendo
 quindi il 
\emph on
PerTickBookkeeping
\emph default
 più grande di 
\begin_inset Formula $O\left(1\right)$
\end_inset

.
\end_layout

\begin_layout Subsection*
Hashed Wheels
\end_layout

\begin_layout Standard
Voglio dimensionare l'array indipendentemente dal 
\emph on
MAXINTERVAL
\emph default
.
 Possiamo sfruttare una struttura ad hash al posto di un array semplice.
\end_layout

\begin_layout Standard
Trasformiamo quindi l'array in una tabella di hash e utilizziamo una funzione
 di hash a modulo (cioè utilizziamo solo i bit di ordine inferiore).
 
\end_layout

\begin_layout Standard
Sappiamo che i timer sono più frequentemente vicino all'istante attuale
 e più difficilmente lontani rispetto all'istante attuale, quindi la scelta
 della tabella di hash rispetto all'array semplice migliora le performance.
 Ogni cella della tabella di hash punta ad una lista 
\series bold
ordinata
\series default
 di timers (come visti nel caso di lista semplice).
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename hashwheel.png
	scale 25

\end_inset


\end_layout

\begin_layout Standard
Dobbiamo aspettarci che i timers si distribuiscano uniformemente all'interno
 della tabella e in media devo aspettarmi che il numero di timers per ogni
 lista sia 1.
\end_layout

\begin_layout Standard
Vediamo i costi:
\end_layout

\begin_layout Itemize
Inserimento di un nuovo timer (
\series bold
\emph on
StartTimer
\series default
\emph default
) : 
\begin_inset Formula $O\left(n\right)$
\end_inset

 nel caso pessimo in cui dobbiamo scorrere tutta la lista per trovare la
 posizione giusta dove inserire il timer.
\end_layout

\begin_layout Itemize
Cancellazione di un timer (
\series bold
\emph on
StopTimer
\series default
\emph default
) : 
\begin_inset Formula $O\left(1\right)$
\end_inset

 se la lista è doppiamente linkata.
\end_layout

\begin_layout Itemize
Lookup (
\series bold
\emph on
PerTickBookkeeping
\series default
\emph default
) : Nel caso pessimo è 
\begin_inset Formula $O\left(n\right)$
\end_inset

 (tutti i timers scadono insieme), però viste le assunzioni precedenti sulla
 lista ordinata è solitamente 
\begin_inset Formula $O\left(1\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Potremmo decidere di non tenere le liste ordinate, guadagnando un 
\begin_inset Formula $O\left(1\right)$
\end_inset

 nello 
\emph on
StartTimer
\emph default
.
 Questo significa però portare più lavoro (arrivare a 
\begin_inset Formula $O\left(n\right)$
\end_inset

) al 
\emph on
PerTickBookkeeping
\emph default
, il che ci porta ad un cattivo tradeoff.
\end_layout

\begin_layout Subsection*
Hierarchical Wheels
\end_layout

\begin_layout Standard
Si basa sempre sull'idea di utilizzare degli array circolari però suddivisi
 per 
\begin_inset Quotes eld
\end_inset

unità
\begin_inset Quotes erd
\end_inset

.
 Per capire il concetto vediamo un paragone con il sistema sessagesimale:
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename hierarchicalwheels.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
In questo esempio dobbiamo suddividere dei compiti da svolgere in diversi
 secondi di diversi minuti di diverse ore del giorno.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Controllare quello che segue
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
L'array delle ore è una tabella di hash che contiene al suo interno tutte
 le informazioni sui compiti di ogni ora.
 Quando il puntatore delle ore passa ad una nuova ora, vengono presi tutti
 i timers e copiati in modo ordinato nell'array dei minuti.
\end_layout

\begin_layout Itemize
Nell'array dei minuti quando si arriva ad un nuovo minuto, tutti i timers
 di quel minuto vengono messi nell'array dei secondi e per ogni secondo
 si scandiscono i timers.
\end_layout

\begin_layout Part*
Demultiplazione 
\end_layout

\begin_layout Section*
Demultiplazione a strati
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename demultiplexing.png
	scale 25

\end_inset


\end_layout

\begin_layout Standard
Vediamo come funziona solitamente la demultiplazione:
\end_layout

\begin_layout Itemize
Il pacchetto o più precisamente la trama Ethernet, si presenta all'adattatore,
 l'adattatore vede un campo, che nel caso della Ethernet si chiama EtherType,
 questo campo identifica un protocollo di livello 3.
\end_layout

\begin_layout Itemize
Il sistema operativo capisce a qule protocollo va consegnato il pacchetto,
 ad esempio TCP o UDP.
\end_layout

\begin_layout Itemize
Come fa il sistema operativo per capire qual'è il processo a cui consegnare
 il pacchetto? Guarda i numeri di porta.
 
\end_layout

\begin_deeper
\begin_layout Itemize
In caso di UDP si guarda solo il numero di porta sorgente e destinazione.
\end_layout

\begin_layout Itemize
In TCP la demultiplazione invece avviene guardando la quadrupla 
\series bold
porta sorgente, porta desintazione , ip sorgente, ip destinazione
\series default
.
\end_layout

\end_deeper
\begin_layout Standard
Ovviamente con questo tipo di approccio abbiamo un costo minimo di lookup
 ad ogni strato.
\end_layout

\begin_layout Standard
Ricordiamoci poi che molti protocolli sfruttano il meccanismo di tunneling
 dove un insieme di traffico viene infilato in un'unica connessione (ad
 esempio HTTP 
\emph on
persistent
\emph default
).
\end_layout

\begin_layout Subsection*
Early demultiplexing
\end_layout

\begin_layout Standard
Decidere dove consegnare un pacchetto è una operazione costosa perchè dobbiamo
 analizzare ogni strato.
 Si tenta quindi di fare l'
\emph on
early demultiplexing
\emph default
, cioè iniziare a leggere i campi del pacchetto fin da quando arriva sulla
 scheda Ethernet.
\end_layout

\begin_layout Standard
Nel progettare un sistema di 
\emph on
early demultiplexing 
\emph default
ci poniamo una serie di obiettivi:
\end_layout

\begin_layout Itemize
Garantire la sicurezza (far arrivare i pacchetti solo a chi li deve ricevere).
\end_layout

\begin_layout Itemize
Raggiungere il cosìdetto 
\begin_inset Quotes eld
\end_inset


\emph on
wire speed processing
\emph default

\begin_inset Quotes erd
\end_inset

 , cioè aumentare la velocità.
\end_layout

\begin_deeper
\begin_layout Itemize
Teniamo conto che normalmente il prezzo che pago per ricevere un paccetto
 non dipende tanto dalla lunghezza del pacchetto.
\end_layout

\begin_layout Itemize
Per questo motivo di solito si misurano le prestazioni di un sistema in
 termini di pacchetti al secondo, piuttosto che in termini di byte al secondo.
\end_layout

\end_deeper
\begin_layout Itemize
Se abbiamo 
\begin_inset Formula $n$
\end_inset

 filtri, vogliamo che il costo computazionale sia più piccolo di effettuare
 
\begin_inset Formula $n$
\end_inset

 volte l'operazione di filtraggio: proprietà di 
\series bold
\emph on
composability
\series default
\emph default
.
\end_layout

\begin_layout Subsection*
CSPF (CMU/Stanford Packet Filter)
\end_layout

\begin_layout Standard
È un meccanismo a filtro utilizzato per smistare pacchetti.
 Ogni filtro è rappresentato come un albero di operatori e si effettuano
 dei confronti in parallelo.
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename cspf.png
	scale 25

\end_inset


\end_layout

\begin_layout Itemize
Contro: è inefficiente su sistemi basati su registri (era un meccanismo
 ideato per macchine a stack).
\end_layout

\begin_layout Itemize
Pro: facile, semplice da implementare
\end_layout

\begin_layout Subsection*
BPF (Berkeley Packet Filter)
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename bpf.png
	scale 25

\end_inset


\end_layout

\begin_layout Standard
È quello più utilizzato al giorno d'oggi.
\end_layout

\begin_layout Standard
È un modo di rappresentare un insieme di controlli su un pacchetto, per
 fare valutazioni sulla corrispondenza ad un filtro.
\end_layout

\begin_layout Standard
Utilizza un linguaggio basato sui registri.
\end_layout

\begin_layout Subsection*
BPF nelle implementazioni reali
\end_layout

\begin_layout Standard
BPF è implementato in diversi kernel, tra cui quello Linux, e agisce da
 filtro che opera in modo parallelo allo stack TCP/IP come rappresentato
 nella figura sottostante.
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename bpf2.png
	scale 28

\end_inset


\end_layout

\begin_layout Standard
Considerazioni sulle performance:
\end_layout

\begin_layout Itemize
L'operazione di filtraggio può essere fatta prima del buffering e risparmiamo
 tempo quando la maggior parte dei pacchetti non sono di interesse.
\end_layout

\begin_layout Itemize
I pacchetti vengono consegnati a blocchi piuttosto che uno per uno.
\end_layout

\begin_layout Subsection*
Pathfinder
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename pathfinder.png
	scale 25

\end_inset


\end_layout

\begin_layout Standard
Al posto di filtri che rispondono 
\begin_inset Quotes eld
\end_inset

sì/no
\begin_inset Quotes erd
\end_inset

, abbiamo filtri che avvisano quale processo contattare.
 La 
\series bold
struttura è ad albero non binario
\series default
.
 Vengono utilizzate le tabelle di hash.
\end_layout

\begin_layout Standard
Un problema dei filtri precedenti è la incapacità di gestire la frammentazione.
\end_layout

\begin_layout Standard
Noi possiamo chiedere il demultiplaxing pacchetto per pacchetto, però ad
 esempio IPv4 fornisce la frammentazione.
 Cosa succede quando arrivano frammenti? Il primo contiene le informazioni
 di trasporto (ad esempio l'header TCP), mentre tutti i frammenti successivi
 ne sono privi!
\end_layout

\begin_layout Standard
Per i layered demultiplexing non è un problema perchè allochiamo i frammenti
 per ricostruire, prima di recapitare.
\end_layout

\begin_layout Section*
BPF e Tcpdump
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename bpf2.png
	scale 28

\end_inset


\end_layout

\begin_layout Itemize
BPF oltre ad essere un modo per rappresentare filtri, è una parte di codice
 che viene eseguita all'interno del kernel in parallelo allo stack TCP/IP.
\end_layout

\begin_layout Itemize
Il driver dell'adattatore di rete consegna i suoi pacchetti sia allo stack
 protocollare standard, sia al layer BPF.
\end_layout

\begin_deeper
\begin_layout Itemize
Molto spesso, quando si utilizza questo meccanismo di filtraggio, si pone
 l'adattatore di rete nelle condizioni di catturare tutti i pacchetti indipenden
temente dal loro MAC di destinazione.
\end_layout

\begin_layout Itemize
Se l'adattatore viene riconfigurato, vengono analizzati anche i pacchetti
 non destinati al nostro MAC.
\end_layout

\end_deeper
\begin_layout Itemize
La interfaccia tra userspace e kernelspace per catturare i pacchetti è la
 
\series bold
pcap
\series default
.
\end_layout

\begin_deeper
\begin_layout Itemize
Diversi programmi in userspace possono utilizzare le API offerte dalla libpcap
 per configurare i filtri BPF e ricevere i dati.
 Tcpdump e wireshark sono tra i più noti.
\end_layout

\end_deeper
\begin_layout Itemize
I pacchetti che vengono accettati da un filtro in spazio kernel, vengono
 accodati in un buffer, quando il buffer contiene nuovi elementi viene avvisato
 il processo utente.
 L'applicazione li andrà a prelevare quando il sistema operativo decide
 che l'applicazione deve essere servita.
\end_layout

\begin_layout Standard
Possono verificarsi problemi quando i buffer si riempiono eccessivamente
 se l'applicazione è troppo lenta a rispondere.
\end_layout

\begin_layout Subsubsection*
Considerazioni sulle performance
\end_layout

\begin_layout Itemize
L'operazione di filtraggio può essere fatta prima del buffering e risparmiamo
 tempo quando la maggior parte dei pacchetti non sono di interesse.
\end_layout

\begin_layout Itemize
I pacchetti vengono inseriti in un buffer in attesa che l'applicazione sia
 pronta a riceverli (questo evita di inviare segnali in continuazione per
 ogni pacchetto)
\end_layout

\begin_layout Itemize
I pacchetti vengono consegnati a blocchi piuttosto che uno per uno.
\end_layout

\begin_layout Section*
Macchina BPF e filtri BPS
\end_layout

\begin_layout Standard
È una macchina pensata da Jacobson, che consiste di:
\end_layout

\begin_layout Itemize
Un accumulatore
\end_layout

\begin_layout Itemize
Un indice di registro
\end_layout

\begin_layout Itemize
Uno spazio di memoria
\end_layout

\begin_layout Itemize
Un program counter
\end_layout

\begin_layout Subsection*
Istruzioni della macchina BPS
\end_layout

\begin_layout Itemize
Caricamento in un 
\series bold
registro
\series default
 o in un 
\series bold
accumulatore
\series default
 (LOAD)
\end_layout

\begin_deeper
\begin_layout Itemize
Di un valore immediato
\end_layout

\begin_layout Itemize
Di dati a pacchetto a offset calcolato
\end_layout

\begin_layout Itemize
Dimensione di un pacchetto
\end_layout

\begin_layout Itemize
Memoria
\end_layout

\end_deeper
\begin_layout Itemize
Salvataggio di un accumulatore o registro in memoria (STORE)
\end_layout

\begin_layout Itemize
Istruzioni ALU per calcoli aritmetici
\end_layout

\begin_layout Itemize
Operazione di BRANCH basata su confronti tra costanti o registri e accumulatore
\end_layout

\begin_layout Itemize
Il calcolo della dimensione del prefisso di un pacchetto da salvare
\end_layout

\begin_layout Itemize
Altre istruzioni per il trasferimento tra i registri
\end_layout

\begin_layout Standard
Solitamente le istruzioni sono allineate a 32 bit
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename setistruzioni.png
	scale 35

\end_inset


\end_layout

\begin_layout Subsubsection*
Esempio 1 - Selezione di tutti i pacchetti da/a l'host 10.0.0.1
\end_layout

\begin_layout LyX-Code
(000) ldh    [12]
\end_layout

\begin_layout LyX-Code
(001) jeq    #0x800        jt 2    jf 6
\end_layout

\begin_layout LyX-Code
(002) ld     [26]
\end_layout

\begin_layout LyX-Code
(003) jeq    #0xa000001    jt 12   jf 4
\end_layout

\begin_layout LyX-Code
(004) ld     [30]
\end_layout

\begin_layout LyX-Code
(005) jeq    #0xa000001    jt 12   jf 13
\end_layout

\begin_layout LyX-Code
(006) jeq    #0x806        jt 8    jf 7
\end_layout

\begin_layout LyX-Code
(007) jeq    #0x8035       jt 8    jf 13
\end_layout

\begin_layout LyX-Code
(008) ld     [28]
\end_layout

\begin_layout LyX-Code
(009) jeq    #0xa000001    jt 12   jf 10
\end_layout

\begin_layout LyX-Code
(010) ld     [38]
\end_layout

\begin_layout LyX-Code
(011) jeq    #0xa000001    jt 12   jf 13
\end_layout

\begin_layout LyX-Code
(012) ret    #65535
\end_layout

\begin_layout LyX-Code
(013) ret    #0
\end_layout

\begin_layout Subsection*
Sintassi BPF
\end_layout

\begin_layout Itemize
Ogni 
\series bold
espressione
\series default
 consiste di una o più 
\series bold
primitive
\series default
 combinate con 
\series bold
operatori logici
\series default
.
\end_layout

\begin_layout Itemize
Ogni 
\series bold
primitiva
\series default
 consiste di uno o più 
\series bold
qulificatori
\series default
 e un nome o un numero.
\end_layout

\begin_layout Standard
Ci sono tre tipi di 
\series bold
qualificatori
\series default
:
\end_layout

\begin_layout Itemize
Di 
\series bold
tipo 
\emph on
: 
\series default
\emph default
host, net, port, portrange, ...
\end_layout

\begin_deeper
\begin_layout Itemize
Possono essere utilizzati anche nomi simbolici di protocolli e flag, oppure
 di hostname.
\end_layout

\begin_layout Itemize
È possibile specificare prefissi di rete (utilizzando 
\begin_inset Quotes eld
\end_inset

net ...
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
Di 
\series bold
direzione
\series default
 : src, dst, src or dst, src and dst
\end_layout

\begin_layout Itemize
Di 
\series bold
protocollo
\series default
: ether, fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp, udp
\end_layout

\begin_deeper
\begin_layout Itemize
Per leggere campi specifici di un protocollo la sintassi è: 
\emph on
proto[expr:size]
\end_layout

\end_deeper
\begin_layout Standard
Ci sono poi delle keyword speciali tipo 
\emph on
boardcast
\emph default
 e anche operatori matematici.
\end_layout

\begin_layout Standard
Possiamo utilizzare ovviamente le parentesi tonde per delimitare le epressioni
 e chiararire le precedenze.
\end_layout

\begin_layout Standard
Ricordiamoci che 
\series bold
BPF non lavora a livello applicativo
\series default
: non possiamo mettere dei filtri sui payload dei pacchetti (cosa che invece
 può fare ad esempio il programma 
\emph on
wireshark
\emph default
 sfruttando le libpcap, tuttavia questo filtraggio viene fatto in userspace!).
 BPF ci permette solo di analizzare gli headers.
\end_layout

\begin_layout Subsubsection*
Esempi:
\end_layout

\begin_layout Itemize

\emph on
'not ip' 
\emph default
: Mostra tutti i pacchetti che non contengono datagrammi IP.
\end_layout

\begin_layout Itemize

\emph on
'ip[2:2] == 40' 
\emph default
: Mostra tutti i pacchetti IP che hanno dimensione 40.
 
\emph on
[2:2]
\emph default
 significa che il valore è il terzo Byte (si parte a contare da zero), ed
 è un valore numerico lungo 2 Byte.
 Riguardando l'header IP possiamo convincerci di questa sintassi.
\end_layout

\begin_layout Itemize

\emph on
'tcp[tcpflags] & (tcp-syn|tcp-fin) != 0 and not src and dst net localnet
\emph default
' : Seleziona tutti i pacchetti tcp che contengano il flag SYN o FIN e non
 siano originati o destinati alla rete locale (scheda di rete di loopback).
\end_layout

\begin_layout Itemize

\emph on
'icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply'
\emph default
 : Selezioni tutti i pacchetti ICMP che non sono di tipo 
\emph on
EchoRequest 
\emph default
o 
\emph on
EchoReply
\emph default
.
\end_layout

\begin_layout Subsubsection*
Tcpdump e wireshark
\end_layout

\begin_layout Standard
Tcpdump è un tool da riga di comando che analizza i pacchetti utilizzando
 le API delle librerie pcap.
 Esso stampa come output:
\end_layout

\begin_layout Itemize
L'ora a cui è stato catturato un pacchetto
\end_layout

\begin_layout Itemize
Il contenuto del pacchetto (può riconoscere la maggior parte dei protocolli
 noti)
\end_layout

\begin_layout Standard
Wireshark è un tool grafico simile a TCPdump che può anche riconoscere la
 maggior parte dei protocolli applicativi.
 Esso può anche effettuare il post-processing e post-filtering dei pacchetti
 catturati ricostruendo stream di comunicazione e molto altro.
\end_layout

\begin_layout Itemize
Pro: Possiamo mettere filtri anche a livello applicativo
\end_layout

\begin_layout Itemize
Contro: Il filtro viene fatto in userspace dopo aver catturato i dati, questo
 è oneroso per il processore e inefficiente.
\end_layout

\begin_layout Subsubsection*
Formato dei file pcap
\end_layout

\begin_layout Standard
Sia TCPdump che wireshark utilizzano come formato di file dove salvare i
 pacchetti il formato pcap.
 Vediamo come è strutturato:
\end_layout

\begin_layout Itemize
Un 
\series bold
header globale 
\series default
che contiene:
\end_layout

\begin_deeper
\begin_layout Itemize
Un 
\emph on
magic number
\emph default
 e un numero di versione
\end_layout

\begin_layout Itemize
Il fusorario considerato durante la cattura dei dati
\end_layout

\begin_layout Itemize
L'accuratezza del timer di sistema
\end_layout

\begin_layout Itemize
La massima lunghezza dei pacchetti catturati
\end_layout

\begin_layout Itemize
Il tipo di collegamento su cui sono stati catturati (ethernet, ppp, ...)
\end_layout

\end_deeper
\begin_layout Itemize
Per ogni pacchetto viene salvato un header e i dati del pacchetto.
 Nell' header troviamo:
\end_layout

\begin_deeper
\begin_layout Itemize
Un timestamp con secondi e microsecondi (i microsecondi possono essere poco
 affidabili vista l'accuratezza del timer)
\end_layout

\begin_layout Itemize
La dimensione dei dati catturati
\end_layout

\begin_layout Itemize
La dimensione originale del pacchetto
\end_layout

\end_deeper
\begin_layout Part*
Routers 1
\end_layout

\begin_layout Standard
Vedremo come si implementano i protocolli nei nodi intermedi.
 Parleremo principalmente di routers e delle caratteristiche dei protocolli
 di livello 2 e 3.
\end_layout

\begin_layout Section*
Lookup
\end_layout

\begin_layout Standard
Vogliamo analizzare il problema di come si trovano le informazioni di intestazio
ne protocollare all'interno del dispositivo (
\series bold
tabella di inoltro
\series default
 o 
\series bold
tabella di routing
\series default
 a seconda del livello 2/3).
\end_layout

\begin_layout Subsubsection*
Tipi di indirizzi
\end_layout

\begin_layout Standard
Esistono vari tipi di indirizzi nelle reti.
 Le due grandi famiglie sono:
\end_layout

\begin_layout Itemize
Gli indirizzi di tipo 
\series bold
flat
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Lunghezza fissa
\series default
, non c'è alcuna organizzazione di carattere topologico/gerarchico all'interno
 dell'indirizzo.
\end_layout

\begin_layout Itemize
Macchine che sono molto vicine possono avere indirizzi molto diversi, macchine
 molto lontane possono avere indirizzi molto simili.
\end_layout

\begin_layout Itemize
Sono gli indirizzi utilizzati ad esempio nell'architettura Ethernet.
 
\end_layout

\begin_layout Itemize
Un altro protocollo che utilizza indirizzi flat è il protocollo 
\series bold
MPLS
\series default
 (che vedremo in seguito).
 Si tratta di un protocollo intermedio tra 2 e 3.
\end_layout

\end_deeper
\begin_layout Itemize
Gli indirizzi di tipo 
\series bold
gerarchico
\end_layout

\begin_layout Subsection*
Exact-Match lookup
\end_layout

\begin_layout Standard
Il nostro scopo è ricercare un indirizzo in una tabella.
 Vogliamo trovare esattamente quell'indirizzo e non uno simile.
\end_layout

\begin_layout Standard
Per farlo dobbiamo cercare all'interno della tabella una chiave 
\begin_inset Formula $K$
\end_inset

 di lunghezza fissata e dobbiamo recuperare tutte le informazioni collegate
 alla chiave 
\begin_inset Formula $K$
\end_inset

.
\end_layout

\begin_layout Standard
Ci sono parecchie tecniche per risolvere questo problema.
\end_layout

\begin_layout Subsubsection*
Wire-speed negli Ethernet bridge
\end_layout

\begin_layout Standard
Il problema principale che limita la nostra capacità decisionale è che noi
 vogliamo effettuare queste richerche a 
\series bold
\emph on
wire-speed
\series default
\emph default
.
 Vogliamo che non ci siano 
\begin_inset Quotes eld
\end_inset

buchi
\begin_inset Quotes erd
\end_inset

 (tempi morti) tra la ricerca di un pacchetto e il successivo.
\end_layout

\begin_layout Itemize
Questo tipo di problema inizia a comparire nel contesto delle reti quando
 parliamo di un 
\series bold
Ethernet bridge
\series default
, che possiamo considerare un caso 
\begin_inset Quotes eld
\end_inset

classico
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Il nostro scopo è quindi aumentare la capacità di una rete locale cercando
 di avere dei dispositivi economici.
\end_layout

\begin_layout Itemize
L'idea di fondo dell'introduzione dell'Ethernet bridge è quella di sfruttare
 
\series bold
il principio di 
\emph on
località del traffico
\series default
\emph default
: macchine vicine tendono a comunicare con altre macchine vicine, piuttosto
 che con macchine lontane.
 Lo scopo del bridge è quello di tenere separati i domini di broadcast e
 mantenere i pacchetti interni alle LAN confinati al loro interno.
\end_layout

\begin_layout Standard
Consideriamo bridge Ethernet a 2 porte per semplicità.
\end_layout

\begin_layout Standard
Ci serve una tabella che 
\series bold
associ agli indirizzi MAC
\series default
 della rete 
\series bold
al numero di porta
\series default
 su cui gli indirizzi MAC sono presenti.
\end_layout

\begin_layout Standard
Sappiamo già come si popola questa tabella (vedi appunti del corso di telecomuni
cazioni).
\end_layout

\begin_layout Standard
Ci serve quindi un sistema con un 
\series bold
processore
\series default
 e un 
\series bold
meccanismo di lookup
\series default
 che acceda ad una 
\series bold
memoria
\series default
.
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename bridge.png
	scale 20

\end_inset


\end_layout

\begin_layout Standard
Misuriamo le prestazioni 
\emph on
wire-speed
\emph default
 nel caso pessimo: una trama Ethernet
\begin_inset Foot
status open

\begin_layout Plain Layout
In questo calcolo ci stiamo riferendo all'architettura 802.3 originale da
 10Mbps
\end_layout

\end_inset

 da 64 Byte che arriva ogni 
\begin_inset Formula $\frac{64\cdot8}{10\,\text{Mbps}}=51.2\mu s$
\end_inset

 
\end_layout

\begin_layout Itemize
Con due porte abbiamo bisogno di fare un lookup ogni 
\begin_inset Formula $12.8\mu s$
\end_inset


\end_layout

\begin_layout Subsubsection*
Soluzione del bridge DEC
\end_layout

\begin_layout Itemize
Il primo bridge DEC utilizzava una ram 
\series bold
DRAM
\series default
 con tempo di accesso 
\begin_inset Formula $100\, ns$
\end_inset

 .
 La tabella era progettata per contenere massimo 8000 elementi.
\end_layout

\begin_layout Itemize
La soluzione che fu adottata ai tempi era essenzialmente una ricerca binaria.
 La scelta fu fatta perché la ricerca binaria avrebbe dato tempi di ricerca
 deterministici.
 
\end_layout

\begin_layout Standard
Il 
\series bold
collo di bottiglia
\series default
 era dettato unicamente dall'
\series bold
accesso alla memoria
\series default
.
\end_layout

\begin_layout Itemize
Una tabella da 8000 righe richiede 
\begin_inset Formula $log_{2}\left(8000\right)=13$
\end_inset

 accessi .
 Il tempo di lookup finale è di 
\begin_inset Formula $1.3\mu s$
\end_inset


\end_layout

\begin_layout Itemize
Il problema che si pone è che questa scelta implementativa non è in grado
 di scalare a velocità più alte.
\end_layout

\begin_layout Subsection*
FDDI lookup
\end_layout

\begin_layout Standard
FDDI (
\series bold
F
\series default
iber 
\series bold
D
\series default
istributed 
\series bold
D
\series default
ata 
\series bold
I
\series default
nterface), si tratta di un protocollo pensato per comunicazioni in fibra
 ottica che utilizza gli stessi indirizzi a livello MAC uguali a quelli
 Ethernet.
\end_layout

\begin_layout Standard
Anche qua vogliono essere introdotti dei bridge che mettano in comunicazione
 reti FDDI ma anche tra reti FDDI e Ethernet.
\end_layout

\begin_layout Standard
Il problema è che in FDDI la velocità è di 100 Mbit/s e le trame minime
 sono di 40Byte.
 Come risultato quindi su FDDI un frame arriva ogni 
\begin_inset Formula $3.2\mu s$
\end_inset

.
\end_layout

\begin_layout Standard
Quindi la ricerca binaria non va più bene.
 Ovviamente se la velocità di accesso alle memorie fosse scalata di un ordine
 di grandezza avremmo potuto utilizzare lo stesso algoritmo.
 Questo però ovviamente non è successo.
\end_layout

\begin_layout Subsection*
DEC Gigaswitch
\end_layout

\begin_layout Standard
Nel 1994 la DEC introduce lo 
\begin_inset Quotes eld
\end_inset


\emph on
Gigaswitch
\emph default

\begin_inset Quotes erd
\end_inset

, che deve risolvere questi problemi.
\end_layout

\begin_layout Standard
La scelta qui fatta è l'utilizzo di una 
\series bold
tabella di hash
\series default
.
\end_layout

\begin_layout Itemize

\series bold
Nel caso medio
\series default
, se la tabella hash è stata dimensionata opportunamente per avere probabilità
 di collisioni molto basse, ci aspettiamo 
\series bold
tempi di accesso costanti
\series default
.
\end_layout

\begin_layout Itemize
Il problema è che le tabelle hash hanno una forte differenza tra i tempi
 di accesso nel caso medio e nel caso pessimo.
\end_layout

\begin_layout Itemize

\series bold
Nel caso pessimo i tempi di accesso
\series default
 sono 
\series bold
lineari
\series default
 (caso completo di collisioni degli hash).
\end_layout

\begin_layout Standard
A questo punto dobbiamo utilizzare un meccanismo per riuscire ad abbassare
 questi tempi di accesso:
\end_layout

\begin_layout Itemize
Una prima possibilità è l'utilizzo dell'
\series bold
hashing perfetto
\series default
.
 Esso consiste nella scelta di una funzione di hash in grado di garantire
 che le chiavi si distribuiscano su tutto l'array uniformemente.
 Il problema è che per calcolare la funzione di hash perfetta devo conoscere
 in anticipo le chiavi, cosa che non posso fare in questo contesto.
 
\end_layout

\begin_layout Itemize
La soluzione è stata utilizzare una 
\series bold
funzione di hash parametrica
\series default
, cioè non una funzione di hash ma 
\bar under
una famiglia di funzioni di hash
\bar default
 indiciazzate da un certo parametro.
 L'idea è che si sceglie a caso una funzione di hash della famiglia e si
 usa quella.
 Se il numero di collisioni diventa troppo grande possiamo 
\series bold
cambiare la funzione
\series default
 scegliendone una diversa all'interno della famiglia.
\end_layout

\begin_deeper
\begin_layout Itemize
Questo ovviamente ha un costo (di 
\series bold
re-hash
\series default
) per rimettere gli elementi con il nuovo hash nella tabella.
 Tuttavia si ritiene che la necessità di fare il re-hash sia un 
\series bold
evento
\series default
 abbastanza 
\series bold
raro
\series default
.
 Questo perché la necessità di re-hash si presenta quando il set di chiavi
 memorizzate nella tabella cambia nel tempo in modo abbastanza significativo
 rispetto al set iniziale quando è stata calcolata la funzione.
 Quindi ci aspettiamo che problemi prestazionali non siano frequenti.
\end_layout

\end_deeper
\begin_layout Standard
Noi sappiamo che un indirizzo MAC è formato da 48 bit.
 La funzione hash che viene utilizzata è una moltiplicazione polinomiale
 con coefficienti polinomiali con coefficienti binari 
\begin_inset Formula $A\left(x\right)$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
H\left(x\right)=A\left(x\right)\cdot M\left(x\right)\, mod\, G\left(x\right)
\]

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $G\left(x\right)$
\end_inset

 è un polinomio di grado 48 (
\series bold
\bar under
fissato
\series default
 da uno standard
\bar default
)
\end_layout

\begin_layout Itemize
\begin_inset Formula $M\left(x\right)$
\end_inset

 è un polinomio di grado massimo 
\begin_inset Formula $47$
\end_inset

 (il 
\series bold
parametro
\series default
 della funzione di hash)
\end_layout

\begin_layout Itemize
\begin_inset Formula $A\left(x\right)$
\end_inset

 è la rappresentazione del MAC address di 48 bit
\end_layout

\begin_layout Standard
Il trucco di questo caso è la scelta di un polinomio 
\begin_inset Formula $G\left(x\right)$
\end_inset

 standard, con proprietà algebriche particolari.
\end_layout

\begin_layout Itemize
Il 
\series bold
risultato
\series default
 
\begin_inset Formula $H\left(x\right)$
\end_inset

 è un altro polinomio di grado massimo 48, dove sono sicuro che se utilizzo
 due 
\begin_inset Formula $A\left(x\right)$
\end_inset

 diversi, non posso mai ottenere due 
\begin_inset Formula $H\left(x\right)$
\end_inset

 uguali (
\series bold
funzione biunivoca
\series default
).
\end_layout

\begin_layout Standard
A cosa serve prendere una stringa di 48 bit (l'indirizzo MAC) e trasformarla
 in un nuovo indirizzo di 48 bit?
\end_layout

\begin_layout Standard
Il fatto è che gli indirizzi MAC tra loro presentano delle correlazioni
 molto forti.
 Se compro 10 adattatori di rete sono quasi sicuro che la prima metà dei
 MAC address saranno uguali o molto simili e la seconda metà in ordine progressi
vo.
\end_layout

\begin_layout Standard
Il discorso è quindi che 
\begin_inset Formula $A\left(x\right)$
\end_inset

 non si può utilizzare come hash perchè presenta delle correlazioni molto
 forti.
\end_layout

\begin_layout Standard
Oltretutto abbiamo bisogno di una funzione parametrica per poter effettuare
 il re-hash se la funzione non è adatta.
\end_layout

\begin_layout Itemize
Inizialmente il parametro 
\begin_inset Formula $M\left(x\right)$
\end_inset

 viene scelto a caso
\end_layout

\begin_layout Itemize
Quindi i 16 bit meno significativi (di 
\begin_inset Formula $H\left(x\right)$
\end_inset

) vengono utilizzati in una 
\series bold
tabella hash che può contenere al massimo 64000 chiavi
\series default
.
 Il fatto di scegliere i meno significativi è una scelta arbitraria.
\end_layout

\begin_layout Itemize
Vogliamo garantire di gestire le collisioni in modo efficiente.
 I 32 bit che non ho utilizzato sono certamente diversi per tutte le chiavi
 che cadono nello stesso elemento della tabella hash.
 Questi 32 bit sono utilizzati per effettuare una ricerca in un albero binario
 che può contere al massimo 7 elementi (un albero di profondità 3).
 
\end_layout

\begin_deeper
\begin_layout Itemize
Sono sicuro che il numero di collisioni che si presentano in questo elemento
 siano al massimo uguale a 7? La risposta è 
\series bold
no
\series default
, per quello che ne sappiamo, tutti i MAC address possono ricadere all'interno
 della stessa entry della tabella hash e quest'albero può diventare molto
 grande.
 Per risolvere quindi ribilanciamo l'albero per avere profondità 3 e se
 gli elementi non ci stanno più nell'albero, li metto in una CAM (una memoria
 associativa) che contiene lo stesso tipo di informazioni da sfruttare come
 
\begin_inset Quotes eld
\end_inset

paracadute
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Perché non usiamo direttamente la CAM? 
\series bold
Costa ed è piccola
\series default
.
\end_layout

\end_deeper
\begin_layout Standard
Qual'è il costo totale di accesso a questo sistema?
\end_layout

\begin_layout Itemize

\series bold
Calcolo della funzione hash
\series default
: non è particolarmente difficile.
 Le operazioni che abbiamo visto prima si riescono a svoglere facilmente
 con registri a scorrimento.
\end_layout

\begin_layout Itemize

\series bold
Accesso alla memoria
\series default
 per entrare nella tabella hash.
\end_layout

\begin_layout Itemize
Abbiamo un accesso alla 
\series bold
ricerca nell'albero
\series default
 e 
\bar under
eventualmente
\bar default
 una
\series bold
 ricerca nella CAM
\series default
.
 
\end_layout

\begin_deeper
\begin_layout Itemize
Nota: la ricerca nella CAM viene effettuata in parallelo all'albero per
 migliorare le prestazioni.
\end_layout

\end_deeper
\begin_layout Standard
L'ultimo problema che resta è che la CAM si può riempire (dato che non è
 molto grande).
\end_layout

\begin_layout Standard
Quando la CAM è piena oltre un certo livello di guardia effetto l'operazione
 di 
\series bold
re-hash
\series default
.
 Il fatto che sia piena è indice del fatto che la funzione di hash è stata
 scelta male.
\end_layout

\begin_layout Standard
Svuoto quindi tutto il dispositivo, scelgo a caso un nuovo 
\begin_inset Formula $M\left(x\right)$
\end_inset

 e ripopolo la tabella.
\end_layout

\begin_layout Standard
La scelta a caso è quella ottimale in termini di ottimizzazione delle tempistich
e.
 Potremmo cercare una funzione di hash migliore riguardando quella appena
 scartata, però non c'è tempo.
\end_layout

\begin_layout Standard

\series bold
Dal punto di vista pratico si è visto che in realtà l'operazione di re-hash
 non viene quasi mai effettuata.
 
\series default
Questo prova la bontà della soluzione scelta.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename gigaswitch.png
	scale 20

\end_inset


\end_layout

\begin_layout Subsection*
Filtri
\end_layout

\begin_layout Standard
Altri casi in cui si utilizzano tabelle di lookup è con filtri a ricerca
 esatta (
\emph on
exact-match
\emph default
), ad esempio per la ricerca in un campo specifico di un pacchetto che è
 sempre nella stessa posizione.
\end_layout

\begin_layout Subsection*
Prefix-Match Lookup
\end_layout

\begin_layout Standard
Gli indirizzi Internet sono strutturati in maniera gerarchica, infatti una
 parte dell'indirizzo identifica la rete e una parte identifica l'host.
 Conosciamo anche la lunghezza del prefisso.
\end_layout

\begin_layout Standard
Con subnetting e supernetting in realtà si trovano spesso indirizzi che
 hanno un prefisso di rete che non rappresenta una rete ma un insieme di
 reti.
\end_layout

\begin_layout Standard
Qual'è il modello grossolano di un router di livello 3?
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename router.png
	scale 27

\end_inset


\end_layout

\begin_layout Itemize
Tanti link di ingresso da cui arrivano dei pacchetti caratterizzati da un
 indirizzo di destinazione.
\end_layout

\begin_deeper
\begin_layout Itemize
A livello 3 quello che conta primariamente è l'
\series bold
\bar under
indirizzo di destinazione
\end_layout

\end_deeper
\begin_layout Itemize
Il pacchetto entra dall'interfaccia di rete e l'
\series bold
intestazione di livello 3
\series default
 viene passata al processore
\end_layout

\begin_layout Itemize
Il processore deve trovare all'interno di una tabella il prefisso corrispondente
 al pacchetto appena entrato, trovare 
\series bold
qual'è il link di uscita
\series default
 corrispondente e dirlo alla parte di commutazione.
\end_layout

\begin_deeper
\begin_layout Itemize
La parte di commutazione può essere un bus dove arrivano i pacchetti oppure
 una 
\emph on
crossbar
\emph default
.
\end_layout

\begin_layout Itemize
Troviamo oppure una vera e propria rete di interconnessione, ovvero una
 rete multistadio in cui il pacchetto si sposta tra vari stadi.
\end_layout

\end_deeper
\begin_layout Standard
Riassumendo dobbiamo fare 3 cose:
\end_layout

\begin_layout Itemize
Capire 
\series bold
dove va mandato
\series default
 il pacchetto
\end_layout

\begin_layout Itemize

\series bold
Spostare
\series default
 il pacchetto sull'uscita giusta
\end_layout

\begin_layout Itemize

\series bold
Accodare
\series default
 i pacchetti sulle uscite (ci sono dei buffer da gestire quindi, che genera
 dei problemi)
\end_layout

\begin_deeper
\begin_layout Itemize
Si pone il serio problema di gestire i dati sulle uscite per 
\series bold
distinguere i tipi di dati
\series default
 (
\bar under
telefonate
\bar default
 trasmesse a pacchetti a 
\bar under
alta priorità
\bar default
 e traffico dati a 
\bar under
bassa priorità
\bar default
)
\end_layout

\end_deeper
\begin_layout Subsection*
Contesto del problema
\end_layout

\begin_layout Standard
Ora siamo passati dalle reti locali al mondo di Internet.
 
\end_layout

\begin_layout Standard
Le caratteristiche viste prima devono essere confrontate con le caratteristiche
 di limiti del traffico.
\end_layout

\begin_layout Itemize
Ci riferiamo a protocolli orientati alla connessione (vedi TCP).
 In un backbone possiamo aspettarci anche 
\series bold

\begin_inset Formula $250000$
\end_inset

 flussi diversi
\series default
.
 
\end_layout

\begin_deeper
\begin_layout Itemize
Quindi nei backbone possiamo scordarci meccanismi di caching!
\end_layout

\end_deeper
\begin_layout Itemize
Circa il 
\series bold
50% dei pacchetti sono riscontri TCP
\series default
 (come già detto in precedenza).
 
\end_layout

\begin_deeper
\begin_layout Itemize
Questo siginfica che l'ottimizzazione della velocità deve essere fatta pensando
 a pacchetti da 40 Byte.
\end_layout

\end_deeper
\begin_layout Itemize
Nel lookup degli indirizzi quello che domina è il 
\series bold
tempo di accesso alla memoria
\series default
.
\end_layout

\begin_deeper
\begin_layout Itemize
Le cache di solito non vanno bene perchè di solito sono troppo piccole,
 registri neanche.
\end_layout

\begin_layout Itemize
L'alternativa sono le CAM che però sono costose.
 Se possiamo usare DRAM è molto meglio.
\end_layout

\begin_layout Itemize
Quindi il costo in termini di tempo di elaborazione è interamente dominato
 dal tempo di accesso alla tabella di lookup.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
La lunghezza dei prefissi
\series default
 che si possono trovare in una tabella di routing è 
\series bold
difficilmente riconducibile a un valore fisso
\series default
.
 Troviamo tantissimi prefissi a lunghezze varie, solitamente i prefissi
 sono da 8 a 32 bit.
\end_layout

\begin_deeper
\begin_layout Itemize
Ricordiamoci il 
\emph on
longest prefix matching
\emph default
.
\end_layout

\begin_layout Itemize
Schemi non ottimizzati posso richiedere in media 24 accessi a memoria.
\end_layout

\begin_layout Itemize
Schemi ottimizzata per il 
\emph on
longest prefix matching
\emph default
 scendono ai 2 accessi a memoria.
\end_layout

\begin_layout Itemize
Varie tecniche che si basano sull'ipotesi che solo una delle righe vada
 bene non funzionano.
 Infatti escluso il discorso del 
\emph on
longest prefix matching
\emph default
, possono esserci più righe valide.
\end_layout

\end_deeper
\begin_layout Itemize
In un backbone si possono trovare anche fino a 
\begin_inset Formula $150000$
\end_inset

 prefissi.
 Inoltre possiamo trovare indirizzi multicast o di host singoli.
\end_layout

\begin_layout Itemize
Abbiamo 
\series bold
modifiche delle rotte molto frequenti
\series default
, quindi bisogna considerare che BGP non è stabile.
\end_layout

\begin_deeper
\begin_layout Itemize
Gli aggiornamenti avvengono anche nell'ordine dei millisecondi.
\end_layout

\end_deeper
\begin_layout Itemize
Nel multicast lo stesso pacchetto va a più destinazioni e bisogna gestire
 l'appartenenza di host e reti ad un gruppo multicast
\end_layout

\begin_layout Itemize
Se vogliamo raggiungere velocità più elevate dobbiamo passare all'utilizzo
 di 
\series bold
SRAM invece di DRAM
\series default
.
\end_layout

\begin_deeper
\begin_layout Itemize
Il problema è il costo superiore.
 Di solito la soluzione è combinare le due cose.
\end_layout

\end_deeper
\begin_layout Itemize
Fin tanto che IPv6 e il multicast non sono largamente adottati, ci possiamo
 concentrare sui lookup a 32 bit.
\end_layout

\begin_layout Subsubsection*
Ternary CAM
\end_layout

\begin_layout Standard
È una soluzione molto costosa.
\end_layout

\begin_layout Standard
Una CAM è una memoria dove presentiamo in ingresso una stringa di lunghezza
 fissata, se quella stringa è presenta in memoria viene restituito in uscita
 il valore associato a quella stringa.
\end_layout

\begin_layout Standard
Questo non va bene per il prefix lookup perché le chiavi nella lista non
 sono di lunghezza fissata.
\end_layout

\begin_layout Standard
Le ternary CAM permettono alle tringhe di avere 3 valori: 0,1 o 
\emph on
wildcard
\emph default
.
 La 
\emph on
wildcard
\emph default
 significa che quel valore è indifferente e possiamo avere un match indifferenta
mente dal valore.
\end_layout

\begin_layout Standard
In IP abbiamo una parte iniziale del prefisso specificata e la parte host-id
 possiamo vederla come una wildcard.
\end_layout

\begin_layout Standard
Nelle CAM cercata una chiave o c'è o non c'è.
 In questo caso però con le ternary CAM abbiamo il caso di più risultati
 per la stessa ricerca.
 Come garantiamo il rispetto della regola del 
\emph on
longest match
\emph default
?
\end_layout

\begin_layout Standard
Si impone di memorizzare i prefissi in ordine di lunghezza decrecescente.
 La regola stabilisce che il prefisso (che corrisponde alla chiave cercata)
 che va bene e viene restituito è quello che si trova più in alto nella
 tabella.
 In sostanza in caso di ambiguità vince sempre il prefisso che si trova
 più in alto (che è il più lungo).
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename tcam.png
	scale 25

\end_inset


\end_layout

\begin_layout Subsubsection*
Problemi
\end_layout

\begin_layout Itemize
Sono memorie molto veloci ma abbiamo bisogno fino a 10-12 transistor per
 bit.
 
\series bold
Larghezza implica consumo di potenza
\series default
.
\end_layout

\begin_layout Itemize
Per loro natura sono sempre accese, non possono essere spente.
 Si consuma molta energia.
\end_layout

\begin_deeper
\begin_layout Itemize
L'energia costa.
\end_layout

\begin_layout Itemize
L'energia che si consuma diventa calore e rimane in prossimità del dispositivo.
 Per cui bisogna anche attrezzarsi per dissipare il calore.
 Se il dispositivo è grosso ci vuole una parte di ventole.
 Se ci sono tanti di questi dispositivi serve un impianto di condizionamento.
\end_layout

\begin_layout Itemize
Facendo i conti delle spese per il raffreddamento si scopre che meno di
 metà del costo energetico diventa l'alimentazione delle memorie e dei processor
i, 
\series bold
più di metà è il costo per il raffreddamento
\series default
.
\end_layout

\end_deeper
\begin_layout Itemize
Quindi le CAM sono costose, se si possono evitare è meglio.
\end_layout

\begin_layout Subsubsection*
Aggiungere righe nelle TCAM
\end_layout

\begin_layout Standard
Abbiamo il problema di aggiungere una nuova riga nella TCAM.
 Il problema è che dobbiamo preservare l'ordine.
 Possiamo togliere il primo elemento in una zona, spostare tutti gli elementi
 
\begin_inset Quotes eld
\end_inset

in basso
\begin_inset Quotes erd
\end_inset

 e aggiungere quello nuovo.
 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Ricontrollare
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sapendo che la memoria CAM è suddivisa in classi, una per ogni lunghezza
 del prefisso, possiamo spostare il prefisso 
\emph on
i+1
\emph default
, creiamo un 
\begin_inset Quotes eld
\end_inset

buco
\begin_inset Quotes erd
\end_inset

 all'inizio della lunghezza dell'
\emph on
i-esimo
\emph default
 prefisso, scriviamo il nuovo prefisso.
\end_layout

\begin_layout Standard
Nel caso peggiore abbiamo spostato 32 elementi.
 Con altri trucchi si può scendere fino a 16.
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename tcam2.png
	scale 24

\end_inset


\end_layout

\begin_layout Standard
Riassumendo le CAM sono utili in:
\end_layout

\begin_layout Itemize
Soluzioni di backup come visto prima
\end_layout

\begin_layout Itemize
Dove le tabelle non sono molto grandi ma è importantissima la velocità.
\end_layout

\begin_layout Part*
Introduzione a Netkit
\end_layout

\begin_layout Standard
Distinguiamo tra 
\series bold
simulazione 
\series default
ed 
\series bold
emulazione
\series default
.
\end_layout

\begin_layout Itemize

\series bold
Sistemi di simulazione
\series default
: tentiamo di riprodurre e misurare le prestazioni di un sistema.
 Quando vogliamo effettuare il dimensionamento di un sistema.
 Per esempio vogliamo decidere quanda banda vogliamo assegnare a certe macchine.
\end_layout

\begin_layout Itemize

\series bold
Sistemi di emulazione
\series default
: tentiamo di riprodurre le 
\series bold
funzionalità
\series default
 di un sistema reale (configurazioni, architetture, protocolli)
\emph on
 
\emph default
con poco interesse alle performance
\end_layout

\begin_layout Standard
Netkit è una piattaforma per lanciare macchine virtuali.
\end_layout

\begin_layout Standard
La tecnica di programmazione utilizzata è la 
\emph on
user-mode-linux
\emph default
 (detta anche 
\series bold
uml
\series default
 
\emph on
http://user-mode-linux.sourceforge.net/
\emph default
), cioè il kernel Linux viene lanciato in userspace.
\end_layout

\begin_layout Standard
Sfruttiamo Linux poiché esso contiene già tutto l'indispensabile per operare
 in una rete sia come client, che anche come bridge o switch.
\end_layout

\begin_layout Standard
Un processo Linux in user-mode può essere anche chiamato 
\series bold
virtual machine
\series default
, mentre il sistema ospitante è solitamente chiamato 
\series bold
host machine
\series default
.
\end_layout

\begin_layout Standard
Ogni macchina virtuale è dodata di:
\end_layout

\begin_layout Itemize
Una 
\series bold
console
\end_layout

\begin_layout Itemize
Una 
\series bold
memoria
\series default
 (scelta con un valore inferiore a quella libera della macchina ospitante)
\end_layout

\begin_layout Itemize
Un 
\series bold
filesystem
\series default
 (viene utilizzato un singolo file nella macchina host)
\end_layout

\begin_layout Itemize
Una o più 
\series bold
interfacce di rete
\end_layout

\begin_deeper
\begin_layout Itemize
Ogni interfaccia di rete può essere collegata ad un dominio di collisione
 virtuale.
\end_layout

\begin_layout Itemize
Ogni dominio di collisione può essere collegato a più interfacce di diverse
 macchine.
\end_layout

\end_deeper
\begin_layout Standard
Le macchine si possono collegare tra di loro a diversi domini di collisione
\end_layout

\begin_layout Standard
L'idea quindi è che noi abbiamo queste macchine virtuali linux che possono
 essere configurate per essere host, router o eventualmente anche switch
 per emulare la nostra rete.
\end_layout

\begin_layout Standard
In definitiva netkit è un insieme di 
\series bold
strumenti
\series default
 per creare in modo semplice una 
\series bold
rete virtuale di macchine virtuali
\series default
.
 Queste macchine virtuali sono già equipaggiate con un filesystem che contiene
 una serie di protocolli utilizzati comunemente per il networking e possono
 essere quindi utilizzati per effettuare emulazione di rete.
\end_layout

\begin_layout Standard
Netkit si scarica da http://www.netkit.org/
\end_layout

\begin_layout Subsubsection*
Nota sull'installazione
\end_layout

\begin_layout Standard
I dischi delle macchine virtuali sono dischi da 10 GB principalmente vuoti.
 Vengono consegnati compressi in un archivio relativamente piccolo.
 Quando si estrae l'archivo bisogna ricordarsi di estrarre i file come files
 di tipo sparso, di modo da non occupare tutti i 10 GB 
\begin_inset Quotes eld
\end_inset

virtuali
\begin_inset Quotes erd
\end_inset

 sul disco fisico.
 Per farlo bisogna utilizzare l'opzione 
\series bold
S
\series default
 sul comando tar
\end_layout

\begin_layout Subsection*
Set di comandi
\end_layout

\begin_layout Standard
Ci sono due famiglie di comandi, quelli che iniziano per 
\series bold
v 
\series default
e quelli che iniziano per 
\series bold
l
\series default
.
\end_layout

\begin_layout Itemize

\series bold
vcommands
\series default
: Tools a basso livello per configurare e avviare macchine virtuali
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
vstart
\series default
: avvia una nuova macchina virtuale
\end_layout

\begin_layout Itemize

\series bold
vlist
\series default
: mostra le macchine virtuali attualmente accese
\end_layout

\begin_layout Itemize

\series bold
vconfig
\series default
: collega una interfaccia di rete ad una macchina virtuale accesa
\end_layout

\begin_layout Itemize

\series bold
vhalt
\series default
: ferma una macchina virtuale in modo pulito
\end_layout

\begin_layout Itemize

\series bold
vcrash
\series default
: causa un crash per interrompere la macchina virtuale in modo forzato
\end_layout

\begin_layout Itemize

\series bold
vclean
\series default
: comando per interrompere tutti i processi di netkit e ripulire tutti i
 parametri di configurazione nella macchina host
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
lcommands
\series default
: Tools per gestire 
\begin_inset Quotes eld
\end_inset

laboratori
\begin_inset Quotes erd
\end_inset

 (gruppi) di macchine virtuali
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
lstart
\series default
: avvia un laboratorio netkit
\end_layout

\begin_layout Itemize

\series bold
lhalt
\series default
: ferma tutte le macchine di un laboratorio
\end_layout

\begin_layout Itemize

\series bold
lcrash
\series default
: ferma in modo forzato tutte le macchine del laboratorio.
\end_layout

\begin_layout Itemize

\series bold
lclean
\series default
: remuove i file temporanei dalla cartella di un laboratorio
\end_layout

\begin_layout Itemize

\series bold
linfo
\series default
: restituisce informazioni riguardo ad un laboratorio senza avviarlo
\end_layout

\begin_layout Itemize

\series bold
ltest
\series default
: permette di eseguire dei test per controllare che il laboratorio stia
 funzionando correttamente.
\end_layout

\end_deeper
\begin_layout Subsection*
Accesso a documenti esterni
\end_layout

\begin_layout Standard
È molto utile scambiare files tra le macchine virtuali e la macchina esterna.
 Per questo nelle macchine virtuali c'è una cartella 
\emph on
/hosthome
\emph default
 che ci permette di accedere alla home della macchina principale.
 Accesso in lettura e scrittura è permesso.
\end_layout

\begin_layout Standard
In alternativa 
\emph on
vstart
\emph default
 ci permette di configurare automaticamente dei tunnels (interfacce tap)
 che permettono ad una macchina virtuale di accedere alla rete esterna.
\end_layout

\begin_layout Subsection*
Preparazione di un laboratorio netkit con i comandi vstart
\end_layout

\begin_layout Standard
Supponiamo che qualcuno ci dia un 
\begin_inset Quotes eld
\end_inset

laboratorio
\begin_inset Quotes erd
\end_inset

 (cioè un insieme preconfezionato di macchine configurate in un certo modo).
\end_layout

\begin_layout Standard
Possiamo:
\end_layout

\begin_layout Itemize
Scrivere un singolo script bash che avvia una per una tutte le macchine
 virtuali utilizzando il comando 
\emph on
vstart
\end_layout

\begin_layout Itemize
Avviare un laboratorio standard netkit che può essere lanciato con i comandi
 di tipo 
\series bold
\emph on
l
\series default
\emph default
 (raccomandato).
\end_layout

\begin_layout Standard
Quando avviamo una macchina virtuale con vstart possiamo passare alcune
 opzioni per configurare ogni macchina virtuale.
 Ad esempio possiamo passare l'opzione 
\emph on
--exec
\emph default
 per eseguire un certo script all'interno della macchina virtuale.
\end_layout

\begin_layout Subsubsection*
Esempio di setup:
\end_layout

\begin_layout LyX-Code
vstart pc1 --eth0=0 --eth1=1 --exec=this_script
\end_layout

\begin_layout LyX-Code
vstart pc2 --eth0=0 --exec=this_script
\end_layout

\begin_layout LyX-Code
vstart pc3 --eth0=0 --exec=this_script
\end_layout

\begin_layout LyX-Code
if [ `id -u` == 
\begin_inset Quotes eld
\end_inset

0
\begin_inset Quotes erd
\end_inset

 ]; then
\end_layout

\begin_deeper
\begin_layout LyX-Code
case 
\begin_inset Quotes eld
\end_inset

$HOSTNAME
\begin_inset Quotes erd
\end_inset

 in
\end_layout

\begin_deeper
\begin_layout LyX-Code
pc1)
\end_layout

\begin_deeper
\begin_layout LyX-Code
ifconfig eth0 10.0.0.1 up
\end_layout

\begin_layout LyX-Code
ifconfig eth1 10.0.0.2 up;;
\end_layout

\end_deeper
\begin_layout LyX-Code
pc2)
\end_layout

\begin_deeper
\begin_layout LyX-Code
ifconfig eth0 10.0.0.3 up;;
\end_layout

\end_deeper
\begin_layout LyX-Code
pc3)
\end_layout

\begin_deeper
\begin_layout LyX-Code
ifconfig eth0 10.0.0.4 up;;
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code
esac
\end_layout

\end_deeper
\begin_layout LyX-Code
fi
\end_layout

\begin_layout Standard
Nota: il valore assegnato a 
\emph on
eth0
\emph default
 è il numero relativo al dominio di collisione a cui associare quelle macchine.
 Possiamo immaginarlo come il numero dell'hub di rete a cui sono collegate.
\end_layout

\begin_layout Subsection*
Preparazione di un laboratorio netkit con i comandi l
\end_layout

\begin_layout Standard
Un laboratorio netkit contiene:
\end_layout

\begin_layout Itemize
Un file 
\series bold
\emph on
lab.conf
\series default
\emph default
 che descrive la tipologia della rete
\end_layout

\begin_deeper
\begin_layout Itemize
Contiene una serie di assegnamenti del tipo: 
\emph on
machine[arg]=value
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
machine
\emph default
 è il nome della vm (ad esempio pc1)
\end_layout

\begin_layout Itemize
Se 
\emph on
arg
\emph default
 è una stringa può essere una opzione del comando vstart, accompagnata dal
 relativo valore.
\end_layout

\begin_layout Itemize
Se 
\emph on
arg
\emph default
 è un numero interno, il valore è il nome del dominio di collisione a cui
 l'interfaccia numero 
\emph on
arg
\emph default
 è collegata.
\end_layout

\end_deeper
\begin_layout Itemize
Esempio:
\end_layout

\begin_deeper
\begin_layout LyX-Code
pc1[0]=A
\end_layout

\begin_layout LyX-Code
pc2[0]=A
\end_layout

\begin_layout LyX-Code
pc2[1]=B
\end_layout

\begin_layout LyX-Code
pc2[mem]=256
\end_layout

\begin_layout LyX-Code
pc3[0]=B
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Un insieme di 
\series bold
sottocartelle
\series default
 che contengono le impostazioni di configurazione per ogni macchina virtuale.
\end_layout

\begin_deeper
\begin_layout Itemize
Netkit avvia una macchina virtuale per ogni sottocartella, con lo stesso
 nome della sottocartella stessa (a meno che lab.conf contenga la definizione
 
\emph on

\begin_inset Quotes eld
\end_inset

machines=
\emph default

\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
I contenuti della sottocartella chiamata 
\series bold
\emph on
vm
\series default
\emph default
 vengono copiati nel filesystem della macchina virtuale.
 Ad esempio 
\emph on
vm/foo/file
\emph default
 viene copiato in 
\emph on
/foo/file
\emph default
.
\end_layout

\begin_layout Itemize
Per pemettere questo tipo di mapping è necessario cancellare il filesystem
 .disk
\end_layout

\end_deeper
\begin_layout Itemize
Un file 
\series bold
\emph on
.startup
\series default
\emph default
 e un file 
\series bold
\emph on
.shutdown
\series default
 
\emph default
che descrivono le azioni che devono svolgere le macchine virtuali.
\end_layout

\begin_deeper
\begin_layout Itemize
Sono script di shell che dicono alla macchina virtuale cosa fare
\end_layout

\begin_layout Itemize
I file 
\emph on
shared.startup 
\emph default
e 
\emph on
shared.shutdown
\emph default
 influiscono su tutte le macchine virtuali
\end_layout

\begin_layout Itemize
Dopo lo startup ogni macchina virtuale avvia 
\emph on
shared.startup
\emph default
 e 
\emph on
vm_name.startup
\emph default
, idem in ordine scambiato per lo shutdown.
\end_layout

\begin_layout Itemize
L'utilizzo classico di un file di startup è la configurazione di interfacce
 di rete o l'avvio di servizi di rete.
\end_layout

\begin_deeper
\begin_layout Itemize
Esempio:
\end_layout

\begin_layout LyX-Code
ifconfig eth0 10.0.0.1 up
\end_layout

\begin_layout LyX-Code
/etc/init.d/zebra start
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
(Opzionale) un file 
\series bold
\emph on
lab.dep
\series default
\emph default
 che descrive le dipendenze nell'ordine di startup delle macchine virtuali.
\end_layout

\begin_deeper
\begin_layout Itemize
Per stabilire le dipendenze tipo 
\begin_inset Quotes eld
\end_inset

pc3 può essere avviato solo dopo pc1 e pc2
\begin_inset Quotes erd
\end_inset

 possiamo scrivere in un formato simile ad un makefile:
\end_layout

\begin_deeper
\begin_layout LyX-Code
pc3: pc1 pc2
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
(Opzionale) una cartella 
\series bold
\emph on
__test
\series default
 
\emph default
che contiene gli script per controllare che il laboratorio funzioni correttament
e.
\end_layout

\begin_layout Subsection*
Avvio e arresto di un laboratorio
\end_layout

\begin_layout LyX-Code
lcommand -d <cartella_lab> [macchina]
\end_layout

\begin_layout Standard
Oppure:
\end_layout

\begin_layout Itemize
Si entra nella cartella del laboratorio
\end_layout

\begin_layout Itemize
Si lancia 
\emph on
lcommand
\end_layout

\begin_layout Itemize

\emph on
lcommand
\emph default
 può essere:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
lstart
\end_layout

\begin_layout Itemize

\series bold
lhalt
\end_layout

\begin_layout Itemize

\series bold
lcrash
\end_layout

\end_deeper
\begin_layout Subsection*
Raccolta di informazioni su un laboratorio
\end_layout

\begin_layout Standard
Il comando 
\emph on
linfo
\emph default
 fornisce informazioni riguardo un laboratorio avviato.
 L'opzione 
\emph on
-m
\emph default
 permette di creare una bozza del grafico dei collegamenti (richiede l'installaz
ione di 
\series bold
GraphViz
\series default
).
\end_layout

\begin_layout Section*
Soluzioni algoritmiche per la ricerca (→ da rivedere ←)
\end_layout

\begin_layout Standard
Abbiamo due grandi famiglie da analizzare:
\end_layout

\begin_layout Itemize

\series bold
\emph on
Tries
\begin_inset Foot
status open

\begin_layout Plain Layout
Il termine
\emph on
 
\begin_inset Quotes eld
\end_inset

trie
\begin_inset Quotes erd
\end_inset

 deriva da 
\begin_inset Quotes eld
\end_inset

recupero
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\series default
\emph default
 (o 
\emph on
prefix tree
\emph default
, sono degli alberi utilizzati per memorizzare un array associativo)
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Unibit Tries
\end_layout

\begin_layout Itemize

\emph on
Multibit Tries
\end_layout

\begin_layout Itemize

\emph on
Level-Compressed Tries
\end_layout

\begin_layout Itemize

\emph on
Tree Bitmaps
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Ricerca binaria
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Su range
\end_layout

\begin_layout Itemize

\emph on
Su lunghezze dei prefissi
\end_layout

\end_deeper
\begin_layout Standard
Per valutare le performance faremo riferimento alla:
\end_layout

\begin_layout Itemize
Compressità spaziale
\end_layout

\begin_layout Itemize
Compressità temporale (nella ricerca e nell'aggiornamento)
\end_layout

\begin_layout Subsection*
Unibit Tries
\end_layout

\begin_layout Standard
È un albero in cui ogni nodo:
\end_layout

\begin_layout Itemize
Memorizza dati associati (il next hop)
\end_layout

\begin_layout Itemize
Un array con un puntatore 0 e 1
\end_layout

\begin_layout Standard
Il puntatore sia:
\end_layout

\begin_layout Itemize
Che punta ai dati associati (il next hop)
\end_layout

\begin_layout Itemize
Punta ad un sotto-albero
\end_layout

\begin_layout Standard
Nella radice tutti i prefissi:
\end_layout

\begin_layout Itemize
Che iniziano con 0 sono nel sottoalbero puntato dal puntatore 0
\end_layout

\begin_layout Itemize
Che iniziano con 1 sono nel sottoalbero puntato dal puntatore 1
\end_layout

\begin_layout Standard
Ogni sotto-albero è costruito in modo ricorsivo
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename unibit.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Ci sono due casi speciali:
\end_layout

\begin_layout Itemize
Un prefisso può essere suffisso di un altro prefisso:
\end_layout

\begin_deeper
\begin_layout Itemize
Nell'esempio in figura 
\begin_inset Formula $P4=1*$
\end_inset

 e 
\begin_inset Formula $P2=111*$
\end_inset


\end_layout

\begin_layout Itemize
Il prefisso corto è memorizzato all'interno di un nodo lungo il percorso
\end_layout

\end_deeper
\begin_layout Itemize
Alcuni sottoalberi hanno dei rami a 
\begin_inset Quotes eld
\end_inset

senso unico
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Nell'esempio 
\begin_inset Formula $P3=11001*$
\end_inset

 , non ci sono rami per gli ultimi due bit
\end_layout

\begin_layout Itemize
Viene sprecato spazio e tempo
\end_layout

\end_deeper
\begin_layout Standard
Come effettuiamo la ricerca per il match più lungo per un indirizzo D? Iniziamo
 dalla radice e continuiamo fino a quando non troviamo:
\end_layout

\begin_layout Itemize
Un puntatore vuoto
\end_layout

\begin_layout Itemize
Una stringa che non corrisponde
\end_layout

\begin_layout Standard
L'algoritmo tiene traccia dell'ultimo prefisso lungo il percorso.
 Quando la ricerca fallisce, quello è match più lungo (
\series bold
\emph on
longest match
\series default
\emph default
)
\end_layout

\begin_layout Subsection*
Multibit Tries
\end_layout

\begin_layout Standard
Gli unibit tries hanno uno svantaggio: nel caso peggiore ci sono 32 accessi
 alla memoria (sono lenti!)
\end_layout

\begin_layout Standard
I multibit ties:
\end_layout

\begin_layout Itemize
Riducono gli accessi in memoria cercando in passi di 
\begin_inset Formula $n$
\end_inset

 bit (con 
\begin_inset Formula $n>1$
\end_inset

)
\end_layout

\begin_layout Itemize
\begin_inset Formula $n$
\end_inset

 può essere fissato per tutti gli alberi o può cambiare ad ogni nodo.
\end_layout

\begin_layout Itemize
Se il prefisso non è un multiplo dei passi del prefisso, deve essere espanso.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename multibit.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Fixed-Stride Multibit Tries
\end_layout

\begin_layout Standard
In ogni nodo, parte dell'indirizzo è un indice in un array.
\end_layout

\begin_layout Standard
Ogni elemento contiene:
\end_layout

\begin_layout Itemize
Un prefisso (P1,P2,...)
\end_layout

\begin_layout Itemize
Un puntatore
\end_layout

\begin_layout Standard
Quando un elemento è vuoto, viene restituito l'ultimo prefisso incontrato.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename multibit2.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Con un passo fissato c'è uno spreco di spazio (nell'espandere scambiamo
 memoria per tempo).
\end_layout

\begin_layout Standard
Passi variabili riducono la memorizzazione data al massimo peso dell'albero.
\end_layout

\begin_layout Standard
Abbiamo alcuni problemi:
\end_layout

\begin_layout Itemize
Trovare il numero ottimo di passi: 
\begin_inset Formula $O\left(N\cdot W^{2}\cdot h\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $N=\text{numero prefissi}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $W=\text{lunghezza dell'indirizzo destinazione}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $h=\text{massima altezza}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Aggiornamento incrementale 
\begin_inset Formula $O\left(W\right)+O\left(S\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Dove 
\begin_inset Formula $S=\text{dimensione massima di un nodo}$
\end_inset


\end_layout

\end_deeper
\begin_layout Subsection*
Lulea-Compressed Tries
\end_layout

\begin_layout Standard
Si tratta di un multi-bit trie dove le informazioni ripetute nei nodi sono
 compresse (per minimizzare il consumo di memoria)
\end_layout

\begin_layout Itemize
Ogni nodo può contenere un prefisso o un puntatore.
 I prefissi puntano verso le foglie.
\end_layout

\begin_layout Itemize
La bitmap del nodo contiene 1 se l'elemento è nuovo, 0 se è ripetuto.
 Gli elementi ripetuti sono cancellati dal nodo.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename lulea.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
Nei tries ogni chunk (sottogruppo dei bit dell'indirizzo) è utilizzato come
 un indice nel nodo per trovare un prefisso o un puntatore.
 Nei lulea questo 
\series bold
\bar under
non è vero
\series default
\bar default
.
\end_layout

\begin_layout Itemize
Nei lulea il numero di 1 nella bitmap fino alla posizione indicata dal chunk,
 è indice del nodo.
\end_layout

\begin_layout Itemize
Per velocizzare il conteggio è possibile precalcolare le somme cumulative
 passo-passo.
 L'inserimento però può diventare lento.
\end_layout

\begin_layout Subsection*
Tree Bitmap
\end_layout

\begin_layout Standard
Si utilizzano per ottenere spazio e velocità in modo simile ai lulea, ma
 con inserimenti più veloci.
\end_layout

\begin_layout Standard
Nei lulea abbiamo in ogni nodo un puntatore o un prefisso.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename bitmap.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Nei tree bitmaps abbiamo tre idee:
\end_layout

\begin_layout Itemize
In un tree bitmap abbiamo due bitmap per nodo: una per i prefissi e una
 per i puntatori (l'ultimo è un albero in una forma linearizzata)
\end_layout

\begin_layout Itemize
Teniamo la dimensione dei nodi piccola
\end_layout

\begin_deeper
\begin_layout Itemize
Il prossimo hop e altri dati associati sono memorizzati in un altro array
 e associati solo quando la ricerca termina
\end_layout

\end_deeper
\begin_layout Itemize
Un unico accesso in memoria per ogni nodo
\end_layout

\begin_deeper
\begin_layout Itemize
Utilizziamo piccoli passi (ad esempio 4 bit)
\end_layout

\begin_layout Itemize
I nodi sono di dimensione fissata
\end_layout

\begin_layout Itemize
Prendiamo l'intero nodo con una unica lettura
\end_layout

\begin_layout Itemize
Contiamo i bit con logica combinatoria
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Graphics
	filename bitmap2.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Ricerca binaria su intervalli
\end_layout

\begin_layout Itemize
Si tratta di un paradigma completamente diverso, non basato su tries o alberi,
 ma su una generalizzazione dell'
\emph on
exact match
\emph default
.
\end_layout

\begin_layout Itemize
La ricerca binaria su intervalli rappresenta ogni prefisso come un intervallo.
 
\begin_inset Formula $N$
\end_inset

 prefissi suddividono lo spazio di indirizzi in 
\begin_inset Formula $2N+1$
\end_inset

 intervalli disgiunti.
\end_layout

\begin_layout Itemize
Utilizziamo la ricerca binaria per cercare l'intervallo in cui giace un
 indirizzo destinazione.
\end_layout

\begin_layout Itemize
La complessità è 
\begin_inset Formula $O\left(log\left(2N\right)\right)$
\end_inset

 e può essere ridotta con 
\emph on
B-trees
\emph default
 o altri trucchi.
\end_layout

\begin_layout Itemize
L'inserimento o cancellazione è 
\begin_inset Formula $O\left(N\right)$
\end_inset

 ma può essere ridotto fino a 
\begin_inset Formula $O\left(log\left(N\right)\right)$
\end_inset


\end_layout

\begin_layout Itemize
Il vantaggio è che non è coperto da brevetto.
 Lo svantaggio è che ha performance peggiori rispetto ai 
\emph on
tries
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename binarysearch.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Ricerca binaria su lungezza dei prefissi
\end_layout

\begin_layout Itemize
Si tratta di una variazione rispetto all'
\emph on
exact match
\emph default
 che sfrutta l'hashing.
\end_layout

\begin_layout Itemize
Si effettuano 
\begin_inset Formula $log_{2}\left(W\right)$
\end_inset

 hash, dove 
\begin_inset Formula $W$
\end_inset

 è la dimensione massima di prefisso.
 (Ha buone performance con IPv6, meglio di altre soluzioni basate su 
\emph on
tries
\emph default
)
\end_layout

\begin_layout Itemize
Utilizza un array 
\begin_inset Formula $L\left[i\right]$
\end_inset

 di tabelle di hash.
 Ogni tabella contiene i prefissi di lunghezza 
\begin_inset Formula $i$
\end_inset

 .
\end_layout

\begin_layout Itemize
Soluzione semplice: cerchiamo in 
\begin_inset Formula $L\left[W\right]$
\end_inset

 e scendiamo fino a 
\begin_inset Formula $L\left[1\right]$
\end_inset

.
 Ci fermiamo se non c'è nessuna corrispondenza.
 La complessità è 
\begin_inset Formula $O\left(W\cdot\text{costo di un lookup in un hash}\right)$
\end_inset


\end_layout

\begin_layout Itemize
La complessità può diventare 
\begin_inset Formula $O\left(log\left(W\right)\right)$
\end_inset

 con una ricerca binaria sulle lunghezze dei prefissi
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename binarysearch2.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
L'algoritmo è:
\end_layout

\begin_deeper
\begin_layout Itemize
Inizio la ricerca con la lunghezza media del prefisso e cerco nella tabella.
\end_layout

\begin_layout Itemize
Se trovo una corrispondenza, cerco per un prefisso più lungo.
\end_layout

\begin_layout Itemize
Se non trovo nessuna corrispondenza, cerco per un prefisso più corto.
\end_layout

\end_deeper
\begin_layout Itemize
C'è un problema: un prefisso di lunghezza 
\begin_inset Formula $x$
\end_inset

 può non esserci, ma un prefisso più lungo sì.
\end_layout

\begin_deeper
\begin_layout Itemize
Un marcatore per un prefisso 
\begin_inset Formula $P$
\end_inset

 deve essere posizionato a tutte le lunghezza in cui cercheremo P
\end_layout

\begin_layout Itemize
Non basta ancora, un marcatore potrebbe condurre a falsi risultati.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Graphics
	filename binarysearch3.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
Memorizza insieme al marcatore:
\end_layout

\begin_deeper
\begin_layout Itemize
Il prefisso massimo per quel mercatore
\end_layout

\begin_layout Itemize
Il risultato per quel marcatore pre-calcolato cercando sul lato sinistro
\end_layout

\end_deeper
\begin_layout Itemize
Se una ricerca raggiunge la massima lunghezza senza risultati, il risultato
 è memorizzato nell'ultimo marcatore trovato.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename binarysearch4.png
	scale 40

\end_inset


\end_layout

\begin_layout Section*
Classificazione dei pacchetti
\end_layout

\begin_layout Standard
I router moderni generalmente utilizzano una serie di informazioni presenti
 nei pacchetti per prendere una serie di decisioni, che non sono solo quelle
 di instradamento.
 
\end_layout

\begin_layout Itemize
Nei 
\series bold
firewall
\series default
 viene deciso se un pacchetto può proseguire nel proprio percorso.
\end_layout

\begin_layout Itemize
Abbiamo tecniche di 
\series bold
prenotazione
\series default
 dove è possibile effettuare 
\series bold
allocazione di risorse
\series default
 per specifici pacchetti.
\end_layout

\begin_deeper
\begin_layout Itemize
Esempi tipici sono la separazione del traffico dati (file transfer) dal
 traffico vocale over IP.
\end_layout

\end_deeper
\begin_layout Itemize
Abbiamo poi la possibilità di fare 
\series bold
routing basato sulla qualità del servizio
\series default
: tecniche relative alla differenziazione della qualità in base ai vari
 tipi di traffico applicativo.
\end_layout

\begin_layout Standard
Non ci occuperemo particolarmente dell'ispezione dei livello 7 (ce ne occuperemo
 quando parleremo di IDS - 
\emph on
Intrusion Detection Systems
\emph default
)
\end_layout

\begin_layout Subsection*
Il problema della classificazione
\end_layout

\begin_layout Standard
I pacchetti sono classificati in base ad un 
\series bold
insieme di regole
\series default
 che solitamente sono ordinate per priorità, implicita nella posizione della
 regola.
 In altri casi viene associato un costo ad ogni regola.
 In generale bisogna sempre poter capire data una coppia di regole qual'è
 quella di costo minimo.
\end_layout

\begin_layout Standard
Il problema è quindi trovare qual'è
\bar under
 la regola di costo minimo
\bar default
 che soddisfa il pacchetto che stiamo analizzando.
\end_layout

\begin_layout Standard
Ogni regola guarda 
\begin_inset Formula $K$
\end_inset

 diversi campi nell'header all'interno di ogni messaggio.
 Ogni campo 
\begin_inset Formula $H\left[i\right]$
\end_inset

 è una stringa di bit di lunghezza fissata
\end_layout

\begin_layout Standard
In alcuni casi la posizione dei campi può dipendere dal valore di altri
 campi, ma in generale noi assumeremo che la parte di 
\begin_inset Quotes eld
\end_inset

lettura
\begin_inset Quotes erd
\end_inset

 del pacchetto sia già stata fatta e siano stati 
\begin_inset Quotes eld
\end_inset

sistemati
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Gli esempi tipici di regole sono quelle in base agli indirizzi sorgente/destinaz
ione, al tipo di protocollo, ai flag TCP,...
\end_layout

\begin_layout Subsection*
Tipi di match
\end_layout

\begin_layout Standard
Ci sono tre principali tipi di match:
\end_layout

\begin_layout Itemize

\series bold
Exact match
\series default
: Quando cerchiamo un campo header del pacchetto che corrisponda esattamente
 al valore scelto nella regola.
\end_layout

\begin_layout Itemize

\series bold
Prefix match
\series default
: Quando la regola specifica un prefisso da cercare in un campo dell'header.
 Questo è utile ad esempio per fare match su certe sottoreti.
\end_layout

\begin_layout Itemize

\series bold
Range match
\series default
: Quando il campo ha un valore compreso tra due estremi.
\end_layout

\begin_layout Subsection*
Il classificatore
\end_layout

\begin_layout Standard
Il classificatore o database delle regole, consiste in un 
\series bold
insieme di regole
\series default
 
\begin_inset Formula $R_{1},\, R_{2},...,R_{n}$
\end_inset

 ciascuna con una certa 
\series bold
priorità
\series default
.
 Lo scopo del classificatore è quello di estrarre le regole che corrispondono
 e scegliere quelle di costo minimo.
 
\end_layout

\begin_layout Standard
Ciascuna regola:
\end_layout

\begin_layout Itemize
Specifica un tipo di match su un certo valore o una combinazione di campi.
\end_layout

\begin_layout Itemize
È associata ad un costo (solitamente la posizione nella lista).
\end_layout

\begin_layout Itemize
È associata ad una direttiva, che specifica cosa fare con il pacchetto quando
 è ricevuto.
 
\bar under
Esempi 
\bar default
di direttive:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
drop
\series default
: scartare il pacchetto
\end_layout

\begin_layout Itemize
forward in base alla destinazione
\end_layout

\begin_layout Itemize
forward ad un certo hop successivo
\end_layout

\begin_layout Itemize
Aggiungere un marcatore.
\end_layout

\end_deeper
\begin_layout Standard
Il nostro problema è quindi con 
\begin_inset Formula $N$
\end_inset

 regole su 
\begin_inset Formula $K$
\end_inset

 dimensioni (o campi).
\end_layout

\begin_layout Standard
Ricordiamoci che in generale una regola su una o più campi può contenere
 una wildcard, per essere svincolata da quel valore.
\end_layout

\begin_layout Section*
Firewall
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename hack.png
	scale 35

\end_inset


\end_layout

\begin_layout Standard
Vediamo un esempio di firewall creato popolando un insieme di regole nel
 classificatore.
\end_layout

\begin_layout Standard
Le nostre regole hanno 
\begin_inset Formula $K=5$
\end_inset

 dimensioni o campi da analizzare.
\end_layout

\begin_layout Section*
Requisiti dei classificatori
\end_layout

\begin_layout Itemize
Il lookup deve essere effettuato a 
\emph on
wire-speed
\emph default
 almeno con i pacchetti di dimensione minima.
\end_layout

\begin_layout Itemize
Struttura dati di piccole dimensioni per memorizzare le regole.
\end_layout

\begin_layout Itemize
L'inserimento e la cancellazione di regole non è molto frequente, quindi
 le prestzioni di queste due operazioni sono meno importanti di quelle relative
 alla ricerca.
\end_layout

\begin_layout Itemize
Bisogna fare attenzione alla classificazione con stato (
\series bold
stateful classification
\series default
):
\end_layout

\begin_deeper
\begin_layout Itemize
Le regole vengono aggiunte/cancellate dinamicamente a seconda di certi eventi.
\end_layout

\begin_layout Itemize
In questo caso la velocità di inserimento e cancellazione è un problema.
\end_layout

\begin_layout Itemize
Esempi:
\end_layout

\begin_deeper
\begin_layout Itemize
Arriva una richiesta UDP che avvia l'inserimento di una regola per permettere
 la corrispettiva risposta.
\end_layout

\begin_layout Itemize
Una quantità esagerata di regole tenta di collegarsi ad un host, il quale
 attiva una regola per bloccare il traffico da quell'host.
\end_layout

\end_deeper
\end_deeper
\begin_layout Section*
Soluzioni semplici
\end_layout

\begin_layout Itemize

\series bold
Ricerca lineare
\series default
: scorro le regole e mi fermo quando trovo un match.
 Il problema è che la ricerca lineare è lenta particolarmente per i grossi
 ruleset, quindi diventa difficile soddisfare il limite di 
\emph on
wire-speed
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Caching
\series default
: Qualcuno pèotrebbe pensare di migliorare le prestazioni sfruttando il
 caching e spostando in una cache le regole con più hit, sfruttando il principio
 che altri pacchetti avranno il match sulle stesse regole.
 Esperimenti dimostrano però che statisticamente un pacchetto su 5 (cioè
 in un numero molto alto di casi) c'è un miss.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Utilizzo di etichette
\series default
/
\series bold
marcatori
\series default
: qualcun'altro effettua la classificazione per me, aggiunge al pacchetto
 una 
\begin_inset Quotes eld
\end_inset

etichetta
\begin_inset Quotes erd
\end_inset

 per farmi capire quale regola devo utilizzare.
 Può sembrare una cavolata ma è una cosa che si fa molto spesso, soprattutto
 con insiemi di regole (
\emph on
ruleset
\emph default
) molto grandi.
 
\end_layout

\begin_deeper
\begin_layout Itemize
Al giorno d'oggi spesso si fa la classificazione dei pacchetti 
\series bold
nella parte di accesso alla rete
\series default
 (che ha meno connessioni TCP distinte rispetto al centro della rete), dove
 possiamo sfruttare maggiormente la località e anche il caching.
 Quindi il problema di packet classification ai bordi della rete diventa
 più semplice.
 Questi nodi di bordo aggiungono una intestazione o identificatore al pacchetto
 (ci sono svariate alternative possibili).
\end_layout

\begin_layout Itemize
Il limite di questa soluzione è che richiede di 
\series bold
modificare il protocollo
\series default
.
 Non ci sono problemi a farlo, ma è una operazione che ha un impatto non
 indifferente.
 Inoltre nel mondo del networking gli operatori aspirano sempre a quella
 che è chiamata 
\begin_inset Quotes eld
\end_inset


\emph on
vendor-independence
\emph default

\begin_inset Quotes erd
\end_inset

, cioè sognano di cambiare fornitore cambiando apparati senza problemi di
 compatibilità.
 Aspirano a questo perchè se si riesce a mettere in concorrenza i fornitori
 tra di loro si ottiengono prezzi più bassi.
 Quindi l'operatore ha interesse ad utilizzare protocolli standard.
 Se cambiamo i protocolli siamo costretti a ricadere nel 
\begin_inset Quotes eld
\end_inset


\emph on
vendor-lock-in
\emph default

\begin_inset Quotes erd
\end_inset

, cioè restare incatenato all'uso di un determinato fornitore.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Algoritmi di demultiplexing
\series default
 (tipo BPF):
\end_layout

\begin_deeper
\begin_layout Itemize
Le regole per cui viene utilizzo BPF è per le regole di exact match, non
 per prefix o range.
 BPF è pensato per un contesto diverso
\end_layout

\begin_layout Itemize
Non c'è inoltre una grande componibilità (
\emph on
composability
\emph default
): per capire qual'è la regola giusta bisogna guardarle tutte
\end_layout

\begin_deeper
\begin_layout Itemize
Esistono varianti di BPF (per esempio 
\emph on
pathfinder
\emph default
) che aumentano la possibilità di componibilità.
 Il problema è che per fare questo vengono imposte delle limitazioni abbastanza
 grandi.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
TCAM
\series default
:
\end_layout

\begin_deeper
\begin_layout Itemize
É la soluzione per ricconi, con i soliti problemi di area, potenza e costo.
\end_layout

\begin_layout Itemize
Inoltre c'è il problema che non abbiamo il range match: per realizzarlo
 bisogna moltiplicare le regole, aumentando quindi il costo del sistema.
\end_layout

\end_deeper
\begin_layout Subsection*
Nota su IPv6
\end_layout

\begin_layout Standard
In IPv6 è stato introdotto un campo di 20 bit chiamato 
\series bold
\emph on
Flow Label
\series default
\emph default
.
 L'uso di questo campo è opzionale, cioè allo stato attuale non viene utilizzato.
 L'idea che ci sta dietro tuttavia è che venga assegnato dalla sorgente
 del pacchetto per identificare tutti i pacchetti che fanno parte dello
 stesso 
\begin_inset Quotes eld
\end_inset


\emph on
flusso
\emph default

\begin_inset Quotes erd
\end_inset

.
 La definizione di 
\begin_inset Quotes erd
\end_inset

flusso
\begin_inset Quotes erd
\end_inset

 è abbastanza vaga e dipende dallo standard.
\end_layout

\begin_layout Standard
L'idea è che per evitare che il nodo interno a livello 3 debba andare a
 vedere informazioni nel livello 4, si è pensato di identificare una stessa
 connessione con questo campo.
 I nodi interni per sapere se due pacchetti fanno parte o meno della stessa
 connessione basta che guardino quindi il flow label.
\end_layout

\begin_layout Standard
La domanda è 
\begin_inset Quotes eld
\end_inset

come si può utilizzare questo campo per la packet classification?
\begin_inset Quotes erd
\end_inset

.
 Una volta che ho fatto una classificazione memorizzo la regola di match
 all'interno del flow label.
 Se la sorgente preserva tutte le caratteristiche normali , la classificazione
 diventa veloce.
 
\series bold
Sì, ma ci fidiamo della sorgente? Probabilmente no.

\series default
 Nel caso in cui non ci fidiamo bisogna aggiungere risorse.
 Un esempio sensato di utilizzo è nelle comunicazioni 
\begin_inset Quotes eld
\end_inset


\emph on
trunk
\emph default

\begin_inset Quotes erd
\end_inset

 tra nodi di gestione della rete.
\end_layout

\begin_layout Section*
Soluzioni algoritmiche al problema della classificazione
\end_layout

\begin_layout Standard
Ci sono una serie di algoritmi, nessuno dei quali è il migliore in generale.
\end_layout

\begin_layout Standard
Il principio generale da tenere a mente è che salvo situazioni particolari
 che si verificano in campo: forti correlazioni di pacchetti,etc...
 il caso generale richiede un tradeoff tra una grossa quantità di 
\series bold
memoria
\series default
 o una grossa quantità di 
\series bold
tempo
\series default
.
\end_layout

\begin_layout Subsection*
Set-pruning tries
\end_layout

\begin_layout Standard
È una estensione del tree uno-dimensionale.
\end_layout

\begin_layout Standard
È efficiente solo per due dimensioni, ad esempio quando il routing dipende
 sia dalla sorgente che dalla destinazione.
\end_layout

\begin_layout Standard
Si parte da un albero per tutte le destinazioni, poi 
\series bold
da ogni foglia 
\series default
con prefisso 
\begin_inset Formula $D$
\end_inset

 :
\end_layout

\begin_layout Itemize
Rimuovo dall'insieme delle regole quelle incompatibili con la 
\begin_inset Formula $D$
\end_inset

 
\end_layout

\begin_layout Itemize
Costruisco un albero per le sorgenti rimanenti nell'insieme delle regole.
\end_layout

\begin_layout Standard
Il problema principale di questa strategia è l'
\series bold
esplosione di memoria
\series default
: nel caso pessimo lo spazio occupato è nell'ordine di 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset


\end_layout

\begin_layout Standard
Possiamo estendere il tutto da 2 a 
\begin_inset Formula $k$
\end_inset

 dimensioni, ma otteniamo uno spazio occupato nell'ordine di 
\begin_inset Formula $O\left(n^{k}\right)$
\end_inset

 , che è anche peggio.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename tries_.png
	scale 27

\end_inset


\end_layout

\begin_layout Subsection*
Schema geometrico
\end_layout

\begin_layout Standard
Un prefisso è visto come un segmento, una regola a 2 dimensioni è un rettangolo,
 ...
\end_layout

\begin_layout Standard
Il pacchetto è visto come un punto.
\end_layout

\begin_layout Standard
Il problema di tipo geometrico diventa: troviamo l'ipercubo di costo minimo
 che contiene il punto.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename geometrico.png
	scale 25

\end_inset


\end_layout

\begin_layout Standard
In questo caso 
\begin_inset Formula $R_{1}$
\end_inset

 e 
\begin_inset Formula $R_{2}$
\end_inset

sono disgiunti, la regola 
\begin_inset Formula $R_{3}$
\end_inset

 è parzialmente coincidente con 
\begin_inset Formula $R_{1}$
\end_inset

 .
\end_layout

\begin_layout Standard
Usando strano artifici matematici, per 
\begin_inset Formula $K=2$
\end_inset

 si riesce ad ottenere una complessità nel tempo che è 
\begin_inset Formula $O\left(log\left(n\right)\right)$
\end_inset

.
 Purtroppo per 
\begin_inset Formula $K>2$
\end_inset

 abiamo una esplosione nel caso pessimo.
 Il motivo per cui il problema è così sofisticato è che nel caso generale
 dobbiamo trovare l'insieme di ipercubi che si possono intersecare tra di
 loro che contiene il pacchetto che ci interessa.
 Come facciamo a capire qual'è l'insieme degli ipercubi?La soluzione geometrica
 è far esplodere l'insieme di ipercubi e vederli come insiemi di classificazioni
 disgiunti.
 Nel caso generale se voglio contare le regioni disgiunte, ne ho 
\begin_inset Formula $O\left(n^{k}\right)$
\end_inset

.
 Il problema non è il numero di regole in sè, ma il fatto che si possono
 intersecare le regole, si determina come problema che il punto può appartenere
 a diverse regioni.
 Ovviamente non avremmo questo problema se le regioni non si intersecassero
 tra loro.
\end_layout

\begin_layout Subsubsection*
Osservazioni
\end_layout

\begin_layout Itemize
Il contenimento di prefissi è nella realtà abbastanza poco comune.
\end_layout

\begin_layout Itemize
I match di range sono abbastanza rari.
\end_layout

\begin_layout Itemize
Di solito le regole dal punto di vista delle coppie sorgente e destinazione
 sono abbastanza disgiunte.
 Questo fa concludere che forse la crescita delle regioni è abbastanza ridotta
\end_layout

\begin_layout Itemize
In conclusione gli schemi geometrici possono dare risultati soddisfacenti
 anche nel caso multidimensionale.
\end_layout

\begin_layout Subsection*
Bit Vector Linear Search
\end_layout

\begin_layout Standard
L'idea è:
\end_layout

\begin_layout Itemize
Fare il match su un singolo campo alla volta.
\end_layout

\begin_layout Itemize
Calcolare l'intersezione
\end_layout

\begin_layout Itemize
Ricercare le intersezioni
\end_layout

\begin_layout Standard
Come elimino i falsi positivi?
\end_layout

\begin_layout Itemize
Salvo solo le regole che soddisfano il match su tutti i campi.
 
\end_layout

\begin_layout Itemize
Trovo le regole che matchano.
\end_layout

\begin_layout Itemize
Cerco le intersezioni.
\end_layout

\begin_layout Standard
Come scelta qua utilizzamo per reappresentare le regole un vettore di bit
 di lunghezza 
\begin_inset Formula $n$
\end_inset

 dove il bit 
\emph on
i-esimo
\emph default
 indica se c'è un match sulla regola 
\emph on
i-esima
\emph default
.
\end_layout

\begin_layout Standard
Quindi mi troverò alla uscita della prima fase, 
\begin_inset Formula $k$
\end_inset

 vettori 
\emph on
n-dimensionali
\emph default
.
 Come faccio le intersezioni? Con un semplice AND di tutti i vettori di
 bit.
 Alla fine mi trovi un vettore 
\emph on
n-dimensionale
\emph default
 in cui sono posti a 1 i bit relativi alle regole su cui ho avuto i match
 sui vari campi.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename bit.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Abbiamo come vantaggio il fatto che possiamo 
\series bold
parallelizzare
\series default
 facilmente i confronti, e 
\series bold
aumentare
\series default
 il numero di AND elementari se il bus ha larghezza più grande.
\end_layout

\begin_layout Standard
Attenzione: la 
\series bold
complessità temporale
\series default
, dal punto di vista matematico è una 
\begin_inset Formula $O\left(n\right)$
\end_inset

 poichè l'operazione di AND bit a bit è comunque 
\begin_inset Formula $O\left(n\right)$
\end_inset

.
 Però le costanti sono basse: il costo di una operazione di AND è piccolo.
 È vero che asintoticamente sono in 
\begin_inset Formula $O\left(n\right)$
\end_inset

, però su numeri che non sono asintoticamente grandi, questo 
\begin_inset Formula $O\left(n\right)$
\end_inset

 ha un contributo abbastanza piccolo.
\end_layout

\begin_layout Standard
Per la precisione abbiamo:
\end_layout

\begin_layout Itemize

\series bold
Complessità temporale 
\series default

\begin_inset Formula $\frac{N\cdot\left(K+1\right)}{W}$
\end_inset

 dove 
\begin_inset Formula $W=\text{larghezza del bus}$
\end_inset

 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Ricontrollare
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Complessità spaziale
\series default
 
\begin_inset Formula $N^{2K}$
\end_inset

 bit nel caso pessimo 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Ricontrollare
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Abbiamo il piccolo svantaggio che gli arggionramenti sono lenti perché il
 database delle regole deve essere ricostruito.
\end_layout

\begin_layout Subsection*
Decision trees (Alberi decisionali)
\end_layout

\begin_layout Itemize
Simili alla struttura del 
\emph on
set-pruning
\emph default
.
\end_layout

\begin_layout Itemize
L'algoritmo 
\emph on
set-pruning
\emph default
 prova tutti i bit della destinazione, poi della sorgente.
 Se estendiamo a campi multipli, ogni campo è testato prima di spostarsi
 su un altro.
\end_layout

\begin_layout Itemize
Prima idea: Scegliere l'ordine ottimale per testare i bit.
 Si utilizzano solitamente delle euristiche per trovare la soluzione ottima.
\end_layout

\begin_layout Itemize
Seconda idea: dividere l'insieme delle regole in diversi alberi decisionarli:
 aumenta il tempo di riecerca ma riduce lo spazio.
\end_layout

\begin_layout Itemize
Terza idea: Per evitare di avere troppi livelli di alberi, effettuare una
 ricerca lineare nel livello più basso: aumenta il tempo di riecerca ma
 riduce lo spazio.
\end_layout

\begin_layout Standard

\series bold
Forte assunzione
\series default
: ci sono abbastanza campi distinti e regole disgiunte per evitare di avere
 troppe repliche delle regole alle foglie.
\end_layout

\begin_layout Standard
Se l'assunzione è vera allora la complessità temporale è circa costante
 e quella spaziale è circa lineare.
 L'aggiornamento è sempre lento.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename confront.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
Notiamo nella figura come i confronti vengano fatti in modo gerarchico e
 per range invece che testando i bit in maschere.
\end_layout

\begin_layout Section*
Routers 4 - Switching
\end_layout

\begin_layout Standard
Tra le operazioni principali svolte da un router troviamo:
\end_layout

\begin_layout Itemize
Lettura dell'intestazione del pacchetto
\end_layout

\begin_deeper
\begin_layout Itemize
Quando il pacchetto arriva bisogna decidere dove mandarlo, cosa farne.
\end_layout

\begin_layout Itemize
A seconda del tipo di protocollo che stiamo trattando, l'interpretazione
 dela intestazione avviene in diverso modo.
\end_layout

\end_deeper
\begin_layout Itemize
Una volta che si è deciso cosa fare del pacchetto bisogna prendere i bit
 su una interfaccia e spostarli su un'altra interfaccia.
 Questa è l'operazione di 
\series bold
switching o commutazione
\series default
.
 All'interno del nodo bisognerà fissare un percorso tra l'interfaccia di
 ingresso e l'interfaccia di uscita.
 Vedremo più avanti poi cosa succedere sulla interfaccia di uscita.
 Succederà che poi si formeranno delle code in uscita con relativi problemi
 di gestione.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename router2.png
	scale 38

\end_inset


\end_layout

\begin_layout Subsection*
Problemi da affrontare nello switching
\end_layout

\begin_layout Standard
Il compito dello switch è effettuare dei 
\series bold
match tra l'ingresso e l'uscita
\series default
.
 
\end_layout

\begin_layout Itemize
Dobbiamo effettuare matching pacchetto per pacchetto nell'ordine dei 
\bar under
nanosecondi
\bar default
.
\end_layout

\begin_layout Itemize
Dobbiamo tentare di fare il match tra 
\series bold
il numero più alto possibile di coppie ingressi-uscite
\series default
.
\end_layout

\begin_layout Itemize
Il problema può essere complicato tenendo conto di concetti come il 
\series bold
multicast
\series default
 dove un pacchetto potrebbe dover essere replicato su più uscite (nel multicast
 l'indirizzo del pacchetto specifica un gruppo di destinazioni).
\end_layout

\begin_layout Itemize
Facendo riferimento al problema astratto algoritmico abbiamo un insieme
 di nodi che rappresentano gli ingressi, un insieme di nodi che rappresentano
 le uscite e dobbiamo fare un match tra ingressi e uscite.
 Noi dobbiamo tentare di risolvere questo problema in tempi molto bassi.
 
\bar under
Se ad esempio lavoriamo a 40Gb/s dobbiamo effettuare una decisione in 
\begin_inset Formula $8ns$
\end_inset


\bar default
.
\end_layout

\begin_layout Standard
Dobbiamo trovare un 
\series bold
compromesso tra efficienza e rapidità
\series default
, quindi:
\end_layout

\begin_layout Itemize
Ci accontentiamo di minore accuratezza in cambio di maggiore velocità.
\end_layout

\begin_layout Itemize
Sfruttiamo il 
\series bold
parallelismo
\series default
, la 
\series bold
casualità
\series default
 e la possibilità di assegnare delle 
\series bold
priorità
\series default
.
\end_layout

\begin_layout Subsection*
Soluzione a memoria condivisa
\end_layout

\begin_layout Standard
La soluzione in assoluto più semplice che può venirci in mente è la shared
 memory: spostiamo i dati in memoria e li ricopiamo poi sull'interfaccia
 di uscita.
\end_layout

\begin_layout Standard
Il problema è che passando sempre per la memoria, questa rappresenta il
 collo di bottiglia.
 Abbiamo bisogno una memoria in grado di lavorare ad alta velocità.
\end_layout

\begin_layout Standard
Ad esempio con 32 ingressi/uscite da 1Gbit/s, la memoria deve essere almeno
 da 64Gbit/s.
\end_layout

\begin_layout Standard
Questa soluzione funziona quindi quando il numero di porte è molto piccolo
 oppure quando i collegamenti sono molto lenti, altrimenti abbiamo bisogno
 di memorie troppo veloci.
\end_layout

\begin_layout Subsection*
Soluzione a bus con singola CPU
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename linecard1.png
	scale 35

\end_inset


\end_layout

\begin_layout Standard
Una soluzione leggermente diversa è quella di far parlare direttamente le
 interfacce senza passare per la memoria.
 L'idea è di avere un bus unico a cui sono collegate tutte le interfacce.
\end_layout

\begin_layout Standard
La principale limitazione del bus è che transita un pacchetto per volta,
 quindi è il bus il collo di bottiglia.
\end_layout

\begin_layout Standard
Nella soluzione più semplice abbiamo 
\series bold
una cpu e un bus
\series default
.
\end_layout

\begin_layout Standard
Il collegamento presente tra le varie schede di rete e il bus centrale viene
 spesso chiamato 
\emph on

\begin_inset Quotes eld
\end_inset


\series bold
line card
\series default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Mentre la cpu sta decidendo cosa fare, il bus non fa niente.
 Inoltre la cpu ha anche altre cose da fare, quindi il tutto rallenta ulteriorme
nte.
 Il pacchetto inoltre deve attraversare il bus due volte, uno per essere
 letto dalla cpu, e la seconda volta per andare verso l'interfaccia di destinazi
one.
\end_layout

\begin_layout Subsection*
Soluzione a bus singolo e CPU
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename linecard2.png
	scale 35

\end_inset


\end_layout

\begin_layout Standard
Possiamo utilizzare più CPU in parallelo, diciamo 
\begin_inset Formula $M$
\end_inset

 CPU, che 
\series bold
devono coordinarsi
\series default
 (su questo abbiamo un 
\series bold
overhead
\series default
 di comunicazione tra le cpu).
 Le cpu utilizzano 
\begin_inset Formula $N$
\end_inset

 line card, quindi ogni cpu gestisce 
\begin_inset Formula $\frac{M}{N}$
\end_inset

 line cards.
 Il pacchetto però deve sempre (come nella soluzione precedente) 
\series bold
attraversare ogni line card due volte
\series default
 (oltre al bus centrale).
\end_layout

\begin_layout Subsection*
Soluzione con routing CPU
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename linecard3.png
	scale 35

\end_inset


\end_layout

\begin_layout Standard
Un'altra soluzione è utilizzare delle 
\series bold
CPU di routing
\series default
 
\bar under
all'interno di ogni line card
\bar default
, così evitiamo di far passare due volte sul bus, però ne passa sempre uno
 per volta; il bus è sempre un collo di bottiglia
\end_layout

\begin_layout Subsection*
Soluzione a 
\begin_inset Quotes eld
\end_inset


\emph on
crossbar
\emph default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename crossbar.png
	scale 35

\end_inset


\end_layout

\begin_layout Standard
Se vogliamo eliminare alla radice il problema della congestione del bus,
 dobbiamo aumentare il numero di bus.
 La soluzione 
\series bold
\emph on
overkill
\series default
 
\emph default
(che risolve i problemi ma è molto dispendiosa in tutti i sensi) è quella
 di mettere tanti bus quanti sono gli ingressi e tanti bus quante sono le
 uscite.
 Ogni linecard ha accesso ad un bus e ciascuno dei bus relativi alle linecard.
 Per accedere al bus e selezionare gli 
\begin_inset Quotes eld
\end_inset

incroci
\begin_inset Quotes erd
\end_inset

 da abilitare, possiamo utilizzare dei transistor.
 Questo tipi di collegamenti viene chiamato 
\begin_inset Quotes eld
\end_inset


\emph on
crossbar
\emph default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Nella crossbar vengono utilizzati 
\begin_inset Formula $2N$
\end_inset

 bus per 
\begin_inset Formula $N$
\end_inset

 interfacce di rete: 
\begin_inset Formula $N$
\end_inset

 per gli ingressi e 
\begin_inset Formula $N$
\end_inset

 per le uscite.
\end_layout

\begin_layout Standard
La velocità può arrivare nel caso ottimo ad essere 
\begin_inset Formula $N$
\end_inset

 volte superiore rispetto ai casi precedenti, se si riescono a trovare 
\begin_inset Formula $N$
\end_inset

 coppie di sorgenti e destinazioni disgiunte.
\end_layout

\begin_layout Standard
Ovviamente abbiamo il problema di quando due ingressi devono uscire sulla
 stessa interfaccia e lo possono fare solo uno alla volta.
\end_layout

\begin_layout Standard
Il numero di incroci della crossbar è uguale a 
\begin_inset Formula $N^{2}$
\end_inset

, per ogni paia di bus c'è un punto di incrocio.
 All'aumentare del numero di interfacce è vero che la complessità temporale
 è costante, ma cresce in 
\begin_inset Formula $N^{2}$
\end_inset

 .
\end_layout

\begin_layout Standard
Ogni incrocio è concettualmente realizzato mediante un transistor.
 Nella pratica è un po' più complesso.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename crossbar2.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
I pacchetti generalmente sono di lunghezza variabile.
 In alcuni casi questo è tollerato (ci sono algoritmi che lo tollerano)
 ma solitamente sono poco efficienti.
 
\end_layout

\begin_layout Standard
La soluzione è quindi di dividere i pacchetti in slot chiamati 
\begin_inset Quotes eld
\end_inset

celle
\begin_inset Quotes erd
\end_inset

 e viene fatto scheduling dividendo il tempo in slot di durata fissa.
 Nel protocollo 
\series bold
ATM
\series default
 ci sono pacchetti di dimensione fissa per considerare questo problema.
 In realtà al giorno d'oggi si preferisce suddividere i pacchetti in slot
 piuttosto che progettare un protocollo con dimensioni fisse.
\end_layout

\begin_layout Standard
Quindi con la crossbar dobbiamo decidere per ogni slot temporale la configurazio
ne da utilizzare per gli 
\begin_inset Formula $N^{2}$
\end_inset

 incroci.
\end_layout

\begin_layout Subsubsection*
Problemi da risolvere nel definire un algoritmo per lo scheduling della
 crossbar
\end_layout

\begin_layout Itemize
Due ingressi vogliono trasmettere sulla stessa uscita: 
\series bold
\bar under
ogni output ha al massimo un input
\series default
\bar default
.
\end_layout

\begin_layout Itemize
Vogliamo massimizzare il numero di output che ricevono qualcosa.
\end_layout

\begin_layout Subsubsection*
Fattori che influenzano il problema
\end_layout

\begin_layout Itemize
Qualche porta di input potrebbe non avere dati da inviare
\end_layout

\begin_layout Itemize
Alcuni input potrebbero voler parlare con lo stesso output
\end_layout

\begin_layout Subsection*
Utilizzo della crossbar: Algoritmo 
\emph on

\begin_inset Quotes eld
\end_inset

take-a-ticket
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Il primo algoritmo che vediamo, pensato per Ethernet, è 
\series bold
take-a-ticket
\series default
.
 Lavora con pacchetti di lunghezza variabile e non è quindi necessario suddivide
re i pacchetti in celle.
 Questo è uno dei pochi algoritmi che non usa pacchetti di grandezza fissata.
\end_layout

\begin_layout Standard
(La necessità di dividere i pacchetti in celle esiste tutte le volte che
 abbiamo a che fare con una crossbar o con una architettura a più stadi,
 nella architettura a singolo bus non c'è questo problema)
\end_layout

\begin_layout Standard
L'algoritmo take-a-ticket utilizza un sistema di gestione delle code simile
 a quelli utilizzati al giorno d'oggi nelle code postali, negli uffici..
\end_layout

\begin_layout Itemize
Ogni linecard di uscita 
\begin_inset Formula $S$
\end_inset

 tiene una coda di pacchetti in uscita che devono essere inviati ad 
\begin_inset Formula $S$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Le varie parti della coda sono mantenute in una singola coda all'ingresso
 
\begin_inset Formula $R$
\end_inset

 (ingresso di buffering).
\end_layout

\begin_layout Itemize
Se la linecard 
\begin_inset Formula $R$
\end_inset

 vuole inviare un pacchetto a 
\begin_inset Formula $S$
\end_inset

, chiede un numero di attesa per quella specifica uscita.
 Se l'uscita S è libera, allora annuncia sul bus qual'è il prossimo numero
 che deve essere servito.
\end_layout

\begin_layout Itemize
\begin_inset Formula $S$
\end_inset

 imposta quindi l'incrocio 
\begin_inset Formula $R/S$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $R$
\end_inset

 invia il pacchetto.
\end_layout

\begin_layout Standard
La linecard mantiene quindi una unica coda relativa all'uscita, la quale
 è però distribuita perché i pacchetti non sono fisicamente accodati nello
 stesso posto ma sono in attesa nella linecard di 
\series bold
arrivo
\series default
.
 
\end_layout

\begin_layout Standard
Vediamo un esempio.
 Mettiamo tutti gli ingressi da una parte e tutte le usicte dall'altra.
 Abbiamo tre ingressi A,B,C e quattro uscite 1,2,3,4.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename round2.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Vediamo i vari passaggi:
\end_layout

\begin_layout Itemize

\series bold
A
\series default
 vuole inviare un pacchetto a 1,2 e 3
\end_layout

\begin_layout Itemize

\series bold
A,B
\series default
 e
\series bold
 C
\series default
 chiedono un ticket per l'uscita 1
\end_layout

\begin_layout Itemize
La porta 1 dà il ticket 
\series bold
#1 ad A
\series default
, 
\series bold
#2 a B
\series default
 e 
\series bold
#3 a C
\end_layout

\begin_layout Itemize

\series bold
A
\series default
 è autorizzato a trasmettere
\end_layout

\begin_layout Itemize
Le altre porte sono bloccate (head-of-line blocking problem)
\end_layout

\begin_layout Standard
L'
\series bold
\emph on
head-of-line blocking
\series default
\emph default
 è il problema per cui anche se i pacchetti dietro non hanno nessun motivo
 di aspettare perchè la destinazione è libera, devono aspettare perchè quello
 davanti è fermo.
\end_layout

\begin_layout Standard
Passiamo al secondo round:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename round3.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize

\series bold
A
\series default
 chiede un ticket per l'uscita 
\series bold
2
\end_layout

\begin_layout Itemize
La porta 
\series bold
2
\series default
 dà il ticket 
\series bold
#1
\series default
 ad 
\series bold
A
\end_layout

\begin_layout Itemize
La porta 
\series bold
1
\series default
 annuncia il ticket 
\series bold
#2
\end_layout

\begin_layout Itemize
La porta 
\series bold
1
\series default
 annuncia il ticket 
\series bold
#1
\end_layout

\begin_layout Itemize

\series bold
A
\series default
 e 
\series bold
B
\series default
 trasmettono, 
\series bold
C
\series default
 è bloccato.
\end_layout

\begin_layout Standard
Vediamo ora al terzo turno:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename round4.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize

\series bold
A
\series default
 richiede un ticket per la porta 3, che restituisce il ticket 
\series bold
#1
\end_layout

\begin_layout Itemize

\series bold
B
\series default
 richiede un ticket per la porta 2, che restituisce il ticket 
\series bold
#2
\end_layout

\begin_layout Itemize
Le porte 
\series bold
1,2,3
\series default
 annunciano i turni per 
\series bold
#3,#2,#1
\end_layout

\begin_layout Itemize

\series bold
A,B,C
\series default
 trasmettono
\end_layout

\begin_layout Itemize
Nessuna porta viene bloccata
\end_layout

\begin_layout Standard
Valutiamo le prestazioni.
 Supponiamo che i pacchetti presentati in ingresso siano uniformati verso
 tutte le possibili uscite.
 Qual'è la probabiità che una porta di output non sia utilizzata? Non è
 utilizzata se non c'è nessun pacchetto destinato verso quell'output in
 attesa verso la prima posizione in ingresso.
 Considerando la probabilità che un generico pacchetto voglia andare su
 quella porta è 
\begin_inset Formula $\frac{1}{N}$
\end_inset

.
 La probabilità che non ci vada è 
\begin_inset Formula $\left(1-\frac{1}{N}\right)$
\end_inset

, la probabilità che non vada in nessuna è 
\begin_inset Formula $\left(1-\frac{1}{N}\right)^{N}$
\end_inset

, la probabilità che una cerca porta di uscita non sia utilizzata è quindi:
 
\begin_inset Formula 
\[
1-\left(1-\frac{1}{N}\right)^{N}
\]

\end_inset


\end_layout

\begin_layout Standard
Per 
\begin_inset Formula $N$
\end_inset

 grande converge a 
\begin_inset Formula $\left(1-\frac{1}{e}\right)\simeq63\%$
\end_inset


\end_layout

\begin_layout Standard
Altri calcoli forniscono l'efficienza ~ 58%
\end_layout

\begin_layout Standard
Distribuzioni non uniformi di traffico possono dare anche risultati peggiori.
\end_layout

\begin_layout Standard
Se accettiamo di scambiare di posto i pacchetti possiamo avere dei vantaggi.
\end_layout

\begin_layout Standard
La prima soluzione è tentare di fare le code in uscita anziché in entrata.
 Tentiamo di far arrivare i pacchetti rapidamente in uscita.
\end_layout

\begin_layout Standard
Per migliorare le prestazioni del caso pessimo è necessario uno speedup
 di 
\begin_inset Formula $N$
\end_inset

 volte.
 Per la precisione è ncessario uno speedup di 
\begin_inset Formula $k$
\end_inset

, dove 
\begin_inset Formula $k$
\end_inset

 è il numero atteso di celle contendenti per lo stesso output.
\end_layout

\begin_layout Subsection*
Parallel Iterative Matching (PIM)
\end_layout

\begin_layout Standard
Si suddivide la coda su ogni ingresso in diverse code separate a seconda
 dell'uscita.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pim.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Notiamo che PIM per funzionare richiede pacchetti di lunghezza fissa e il
 tempo suddiviso in slot.
\end_layout

\begin_layout Standard
Vediamo il funzionamento nelle sue varie fasi:
\end_layout

\begin_layout Itemize

\series bold
Request
\end_layout

\begin_deeper
\begin_layout Itemize
Ogni porta di ingresso comunica il suo stato utilizzando una 
\emph on
bitmap
\end_layout

\begin_layout Itemize
Ogni bit rappresenta una coda di uscita:
\end_layout

\begin_deeper
\begin_layout Itemize
0 = La coda 
\begin_inset Quotes eld
\end_inset

virtuale
\begin_inset Quotes erd
\end_inset

 di uscita ha almeno un pacchetto.
\end_layout

\begin_layout Itemize
1 = La coda 
\begin_inset Quotes eld
\end_inset

virtuale
\begin_inset Quotes erd
\end_inset

 di uscita è vuota.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Grant
\end_layout

\begin_deeper
\begin_layout Itemize
Ogni porta di uscita sceglie una porta di ingresso.
\end_layout

\begin_layout Itemize
Quando una porta di uscita riceve una richiesta da 
\series bold
più
\series default
 porte di ingresso, ne sceglie una a caso.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Accept
\end_layout

\begin_deeper
\begin_layout Itemize
Se una porta di ingresso è scelta a caso da più porte di uscita, se ne sceglie
 una a caso.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Graphics
	filename pim2.png
	scale 40

\end_inset


\end_layout

\begin_layout Section*
Buffer management e scheduling
\end_layout

\begin_layout Standard
Abbiamo visto cosa succede all'ingresso del pacchetto nel nodo (vengono
 prese delle decisioni in base alla intestazione).
 Abbiamo visto in che modo materialmente i pacchetti che si presentano su
 una certa interfaccia fisica vengono spostati sulla interfaccia fisica
 di uscita attraverso una matrice di commutazione o una più sofisticata
 rete di commutazione o semplicemente attraverso un bus di comunicazione.
 I nostri pacchetti sono quindi arrivati sulla interfaccia di uscita.
 In generale succederà che sulla interfaccia di uscita potrebbero presentarsi
 più pacchetti provenienti da diverse interfacce di entrata e potrebbe succedere
 che più pacchetti trovino occupata l'interfaccia di uscita perché sta già
 trasmettendo.
 Questo accade soprattutto quando il traffico non è uniforme.
 Abbiamo visto che uno dei problemi che si presentano negli switch è l'
\emph on
end-of-line blocking
\emph default
.
 Uno dei modi per risolvere questi problemi è quello di velocizzare il calcolo
 interno rispetto alla velocità con cui arrivano i dati.
\end_layout

\begin_layout Standard
Dobbiamo ora vedere cosa succede quando ci sono delle code.
 Dobbiamo vedere come gestire il buffer di uscita in modo che non penalizzi
 il traffico di alcuni flussi rispetto ad altri.
 Inoltre è prassi comune che sulla interfaccia di uscita ci siano
\series bold
 code multiple
\series default
 in base a varie caratteristiche del pacchetto (ad esempio in base al tipo
 di applicazione).
 Si tratterà di capire quindi quale coda deve essere servita quando l'uscita
 è libera.
\end_layout

\begin_layout Standard
L'opzione di 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 sull'interfaccia di uscita è la cosìdetta 
\emph on
fifo con tail-drop
\emph default
.
\end_layout

\begin_layout Standard

\series bold
\emph on
FIFO
\series default
\emph default
 sta per la politica utilizzata per gestire la coda (
\emph on
First In First Out
\emph default
).
 Per la gestione del buffer l'opzione è la 
\emph on
tail-drop
\emph default
: fin quando c'è posto nel buffer li accodo, quando non c'è più posto li
 butto via.
\end_layout

\begin_layout Standard
Entrambe queste due opzioni vanno bene in molti casi, però talvolta danno
 luogo a dei problemi che devono essere affrontati.
\end_layout

\begin_layout Subsection*
Considerazioni sul traffico 
\end_layout

\begin_layout Itemize
La maggior parte del traffico di rete è TCP, raramente abbiamo flussi UDP
 e quelli che ci sono spesso utilizza meccanismi interni per il controllo
 di congestione.
\end_layout

\begin_deeper
\begin_layout Itemize
La particolarità utile di TCP in questo caso è che un pacchetto perso viene
 interpretato come congestione.
 Quindi perdendo pacchetti possiamo regolare la velocità.
\end_layout

\end_deeper
\begin_layout Itemize
Il problema è che l'anello chiuso di controllo che si forma ha un tempo
 abbastanza lungo e confrontabile al RTT.
 Questo perché per scoprire la perdita bisogna aspettare un timeout.
 Quindi c'è una 
\series bold
dinamica troppo lenta
\series default
.
\end_layout

\begin_layout Itemize
Inoltre se vengono mandati dei 
\emph on
burst
\emph default
 di pacchetti ci può essere un problema di congestione sulla coda del router
 e determinare perdite a 
\emph on
burst
\emph default
 di pacchetti.
 Il problema è che quando il buffer è pieno scarto tutti gli altri pacchetti
 che arrivano, solitamente provenienti tutti dalla stessa sorgente.
 Quindi gli 
\begin_inset Formula $n$
\end_inset

 pacchetti che arrivano sul buffer quando è pieno, vengono abbandonati.
\end_layout

\begin_deeper
\begin_layout Itemize
Inoltre in TCP dei 
\emph on
burst
\emph default
 di pacchetti persi vengono interpretati come una 
\series bold
\emph on
grave congestione
\series default
\emph default
.
\end_layout

\end_deeper
\begin_layout Itemize
La perdita di pacchetti di tipo 
\emph on
tail-drop
\emph default
 determina perdite di pacchetti tutte allo stesso tempo, quindi tutte le
 sorgenti che mandano pacchetti durante una congestione vengono rallentate
 perché perdono pacchetti.
 Il risultato è che si presenta un fenomeno di 
\series bold
sincronizzazione
\series default
.
 Tutte le sorgenti che tentano di inviare quando il buffer è pieno, tutte
 abbassano la velocità e ritentano contemporaneamente e il buffer si riempie
 nuovamente perché lo riempiono tutti contemporaneamente.
\end_layout

\begin_deeper
\begin_layout Itemize
Il nostro scopo sarà quindi quello di determinare degli sfasamenti casuali
 tra l'invio delle varie sorgenti, per evitare fenomeni di sincronizzazione
\end_layout

\end_deeper
\begin_layout Itemize
Le sorgenti 
\begin_inset Quotes eld
\end_inset

voraci
\begin_inset Quotes erd
\end_inset

 si prendono tante risorse e gli altri non prendono niente.
 Le risorse non vengono distribuite uniformemente a tutti ma gli altri vengono
 schiacciati.
\end_layout

\begin_layout Subsection*
Obiettivi
\end_layout

\begin_layout Itemize
Abbiamo quindi la necessità di una migliore gestione del buffer.
 Per migliore intendiamo una gestione che sia più 
\series bold
coerente con le dimaniche del TCP
\series default
.
 Dobbiamo dare quindi più informazioni alle sorgenti di quelle che vengono
 date utilizzando solo il drop.
 L'idea è di non lasciare al caso (la dinamica della rete) la decisione
 di quali pacchetti scartare.
 Noi dovremo scartare pacchetti quando c'è un 
\begin_inset Quotes eld
\end_inset

sintomo
\begin_inset Quotes erd
\end_inset

 di congestione, prima che essa avvenga.
\end_layout

\begin_layout Itemize
Vorremmo garantire le stesse risorse a tutti.
\end_layout

\begin_layout Itemize
Vogliamo garantire la qualità di servizio: vogliamo dare prestazioni 
\series bold
misurabili
\series default
 all'utente: vogliamo promettere all'utente di avere una certa quantità
 di 
\begin_inset Formula $\frac{KB}{s}$
\end_inset


\end_layout

\begin_layout Subsection*
Soluzione RED (Random Early Detection)
\end_layout

\begin_layout Standard
È lo standard nei router di fascia medio-alta.
\end_layout

\begin_layout Standard
L'idea di base è prendere decisioni in base alla lunghezza 
\series bold
media
\series default
 della coda.
 Questo ci permette di ovviare a problemi di congestione con durata 
\series bold
lunga
\series default
.
 Non ci interessano i fenomeni di congestione 
\series bold
momentanea
\series default
.
\end_layout

\begin_layout Standard

\series bold
Scartiamo pacchetti non quando la coda è piena, ma con una probabilità crescente
 al crescere della lunghezza della coda.
\end_layout

\begin_layout Standard
In questo modo siamo abbastanza sicuri di distribuire gli eventi di scarto
 tra diverse sorgenti e quindi di desincronizzare la dimanica di congestione
 delle varie sorgenti.
\end_layout

\begin_layout Standard
Ovviamente questo ha delle potenziali inefficiente (scartiamo pacchetti
 anche quando ci sono risorse).
\end_layout

\begin_layout Standard
Tutto questo discorso non ha senso per 
\series bold
UDP
\series default
, perché se la sorgente è ad anello aperto e trasmette sempre, anche droppando
 pacchetti non risolviamo.
\end_layout

\begin_layout Standard
Un evento di perdita singolo in TCP viene identificato in base al meccanismo
 di 
\emph on
fast-retransmit
\emph default
: quando c'è un 
\begin_inset Quotes eld
\end_inset

buco
\begin_inset Quotes erd
\end_inset

 nei numeri di sequenza vengono inviati due riscontri
\begin_inset Note Note
status open

\begin_layout Plain Layout
controllare
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename red1.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Un evento singolo di perdita genera un evento di piccola identità.
\end_layout

\begin_layout Standard
Una perdita di pacchetti multipli non viene identificata da TCP se non tramite
 il timeout.
 Il timeout però può arrivare a valori molto elevati: abbiamo un anello
 chiuso ma molto lento.
\end_layout

\begin_layout Standard
In caso di perdita multipla l'oscillazione è 
\series bold
molto
\series default
 ampia.
\end_layout

\begin_layout Standard
Idealmente noi vorremmo un meccanismo che fermi il TCP con una singola perdita
 in prossimità della banda massima disponibile, questo perchè gli eventi
 di perdita multipla determinano inefficienza.
\end_layout

\begin_layout Standard
Il 
\series bold
RED
\series default
 tiene traccia della lunghezza media della coda, che viene calcolata con
 un filtro di tipo 
\emph on
passa-basso
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
AvarageQ=\left(1-W\right)\cdot AvarageQ+\left(W*SampleQsize\right)
\]

\end_inset


\end_layout

\begin_layout Standard
In questo modo dei 
\emph on
burst
\emph default
 di circa 
\begin_inset Formula $\frac{1}{W}$
\end_inset

 pacchetti hanno un impatto limitato sullo spostamento.
 Burst piccoli provocano uno spostamento piccolo.
 Questo filtraggio passa-basso implica che picchi di traffico determinino
 delle 
\begin_inset Quotes eld
\end_inset

gobbe
\begin_inset Quotes erd
\end_inset

 brevi e ci interessiamo quindi di più alla congestione di lunga durata.
\end_layout

\begin_layout Itemize
Fissiamo poi delle soglie: sotto una certa soglia non scartiamo pacchetti.
\end_layout

\begin_layout Itemize
Tipicamente nel percorso del TCP sulla rete ci sarà 
\series bold
un
\series default
 router su cui si verifica la congestione.
 Quello sarà il 
\emph on
bottleneck-router
\emph default
.
 Quindi tutti i router che non sono 
\emph on
bottleneck
\emph default
 avranno una coda molto corta.
\end_layout

\begin_layout Itemize
Tra le due soglie abbiamo la regione ideale di funzionamento del 
\emph on
bottleneck-router
\emph default
.
 Noi a regime ci aspettiamo che la velocità del 
\emph on
bottleneck-router 
\emph default
sia compresa tra le due soglie.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename red2.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
C'è un ultimo aspetto da tener presente: in base alla lunghezza media della
 coda noi calcoliamo una probabilità di scarto.
 Nessuno però mi dice qual'è l'influenza della lunghezza della coda sulla
 probabilità.
 
\end_layout

\begin_layout Standard
Il tipo di variabile casuale che ci interessa è una 
\emph on
bernoulliana
\emph default
.
\end_layout

\begin_layout Standard
Dobbiamo stare attenti a non fare burst di drop di pacchetti.
\end_layout

\begin_layout Standard
Una soluzione alternativa a bernoulli è quello di utilizzare una probabilità
 di scarto che inizia molto bassa e poi cresce all'aumentare del numero
 di pacchetti che non sono ancora stati scartati dall'ultimo evento di scarto.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
c=\text{numero di pacchetti non ancora scartati dall'ultimo evento di scarto}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
p_{b}=\text{probabilità di scarto}
\]

\end_inset


\end_layout

\begin_layout Standard
Diciamo quindi che la probabilità di scartare ogni pacchetto è 
\begin_inset Formula 
\[
\frac{p_{b}}{\left(1-c\cdot p_{b}\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
Ci sono tante varianti di RED.
 Una interessante è la 
\series bold
\emph on
Weighted RED
\series default
\emph default
: la probabilità cambia a seconda del tipo di pacchetto.
\end_layout

\begin_layout Standard
La cosa importante del RED è che per come l'abbiamo descritto, funziona
 con un singolo buffer.
 La distinzione del traffico in 
\emph on
Weighted RED
\emph default
 la facciamo in ingresso al buffer.
\end_layout

\begin_layout Subsection*
Token Bucket Policing
\end_layout

\begin_layout Standard
Specifichiamo una velocità massima media e la lunghezza massima (in tempo)
 di un burst di pacchetti.
 
\end_layout

\begin_layout Standard
L'implementazione richiede un contatore e un timer.
\end_layout

\begin_layout Standard
Il contatore cresce nel tempo con una velocità 
\begin_inset Formula $R$
\end_inset

 (la velocità a cui vogliamo limitare il traffico).
 Questo contatore può arrivare al massimo al valore 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard
Quando un pacchetto di lunghezza 
\begin_inset Formula $L$
\end_inset

 si presenta, se il contatore vale meno di 
\begin_inset Formula $L$
\end_inset

 , il pacchetto viene scartato.
 Se il contatore è maggiore di 
\begin_inset Formula $L$
\end_inset

, si accetta il pacchetto e si decrementa il contatore di 
\begin_inset Formula $L$
\end_inset

.
\end_layout

\begin_layout Standard
Su una scala temporale piccola permettiamo una velocità non limitata (ma
 al massimo di 
\begin_inset Formula $B$
\end_inset

 pacchetti).
\end_layout

\begin_layout Standard
Una variante di questo algoritmo, lo shaper, utilizza una coda dove memorizza
 i pacchetti al posto di scartarli.
\end_layout

\begin_layout Subsection*
Scheduling
\end_layout

\begin_layout Standard
Per garantire la qualità del servizio il router dovrebbe garantire ad ogni
 flusso:
\end_layout

\begin_layout Itemize
Banda garantita (bit serviti in una certa unità di tempo fissata, generalmente
 grande)
\end_layout

\begin_layout Itemize
Bassa latenza (tempo tra l'arrivo del pacchetto all'ingresso e quando viene
 messo in uscita)
\end_layout

\begin_layout Standard
Non riusciamo a garantire entrambe le cose, dobbiamo trovare una via di
 mezzo.
\end_layout

\begin_layout Standard
Possiamo utilizzare code multiple: i pacchetti in uscita vengono classificati
 e inseriti in code di uscita diverse.
\end_layout

\begin_layout Standard
Quindi abbiamo bisogno:
\end_layout

\begin_layout Itemize
Un classificatore che ci permette di scegliere in quale coda inviare un
 pacchetto
\end_layout

\begin_layout Itemize
Uno scheda di gestione del buffer per ogni coda
\end_layout

\begin_layout Itemize
Uno scheduler che mi dice quando il canale si libera quale coda servire.
\end_layout

\begin_deeper
\begin_layout Itemize
Ci sono centinaia di scheduler.
 Noi ci concentriamo su scheduler 
\emph on
non-preemtive
\emph default
 (non bloccano pacchetti in trasmissione per sostituirli) e 
\emph on
work-conservative
\emph default
 (trasmettere sempre quando il canale è libero).
\end_layout

\begin_deeper
\begin_layout Itemize
Gli scheduler 
\emph on
preemtive
\emph default
 sono rari e hanno senso solo su collegamenti 
\series bold
molto
\series default
 lenti.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Vediamo alcuni 
\series bold
scheduler semplici
\series default
:
\end_layout

\begin_layout Itemize
Code a priorità: si serve prima la coda x, poi la coda y,...
 Il tutto funziona se non mettiamo ad alta priorità delle sorgenti 
\emph on
greedy
\emph default
.
\end_layout

\begin_layout Itemize
Il 
\series bold
Round Robin
\series default
 (
\series bold
RR
\series default
) ha lo scopo di dividere equamente tra le varie code e viene suddivisa
 per flusso.
 Si possono poi fissare dei 
\begin_inset Quotes eld
\end_inset

pesi
\begin_inset Quotes erd
\end_inset

 per dare più banda a certe code rispetto ad altre.
\end_layout

\begin_deeper
\begin_layout Itemize
Il servizio ideale di round-robin è il 
\series bold
bit-to-bin round robin
\series default
.
 Però noi possiamo servire solo 
\begin_inset Quotes eld
\end_inset

pacchetti
\begin_inset Quotes erd
\end_inset

, non bit singoli.
 Il problema è che i pacchetti possono avere dimensioni diverse.
\end_layout

\end_deeper
\begin_layout Subsubsection*
Round Robin
\end_layout

\begin_layout Standard
Serviamo alternativamente pacchetti dalle varie code.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename roundrobin.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Problema: se qualcuno nelle code invia pacchetti più grandi si prende più
 risorse.
 
\end_layout

\begin_layout Subsubsection*
Deficit Round Robin (DRR)
\end_layout

\begin_layout Standard
Per ogni flusso
\begin_inset Foot
status open

\begin_layout Plain Layout
Insieme di pacchetti che saranno trattati allo stesso modo
\end_layout

\end_inset

 
\begin_inset Formula $i$
\end_inset

 abbiamo una coda separata.
 Per ciascuno avremo un 
\emph on
quantum size 
\begin_inset Formula $Q_{i}$
\end_inset

 
\emph default
e un contatore di 
\emph on
deficit 
\emph default

\begin_inset Formula $D_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Se i 
\begin_inset Formula $Q_{i}$
\end_inset

 sono tutti uguali, la banda viene data in modo uguale a tutti, se lo aumento
 il flusso prende più risorse.
\end_layout

\begin_layout Standard
[omissis]
\end_layout

\begin_layout Itemize
Faccio un ciclo su tutte le code.
 
\end_layout

\begin_layout Itemize
Quando arrivo alla coda 
\emph on
i-esima
\emph default
 non trasmetto il pacchetto ma incremento il deficit 
\begin_inset Formula $D_{i}$
\end_inset

 sommando 
\begin_inset Formula $Q_{i}$
\end_inset

.
 Se c'è qualcosa nella coda spedisco al più 
\begin_inset Formula $D_{i}$
\end_inset

 bit o byte.
 Ovviamente non trasmetto mezzi pacchetti: se non ho abbastanza deficit
 per un intero pacchetto, non mando niente e aspetto di accumulare abbastanza
 deficit.
\end_layout

\begin_layout Standard
In un tempo sufficientemente lungo tutti hanno ricevuto la stessa quantità
 di 
\emph on
quanti
\emph default
 e quindi sul lungo termine tutti hanno avuto la stessa quantità di autorizzazio
ni.
 Sul 
\series bold
breve termine invece
\series default
 l'ordine con cui visito le code e la lunghezza dei pacchetti, non è grantita
 la concorrenza pari tra i vari flussi.
 
\end_layout

\begin_layout Standard
Questo è dovuto al fatto che in DRR 
\bar under
si possono inviare più pacchetti per round
\bar default
.
\end_layout

\begin_layout Standard
Inoltre prima di essere servito un pacchetto, devo aspettare che vengano
 inviati da tutte le altre code prima.
 Questo provoca delle forti latenze.
 Nel caso sfortunato può succedere che le code prima del flusso considerato
 siano vuote e si riempino man mano che il round-robin le analizza.
 Abbiamo 
\series bold
\bar under
ritardi poco prevedibili
\series default
!
\end_layout

\begin_layout Standard
(Un' interessante variante è quella di strutturare DRR in modo gerarchico:
 
\series bold
\emph on
Hierarchical DRR
\series default
\emph default
).
\end_layout

\begin_layout Standard
Vediamo un esempio di come funziona il DRR.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename roundrobin2.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
In questo esempio assumiamo che:
\end_layout

\begin_layout Itemize
Tutte le code hanno pacchetti da inviare.
 Non ci sono mai momenti in cui una coda è vuota.
\end_layout

\begin_layout Itemize
\begin_inset Formula $D_{i}=0$
\end_inset

 inizialmente
\end_layout

\begin_layout Itemize
\begin_inset Formula $Q_{i}=500\,\left[byte\right]$
\end_inset


\end_layout

\begin_layout Itemize
Primo ciclo: analisi del flusso F1:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $D_{1}=0+Q_{1}=500$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $500\,\geq\,200$
\end_inset

 quindi decido di inviare il pacchetto in coda
\end_layout

\begin_layout Itemize
\begin_inset Formula $D_{1}=D_{1}-200=300$
\end_inset


\end_layout

\begin_layout Itemize
Il pacchetto da 750 byte non può essere inviato poiché abbiamo solo 300
 byte di deficit
\end_layout

\begin_layout Itemize
Salviamo i 300 in 
\begin_inset Formula $D_{1}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Primo ciclo: analisi del flusso F2:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $D_{2}=0+Q_{2}=500$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $500\geq500$
\end_inset

 quindi decido di inviare il pacchetto in coda
\end_layout

\begin_layout Itemize
\begin_inset Formula $D_{2}=D_{2}-500=0$
\end_inset


\end_layout

\begin_layout Itemize
Il deficit finale è esaurito, non posso inviare altro.
\end_layout

\end_deeper
\begin_layout Itemize
[...]
\end_layout

\begin_layout Standard

\series bold
Quando la coda si svuota il deficit viene azzerato
\series default
.
 Questo viene fatto altrimenti una sorgente potrebbe accumulare un deficit
 troppo elevato e poi inviare un burst esagerato.
\end_layout

\begin_layout Standard
Se scelgo dei quanti troppo piccoli, devo fare una notevole quantità di
 iterazioni prima di poter trasmettere un pacchetto.
 Quindi perderei un sacco di tempo.
 La strada che si segue è quella di fissare il quanto abbastanza grande
 da trasmettere almeno un pacchetto per ogni iterazione.
 Solitamente si fissa il 
\begin_inset Formula $Q_{i}$
\end_inset

 superiore alla dimensione del pacchetto massimo.
\end_layout

\begin_layout Standard
Spesso per risolvere il problema prima citato le code vuote escono dal servizio.
 Queste vengono definite 
\emph on
ActiveList
\emph default
.
 Invece di avere le code in ordine fissato, associo queste code a dei puntatori
 e poi tengo una lista di code.
 Se una coda diventa vuota la tolgo dalla lista.
 Quando una coda diventa attiva prendo il puntatore alla coda precedentemente
 vuota e la metto in fondo alla lista delle code attive.
\end_layout

\begin_layout Standard
L'unica differenza di questo schema rispetto al precedente (a parte l'efficienza
) è che l'ordine con cui visito le code non è più predeterminato.
 Ci dà fastidio il fatto che l'ordine delle code cambi? No, non ha nessun
 impatto sulla 
\emph on
fairness 
\emph default
di lungo termine.
\end_layout

\begin_layout Part*
Misurazione del traffico
\end_layout

\begin_layout Standard
Ci interessa fare delle misurazioni all'interno della nostra rete per poterla
 controllare meglio.
 Per prendere decisioni dobbiamo essere in grado di misurare lo stato e
 l'effetto delle nostre decisioni e rendere la rete più controllabile.
\end_layout

\begin_layout Standard
Sostanzialmente l'attività principale nella misurazione consiste in:
\end_layout

\begin_layout Itemize

\series bold
Packet counting
\end_layout

\begin_layout Itemize

\series bold
Byte couting
\end_layout

\begin_layout Standard
Queste informazioni sono utili per tre principali motivi:
\end_layout

\begin_layout Itemize
La definizione della 
\series bold
capacità necessaria
\series default
 per il corretto funzionamento della rete
\end_layout

\begin_layout Itemize

\series bold
Accounting
\series default
: conteggiare i 
\begin_inset Quotes eld
\end_inset

consumi
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Conoscere il 
\series bold
tipo di traffico
\series default
 che attraversa la rete.
\end_layout

\begin_layout Subsection*
Controllo della capacità
\end_layout

\begin_layout Standard
Quindi lo scopo della misura è concentrato principalmente sulla misurazione
 della 
\series bold
capacità
\series default
 necessaria.
 
\end_layout

\begin_layout Standard
Si costruisce solitamente una 
\series bold
matrice di traffico
\series default
 dove vediamo il traffico per varie combinazioni di reti che comunicano
 tra loro.
\end_layout

\begin_layout Standard
Ci è utile per capire dove sono i colli di bottiglia e aumentare le capacità
 della rete
\end_layout

\begin_layout Subsection*
Accounting
\end_layout

\begin_layout Itemize
Ci serve per verificare i 
\series bold
\emph on
Service Level Agreements
\series default
\emph default
 (
\series bold
\emph on
SLA
\series default
\emph default
)
\begin_inset Foot
status open

\begin_layout Plain Layout
Ci si riferisce agli accordi stabiliti con i clienti da parte degli ISP
 per garantire i requisiti minimi garantiti delle connessioni
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Vogliamo identificare i flussi più 
\series bold
significativi
\series default
 per decidere se fare dei 
\begin_inset Quotes eld
\end_inset


\emph on
peering agreements
\emph default

\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Accordi che vengono stipulati tra un ISP e una specifica destinazione per
 utilizzare una lina di comunicazione dedicata.
 Ciò viene ad oggi spesso fatto con Google.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Analisi del traffico
\end_layout

\begin_layout Itemize
Classificazione dei tipi di traffico
\end_layout

\begin_layout Itemize
Identificazione di possibili attacchi
\end_layout

\begin_layout Section*
Costruzione della matrice di traffico
\end_layout

\begin_layout Standard
Supponiamo che un provider abbia 
\begin_inset Formula $N$
\end_inset

 collegamenti da/a altre reti (collegamenti 
\bar under
esterni
\bar default
).
\end_layout

\begin_layout Standard
La matrice di traffico è la matrice tra i 
\begin_inset Formula $N\cdot\left(N-1\right)$
\end_inset

 collegamenti esterni.
\end_layout

\begin_layout Itemize
Abbiamo 
\begin_inset Formula $N^{2}$
\end_inset

 variabili!
\end_layout

\begin_layout Itemize
Dobbiamo tenere conto anche delle variazioni orarie o speifiche per applicazoni.
 Ad esempio al mattino il traffico è generato dagli uffici, la sera dalle
 abitazioni.
 Queste cose vanno considerate.
\end_layout

\begin_layout Standard
Solitamente i router semplici implementano dei contatori per ogni interfaccia.
\end_layout

\begin_layout Itemize
Viene contato il numero di pacchetti e bytes in ingresso e in uscita da
 ogni link.
\end_layout

\begin_layout Itemize
Ci sono 
\begin_inset Formula $N$
\end_inset

 coefficienti.
 Con 
\begin_inset Formula $N$
\end_inset

 equazioni e 
\begin_inset Formula $N^{2}$
\end_inset

 variabili il sistema non è determinato.
\end_layout

\begin_layout Itemize
Teniamo conto che potremmo aver bisogno di più contatori per ogni interfaccia.
 Ad esempio potremmo essere interessati a conteggiare in base al prefisso
 IP.
\end_layout

\begin_layout Subsection*
Il problema del conteggio
\end_layout

\begin_layout Standard
La parte fondamentale della misurazione è il couting di pacchetti/bytes.
 Dobbiamo tenere conto di varie cose:
\end_layout

\begin_layout Itemize
Possono servirci 
\series bold
molti
\series default
 contatori, anche alcuni milioni!
\end_layout

\begin_layout Itemize
Può succedere che lo stesso pacchetto debba aggiornare più contatori
\end_layout

\begin_layout Itemize
Abbiamo a che fare con alte velocità
\end_layout

\begin_layout Itemize
Dobbiamo utilizzare contatori che non vadano in overflow (solitamente 64
 bit è una buona scelta per non preoccuparsi troppo).
\end_layout

\begin_layout Standard
Vediamo un esempio:
\end_layout

\begin_layout Itemize
1 Milione di contatori a 64 bit significa 64Mbits di memoria!
\end_layout

\begin_layout Itemize
Dobbiamo aggiornare due contatori ogni 
\begin_inset Formula $8ns$
\end_inset

 , cioè abbiamo un throughput di 
\begin_inset Formula $16\,\frac{Gbit}{s}$
\end_inset


\end_layout

\begin_layout Itemize
L'alta velocità richiede memorie veloci tipo SRAM (che costano!) le DRAM
 sono troppo lente.
\end_layout

\begin_layout Subsection*
Risolvere il problema del conteggio
\end_layout

\begin_layout Standard
Qualcuno potrebbe pensare di tenere in una cache i contatori che sono stati
 aggiornati recentemente.
 Questa strategia non può essere adottata perché le intestazioni dei pacchetti
 presentano una località non adatta al funzionamento della cache.
\end_layout

\begin_layout Standard
Una strategia di soluzione consiste nel tenere in cache i bit meno significativi
 di ogni contatore.
 Ad esempio possiamo tenere in una cache una quantità più piccola di bit
 del contatore.
\end_layout

\begin_layout Standard
Ovviamente questo andrà in overflow molto più spesso, quindi devo periodicamente
 scegliere un contatore (quello che andrà in overflow a breve) e in qualche
 modo farne il 
\begin_inset Quotes eld
\end_inset

backup
\begin_inset Quotes erd
\end_inset

 nel contatore lungo.
 Dobbiamo fare il backup del contatore prima che vada in overflow ovviamente.
 Quindi 
\series bold
contatore corto nella memoria veloce, contatore lungo nella memoria DRAM
 classica
\series default
.
\end_layout

\begin_layout Subsection*
Largest Count First Algorithm (LCF)
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename lcf.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
È forse la soluzione migliore.
 Se la memoria veloce è 
\begin_inset Formula $b$
\end_inset

 volte più veloce di quella lenta, possiamo spostare un contatore ogni 
\begin_inset Formula $b$
\end_inset

 pacchetti.
\end_layout

\begin_layout Standard
Quale contatore spostiamo? Idealmente quello con il più grande numero (per
 questo l'algoritmo si chiama 
\emph on

\begin_inset Quotes eld
\end_inset

Largest Count First
\emph default

\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
Il numero di bit da tenere nella SRAM è approssimativamente: 
\begin_inset Formula 
\[
c\approx log\,\left(log\,\left(b\cdot N\right)\right)
\]

\end_inset


\end_layout

\begin_layout Standard
L'implementazione dell'algoritmo può essere problematica.
 Trovare il numero più grande richiede tempo e memoria!
\end_layout

\begin_layout Standard
Possiamo 
\series bold
semplificare
\series default
 l'algoritmo:
\end_layout

\begin_layout Itemize
\begin_inset Formula $cj\,=\,\text{il più grande contatore aggiornato nell'ultimo ciclo di b accessi}$
\end_inset


\end_layout

\begin_layout Itemize
Se 
\begin_inset Formula $cj\,\geq b$
\end_inset

 aggiorno 
\begin_inset Formula $cj$
\end_inset


\end_layout

\begin_layout Itemize
Altrimenti aggiorno ogni altro contatore con valore almeno 
\begin_inset Formula $b$
\end_inset

 
\end_layout

\begin_layout Subsection*
Randomized Couting
\end_layout

\begin_layout Standard
Si riuncia alla accuratezza in cambio di efficienza.
\end_layout

\begin_layout Itemize
Quando arriva un pacchetto, incremento un contatore con probabilità 
\begin_inset Formula $\frac{1}{c}$
\end_inset

.
\end_layout

\begin_layout Itemize
Se il contatore ha valore 
\begin_inset Formula $x$
\end_inset

 , il numero atteso di pacchetti contati è 
\begin_inset Formula $xc$
\end_inset

 .
\end_layout

\begin_layout Itemize
Il problema è che essendo probabilistico la misura non è esatto.
 In realtà non ci preoccupiamo molto, basta che sappiamo quando è l'errore
 però!
\end_layout

\begin_layout Itemize
La deviazione standard dell'errore è di 
\series bold
qualche 
\begin_inset Formula $c$
\end_inset

 .
\end_layout

\begin_deeper
\begin_layout Itemize
Quindi se 
\begin_inset Formula $x\gg c$
\end_inset

 la precisione è alta
\end_layout

\begin_layout Itemize
Quando 
\begin_inset Formula $x\sim c$
\end_inset

 l'errore è abbastanza grosso, quindi sono numeri inutili.
\end_layout

\end_deeper
\begin_layout Standard
Questo metodo funziona quando contiamo flussi che sembrano essere rilevanti.
\end_layout

\begin_layout Standard
La misura di metodi rari con questo metodo è inaccurato.
\end_layout

\begin_layout Subsection*
Threshold Aggregation
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename threshold_aggregation.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
L'idea è di tenere 
\series bold
solo
\series default
 i contatori che 
\series bold
superano una certa soglia
\series default
.
 Questa è una strada per ridurre il numero di contatori che uso.
 Ovviamente io potrei tenere tutti i contatori e a posteriori guardare quelli
 che corrono velocemente e poi tenere solo quelli.
 Però questo non ci serve, il nostro scopo è ridurre il numero di contatori!
\end_layout

\begin_layout Quotation

\emph on
\begin_inset Quotes eld
\end_inset

How to detect the elephants? (cit.)
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Partiamo dal calcolare l'identificativo del flusso del pacchetto.
 Il flusso è qualcosa la cui definizione dipende un po' dalle nostre esigenze.
 Per identificare il flusso usiamo un hash.
 
\end_layout

\begin_layout Standard
Ad esempio in TCP facciamo un hash della tupla che definisce i dati della
 connessione.
 Aggiungiamo il pacchetto al contatore associato a quell'hash.
 Se il contatore è sopra una certa soglia, traccia il flusso
\end_layout

\begin_layout Standard
Ci sono due tipi di falsi positivi:
\end_layout

\begin_layout Itemize
Un flusso piccolo che genera pochi pacchetti, a causa delle collisioni nell'hash
, finisce nel contatore per il flusso grosso.
\end_layout

\begin_layout Itemize
Tanti flussi piccoli per caso si mappano sullo stesso contatore e lo fanno
 correre, però sono tutti flussi individualmente piccoli, uniti solo a causa
 dell'hash.
\end_layout

\begin_layout Standard
Soluzione:
\end_layout

\begin_layout Itemize
Utilizziamo funzioni di hash multiple e indipendenti.
\end_layout

\begin_deeper
\begin_layout Itemize
I falsi positivi sono ridotti (ma non eliminati putroppo)
\end_layout

\end_deeper
\begin_layout Subsubsection*
Esempio applicativo:
\end_layout

\begin_layout Standard
Input
\end_layout

\begin_layout Itemize
Abbiamo un link con velocità 
\begin_inset Formula $v\,=\,100\,\frac{Mbit}{s}$
\end_inset


\end_layout

\begin_layout Itemize
Abbiamo 
\begin_inset Formula $N=10^{5}$
\end_inset

 flussi
\end_layout

\begin_layout Itemize
L'intervallo di misurazione è 
\begin_inset Formula $T=1s$
\end_inset


\end_layout

\begin_layout Standard
Output
\end_layout

\begin_layout Itemize
I flussi sopra l'
\begin_inset Formula $1\%$
\end_inset

 della capacità del link durante 
\begin_inset Formula $T$
\end_inset


\end_layout

\begin_layout Standard
Scelte di design
\end_layout

\begin_layout Itemize
Ogni stadio ha 
\begin_inset Formula $1000$
\end_inset

 buckets
\end_layout

\begin_layout Itemize
La soglia è 
\begin_inset Formula $1\,\frac{Mbit}{s}$
\end_inset


\end_layout

\begin_layout Itemize
4 stadi indipendenti
\end_layout

\begin_layout Standard
Calcoliamo la probabilità che un flusso da 
\begin_inset Formula $100\,\frac{kbit}{s}$
\end_inset

 sia sopra la soglia:
\end_layout

\begin_layout Itemize
Per ogni stadio il flusso è sopra la soglia se altri flussi nello stesso
 contatore si aggiungono fino a 
\begin_inset Formula $900\,\frac{kbit}{s}$
\end_inset


\end_layout

\begin_layout Itemize
Il caso pessimo è quando tutto il traffico tra altri flussi si divide in
 
\begin_inset Formula $x=\frac{99999\,\text{flussi}}{900\,\frac{kbit}{s}}=111\,\text{buckets}$
\end_inset


\end_layout

\begin_layout Itemize
La probabilità di falsi positivi è almeno 
\begin_inset Formula $11,1\%$
\end_inset

 ad ogni stadio.
\end_layout

\begin_layout Itemize
Con 4 stadi la probabilità di un laso positivo è almeno 0.016%
\end_layout

\begin_layout Section*
Flow counting 
\end_layout

\begin_layout Standard
Invece di contare pacchetti, contiamo il numero di distinti flussi che matchano
 un certo pattern che genera traffico sopra una certa soglia.
\end_layout

\begin_layout Standard
Ad esempio questo è utile per l'
\series bold
identificazione di attacchi
\series default
, identificazione di applicazioni che consumano tanta banda.
\end_layout

\begin_layout Standard
Il metodo più semplice per contare i flussi distinti è una hashtable che
 contiene tutte le coppie sorgente-destinazione.
\end_layout

\begin_layout Standard
Il modo classico per affrontare questo problema è quello di scambiare accuratezz
a e 
\series bold
memoria
\series default
.
\end_layout

\begin_layout Standard
L'idea è di cercare pattern che si presentano con bassa probabilità.
\end_layout

\begin_layout Subsection*
Probabilistic couting
\end_layout

\begin_layout Standard
L'idea base è cercare per pattern non comuni nei flow IDs.
 Se il pattern non comune viene trovato, ci sono molti flussi.
\end_layout

\begin_layout Standard
Per implementarlo:
\end_layout

\begin_layout Itemize
Facciamo l'hash del flow ID
\end_layout

\begin_layout Itemize
Contiamo il numero di zeri consecutivi partendo dal bit meno significativo
\end_layout

\begin_layout Itemize
\begin_inset Formula $x$
\end_inset

 è il massimo numero osservato di zeri consecutivi
\end_layout

\begin_layout Itemize
La stima per il numero di flussi è 
\begin_inset Formula $2^{x}$
\end_inset


\end_layout

\begin_layout Standard
Risultati migliori si ottengono con un array di funzioni di hash indipendenti.
\end_layout

\begin_layout Standard
I risultati più accurati si ottengono se questa operazione viene ripetuata
 tante volte e poi si fa la media della variabile 
\begin_inset Formula $x$
\end_inset

 , questo ha un effetto di attenuare molto l'errore.
\end_layout

\begin_layout Subsection*
IPFIX
\end_layout

\begin_layout Standard
Un'altra strategia è quella legata allo standard IETF 
\series bold
ipfix
\series default
 (prima chiamato 
\emph on
Cisco Netflow
\emph default
) che fornisce funzionalità di conteggio per-flusso:
\end_layout

\begin_layout Itemize
Un flusso è definito come una connessione TCP o un dialogo UDP.
\end_layout

\begin_layout Itemize
I dati ricevuti possono essere aggregati per prefisso, per numero di porta,
 per destinazione.
\end_layout

\begin_layout Itemize
I dati raccolti sono inviati ad una workstation che funge da ruolo di manager.
\end_layout

\begin_layout Standard
Abbiamo due problemi:
\end_layout

\begin_layout Itemize
Overhead della misura
\end_layout

\begin_deeper
\begin_layout Itemize
La misurazione aumenta il carico di lavoro sul router (di parecchio!)
\end_layout

\end_deeper
\begin_layout Itemize
Overhead di raccolta a reporting
\end_layout

\begin_deeper
\begin_layout Itemize
La stessa operazione di reporting delle misure incrementa il consumo di
 banda e il carico di lavoro per le workstations di management.
\end_layout

\end_deeper
\begin_layout Standard
La strada più usata per ridurre il carico sulla CPU è quella del 
\series bold
\emph on
packet sampling
\series default
\emph default
 , cioè conteggiare solo un pacchetto ogni 
\begin_inset Formula $N$
\end_inset

.
 Valori comuni sono da 
\begin_inset Formula $N=16$
\end_inset

 a 
\begin_inset Formula $N=1000$
\end_inset

.
\end_layout

\begin_layout Standard
Questo comporta però che possa succedere che interi flussi non siano neanche
 visti.
\end_layout

\begin_layout Standard
Quindi ha senso solo se le misure sono aggregate e su scale temporali 
\series bold
lunghe
\series default
, dove l'effetto di 
\begin_inset Quotes eld
\end_inset

media
\begin_inset Quotes erd
\end_inset

 conpensa l'errore che compio con un campionamento.
\end_layout

\begin_layout Standard
Il 
\series bold
\emph on
packet sampling
\series default
\emph default
 serve per mitigare il problema dell'overhead di misura.
\end_layout

\begin_layout Standard
Per il problema di reporting si riduce l'overhead riportando solo quei flussi
 il cui volume di traffico supera una certa soglia, questo è chiamato 
\series bold
\emph on
sampled charging 
\series default
\emph default
.
 L'algoritmo è abbastanza semplice: inviamo un rapporto al manager per un
 flusso di lunghezza 
\begin_inset Formula $s$
\end_inset

 se 
\begin_inset Formula $s$
\end_inset

 supera una certa soglia o con una probabilità proporzionale ad 
\begin_inset Formula $s$
\end_inset

 se 
\begin_inset Formula $s$
\end_inset

 è sotto la soglia.
\end_layout

\begin_layout Standard
Il problema è che ho tanti flussi piccoli e una soglia alta, non mi viene
 risportato niente.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ipfix.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
L'idea è che dei flussi sotto soglia ne scelgo a caso (con una probabilità
 proporzionale alla grandezza del flusso) e lo riporto.
\end_layout

\begin_layout Subsection*
Trajectory Sampling
\end_layout

\begin_layout Standard
Tutto quello che abbiamo detto fino ad ora è relativo a misure locali, a
 conteggi di flussi che transitano da un singolo nodo.
 Tutto il discorso partiva dal fatto che per fare una matrice di traffico
 avevo bisgono di tanti contatori presi agli ingressi della rete.
\end_layout

\begin_layout Standard
Questo approccio ha il difetto di dirmi cosa succede tra l'ingresso e l'uscita
 della rete ma non mi dice cosa succede dentro la rete.
\end_layout

\begin_layout Standard
Il punto cardine è: mi piacerebbe avere delle misure prese all'interno dei
 vari nodi della rete che mi permettano di ricostruire il percorso che i
 pacchetti fanno nella rete.
 Stiamo parlando di misure passive (ovviamente possiamo fare anche misure
 attive inviando pacchetti e vedendo che strada fanno, come ad esempio il
 
\emph on
traceroute
\emph default
).
\end_layout

\begin_layout Standard
Il fatto i che nodi misurano solo qualche pacchetto.
 Voglio però sposarlo sapendo il percorso seguito dai pacchetti.
\end_layout

\begin_layout Standard
Sono in grado di fare il modo che il generico pacchetto sia campionato da
 tutti o ignorato da tutti? Sì, sono in grado di farlo e seguire il percorso
 che il pacchetto fa nella rete.
 Il punto chiave è che invece di fare scelte casuali io farò delle scelte
 sull'output di funzioni pseudo-casuali.
\end_layout

\begin_layout Standard
Possiamo far finta che la funzione hash associ un numero a caso al suo input.
 
\end_layout

\begin_layout Standard
La prima cosa da fare è capire come faccio a prendere una decisione su un
 pacchetto che si muove nella rete.
 Prima di tutto devo trovare un set di campi immutabili
\bar under
 (Non esiste un set predefinito di campi immutabili)
\bar default
.
\end_layout

\begin_layout Standard
In particolare il campo TTL cambia nel tempo, quindi non lo devo considerare.
 Gli indirizzi MAC non possono essere usati.
\end_layout

\begin_layout Standard
Quindi per prima cosa devo selezionare dei campi che siano immutabili, ad
 esempio gli indirizzi IP (non consideriamo il NAT).
 Ignoriamo il caso dei pacchetti frammentati (che sono comunque rarissimi).
\end_layout

\begin_layout Standard
Dobbiamo pescare una stringa di 
\begin_inset Formula $m$
\end_inset

 bit pescando tra i vari campi che 
\series bold
non cambiano
\series default
 all'interno del pacchetto.
\end_layout

\begin_layout Standard
Questa stringa di bit di grandezza arbitraria la diamo in pasto ad una funzione
 hash deterministica uguale in tutti i router.
 Essendo deterministica 
\begin_inset Formula $0<h\left(m\right)<R$
\end_inset

 .
 Dove 
\begin_inset Formula $R$
\end_inset

 è la cardinalità del codominio della funzione hash.
\end_layout

\begin_layout Standard
Scegliamo una soglia 
\begin_inset Formula $B$
\end_inset

 che controllerà la frazione di pacchetti che sono campionati.
 
\end_layout

\begin_layout Standard
Se 
\begin_inset Formula $h\left(m\right)<B$
\end_inset

 il pacchetto è conteggiato.
 Questa non è una scelta casuale ma deterministica: tutti i router.
\end_layout

\begin_layout Standard
Un dato pacchetto è conteggiato in tutti i router con una probabilità 
\begin_inset Formula $\frac{B}{R}$
\end_inset

.
 Se il pacchetto è accettato, manteniamo la sua etichetta 
\begin_inset Formula $g\left(m\right)$
\end_inset

 nei log.
\end_layout

\begin_layout Standard
Nota: devo scegliere una funzione hash 
\begin_inset Formula $g$
\end_inset

 indipendente che mi da in output una etichetta che userò per identificare
 il apcchetto nel suo percorso.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename tajectory.png
	scale 40

\end_inset


\end_layout

\begin_layout Section*
Network-layer Intrusion Detection
\end_layout

\begin_layout Standard
Vediamo l'uso di varie tecniche per identificare la presenza di 
\begin_inset Quotes eld
\end_inset

intrusioni
\begin_inset Quotes erd
\end_inset

 (pacchetti non conformi alle policy della rete dove sono stati trovati).
\end_layout

\begin_layout Standard
Di solito si tende a fare la 
\begin_inset Quotes eld
\end_inset

detection
\begin_inset Quotes erd
\end_inset

, cioè riportarne l'avviso a livello amministrativo.
\end_layout

\begin_layout Standard
In altri casi si effettuano anche delle operazioni automatiche.
\end_layout

\begin_layout Standard
Dobbiamo però fare attenzione perché entriami in un mondo dove i falsi positivi
 sono tutt'altro che rari.
\end_layout

\begin_layout Standard
In generare un 
\series bold
Intrusion Detection System (IDS)
\series default
 è un sistema che monitora un sistema per attività effettuate da malintenzionati
 o da violazioni di policy.
\end_layout

\begin_layout Subsection*

\series bold
Network Intrusion Detection System (NIDS)
\end_layout

\begin_layout Standard
Ciò su cui esercitano la loro azione sono i pacchetti catturati durante
 il viaggio.
\end_layout

\begin_layout Itemize
È un dispositivo che cattura e analizza il traffico nelle posizioni critiche
 di una rete
\end_layout

\begin_layout Itemize
Solitamente effettuano 
\series bold
\emph on
\bar under
Deep Packet Inspection 
\emph default
(DPI
\bar default
)
\series default
, cioè guardano fino nel payload.
\end_layout

\begin_layout Subsection*
Host Intrusion Detection System (HIDS)
\end_layout

\begin_layout Standard
È un agente su un host che controlla il traffico in ingresso, i log, le
 chiamate di sistema, i files aperti etc...
\end_layout

\begin_layout Subsection*

\series bold
Intrusion Detection and Prevention System (IDPS)
\end_layout

\begin_layout Standard
Ha la differenza di poter anche reagire agli allarmi eseguendo delle operazioni.
\end_layout

\begin_layout Subsection*
Sistemi basati sulla signature detection
\end_layout

\begin_layout Standard
È il tipo di IDS più comune.
 Sono dei sistemi dotati di database di tipi di attacchi noti.
 Cercano i pattern descritti nel database all'interno dei pacchetti che
 passano nella rete.
\end_layout

\begin_layout Itemize
Il limite di questi sistemi è che agiscono solo su attacchi noti
\end_layout

\begin_layout Itemize
Il sistema è utile solo se il database è aggiornato
\end_layout

\begin_layout Itemize
Possono esserci una serie di 
\series bold
falsi allarmi
\series default
 a seconda della qualità delle regole 
\end_layout

\begin_layout Subsection*
Sistemi basati sulla anomaly detection
\end_layout

\begin_layout Standard
Sono sistemi che vengono lasciati funzionare in un contesto dove è presente
 solo traffico corretto.
 Poi in base a condizioni statistiche si stabilisce qual'è la 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
baseline condition
\series default
\emph default

\begin_inset Quotes erd
\end_inset

.
 Finita la fase di 
\begin_inset Quotes eld
\end_inset

addestramento
\begin_inset Quotes erd
\end_inset

, l'IDS segnala possibili attacchi.
\end_layout

\begin_layout Standard
Un esempio di questo è il numero di connessioni su un host per unità di
 tempo.
 Un IDS potrebbe rivelare anomalo un aumento improvviso del numero di connession
i.
\end_layout

\begin_layout Itemize
Può potenzialmente rilevare attacchi di tipo 
\emph on
0-day
\end_layout

\begin_layout Itemize
Purtroppo segnalano molto spesso 
\series bold
falsi allarmi
\series default
 (più dei sistemi si 
\emph on
signature detection
\emph default
).
\end_layout

\begin_layout Standard
Spesso si associa un sistema di 
\emph on
anomaly detection 
\emph default
con un sistema di 
\emph on
signature detection
\emph default
.
\end_layout

\begin_layout Subsection*
IDS vs.
 Firewall
\end_layout

\begin_layout Standard
Quali sono le differenze?
\end_layout

\begin_layout Itemize
La prima differenza è che gli IDS sono lenti e i firewall sono (e devono
 essere) veloci.
\end_layout

\begin_deeper
\begin_layout Itemize
Il primo motivo è che gli IDS devono fare 
\emph on
deep packet inspection
\emph default
.
\end_layout

\end_deeper
\begin_layout Itemize
L'IDS si occupa di segnalare degli allarmi.
 Il firewall invece di solito blocca i pacchetti.
 L'IDS di solito fa blacklisting (e non whitelisting come il firewall).
\end_layout

\begin_layout Itemize
Gli IDS tendono a formare delle code se hanno troppe regole.
 Per evitare di rallentare tutto il traffico, gli IDS vengono messi in 
\series bold
parallelo
\series default
 al traffico (non come i firewall che vengono messi in 
\begin_inset Quotes eld
\end_inset

serie
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_deeper
\begin_layout Itemize
Anche se l'IDS perde qualche pacchetto, la cosa non è rilevante.
 Meglio perdere un po'di traffico piuttosto di perdere prestazioni di 
\series bold
tutta
\series default
 la rete.
\end_layout

\end_deeper
\begin_layout Itemize
Gli IDS hanno un alto tasso di falsi positivi, a differenza dei firewall.
\end_layout

\begin_layout Itemize
I firewall sono efficaci solo per il traffico che transita dai bordi della
 rete, mentre gli IDS solitamente ascoltano tutto il traffico 
\series bold
dentro
\series default
 alla rete, non sono a quello che ci entra.
\end_layout

\begin_layout Subsection*
Building blocks di un sistema NIDS
\end_layout

\begin_layout Itemize
È necessaria una fase di ispezione dei pacchetto il cui scopo è effettuare
 il matching della 
\emph on
signature.
\end_layout

\begin_layout Itemize
Un sistema più sofisticato può anche tentare una risposta.
 In questo caso dobbiamo capire qual'è la 
\series bold
sorgente dell'attacco
\series default
.
 
\end_layout

\begin_layout Itemize
Poi c'è il problema di capire quali sono i pacchetti relativi all'attacco.
 
\end_layout

\begin_deeper
\begin_layout Itemize
Possiamo utilizzare delle 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
honeynets
\series default
\emph default

\begin_inset Quotes erd
\end_inset

 (anche note come 
\begin_inset Quotes eld
\end_inset


\emph on
network telescopes
\emph default

\begin_inset Quotes erd
\end_inset

): delle reti finte dove non ci sono utenti e servizi per utenti esterni.
 Quindi tutto il traffico che entra lì, lo ha fatto tramite una ricerca
 automatizzata e quindi tutto il traffico all'interno è malicious.
\end_layout

\begin_layout Itemize
Per identificare i 
\emph on
worm
\emph default
 ci sono varie tecniche per analizzare le signatures.
\end_layout

\end_deeper
\begin_layout Subsection*
Fase di ispezione
\end_layout

\begin_layout Standard
È il blocco fondamentale negli NIDS di tipo 
\emph on
signature-based
\emph default
.
\end_layout

\begin_layout Standard
In questo caso parliamo di 
\begin_inset Quotes eld
\end_inset

pacchetto
\begin_inset Quotes erd
\end_inset

 in senso lato, può succedere che a livello 7 delle applicazioni utilizzino
 stringhe molto lunghe spezzate in più pacchetti.
\end_layout

\begin_layout Standard
Quindi è necessario ricostruire e elaborare gli stream applicativi.
\end_layout

\begin_layout Standard
Di solito viene fatta anche una prima decodifica degli stream.
 Questo perché molti protocolli prevedono delle tecniche di codifica o compressi
one che possono essere utilizzate per 
\begin_inset Quotes eld
\end_inset

nascondere
\begin_inset Quotes erd
\end_inset

 delle stringhe che potrebbero essere rilevate dall'IDS.
 Ad esempio se filtriamo su HTTP certi pattern, qualcuno potrebbe inviarla
 codificata con 
\emph on
%codiceascii
\emph default
.
\end_layout

\begin_layout Standard
Quindi a questo punto ogni pacchetto viene confrontato con un set di signatures.
 Il database delle signatures può essere più o meno grande.
 Ci sono database anche da diverse migliaia di regole.
 Il pacchetto deve essere confrontato con tutte le signatures.
\end_layout

\begin_layout Standard
Ci sono due grossi insiemi di regole:
\end_layout

\begin_layout Itemize
Regole 
\begin_inset Quotes eld
\end_inset


\series bold
standard
\series default

\begin_inset Quotes erd
\end_inset

 a livello 3 e 4 (che si sovrappongono un po' a quello che fanno i firewall).
\end_layout

\begin_deeper
\begin_layout Itemize
Ad esempio ci sono i 
\series bold
bogons
\series default
.
 A volte qualcuno invia pacchetti IP utilizzando come sorgente degli indirizzi
 non assegnati.
 Fare delle regole nei firewall per questi indirizzi di 
\emph on
bogons
\emph default
 è abbastanza pesante e inutile, però può aver senso in un IDS.
\end_layout

\end_deeper
\begin_layout Itemize
Matching di 
\series bold
stringhe
\series default
 a livello 7.
 Ovviamente bisogna fare dei controlli a livello 3 e 4 prima.
 È inutile filtrare stringhe per server web se la destinazione non è un
 server web!
\end_layout

\begin_layout Standard
Uno dei software più famosi per realizzare un IDS è 
\series bold
SNORT:
\end_layout

\begin_layout Itemize
Si catturano i pacchetti utilizzando le librerie pcap (con wireshark o tcpdump).
 Nel caso standard si copia tutto, però si possono utilizzare regole BPF.
\end_layout

\begin_layout Itemize
Per ogni pacchetto che arriva si può lavorare a livello 3 oppure i preprocessori
 per ricostruire i pacchetti applicativi.
 
\end_layout

\begin_layout Itemize
Il motore di snort è opensource e c'è una compagnia (
\emph on
SourceFire
\emph default
) che vende signatures più aggiornate.
\end_layout

\begin_layout Standard
Vediamo un esempio di regola:
\end_layout

\begin_layout LyX-Code

\size footnotesize
alert tcp any any -> 192.168.1.0/24 80 (content: 
\begin_inset Quotes eld
\end_inset

cgi-bin/phf
\begin_inset Quotes erd
\end_inset

; offset: 3; depth: 22; msg: 
\begin_inset Quotes eld
\end_inset

CGI-PHF attack
\begin_inset Quotes erd
\end_inset

;)
\end_layout

\begin_layout Itemize
La regola è composta da una intestazione e da delle opzioni.
\end_layout

\begin_layout Itemize
Nell'intestazione abbiamo l'azione che viene compiuta quando il test sulla
 regola viene verificato.
 In questo esempio viene eseguita una allerta.
\end_layout

\begin_layout Itemize
Poi possiamo specificare il tipo di protocollo (tcp, udp,...), le porte, la
 direzione del pacchetto, la destinazione (espressa in qusto caso come un
 blocco di indirizzi) e la porta della destinazione.
\end_layout

\begin_layout Itemize
Quindi la regola viene applicata solo se prima di tutto è tcp e va al webserver
 di un certo blocco di ip.
\end_layout

\begin_layout Itemize
Content specifica che vogliamo cercare una certa stringa nel payload (operazione
 
\series bold
DPI
\series default
 a livello 7).
\end_layout

\begin_layout Itemize
Siccome fare una ricerca di stringa in un intero payload 
\series bold
\bar under
è una operazione onerosa
\series default
\bar default
, la cosa migliore da fare è mettere dei vincoli di modo da limitare il
 lavoro.
 In questo caso viene detto che la stringa non può iniziare prima della
 terza posizione e non può trovarsi dopo la 22° posizione.
 (22 perché suppongo che la lunghezza del server name non sia più lungo
 di un certo valore).
\end_layout

\begin_deeper
\begin_layout Itemize
Sono possibili più tipi di regole.
 C'è la possibilità di utilizzare espressioni regolari.
\end_layout

\begin_layout Itemize
Ovviamente le espressioni regolari possono richiedere una quantità di lavoro
 molto più grande, quindi si può lasciarle per solo specifiche macchine
 (facendo un filtraggio prima a livello 3 magari).
\end_layout

\end_deeper
\begin_layout Itemize
È possibile fare anche una regola che attiva altre regole e quindi rendere
 l'IDS 
\series bold
state dependent
\series default
.
\end_layout

\begin_layout Subsection*
Regole di SNORT
\end_layout

\begin_layout Standard
Le regole sono solitamente scritte su una singola riga, ma possono essere
 scritte su più righe utilizzando 
\begin_inset Quotes eld
\end_inset


\backslash

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize

\emph on
alert
\emph default
 : Generare un allarme e loggare il pacchetto.
\end_layout

\begin_layout Itemize

\emph on
log
\emph default
 : Loggare il pacchetto.
\end_layout

\begin_layout Itemize

\emph on
pass
\emph default
 : Ignorare il pacchetto.
\end_layout

\begin_layout Itemize

\emph on
drop : 
\emph default
Blocco e loggo il pacchetto.
\end_layout

\begin_layout Itemize

\emph on
reject
\emph default
 : Blocco, loggo e invio un TCP reset o ICMP unreachable.
\end_layout

\begin_layout Itemize

\emph on
sdrop
\emph default
 : Blocco ma non loggo.
\end_layout

\begin_layout Standard
Riguardo all'intestazione il protocollo può essere: 
\emph on
ip, icmp, tcp, udp
\end_layout

\begin_layout Standard
Gli indirizzi IP possono essere:
\end_layout

\begin_layout Itemize

\emph on
any
\end_layout

\begin_layout Itemize
Un inidirizzo ip in notazione decimale puntata
\end_layout

\begin_layout Itemize
Un range CIDR
\end_layout

\begin_layout Itemize
Una lista di indirizzi IP separati da virgola e contenuti in parentesi quadre
 
\end_layout

\begin_layout Itemize
Possiamo utilizzare il punto esclamativo per matchare tutto tranne quelli
 listati
\end_layout

\begin_layout Standard
I numeri di porta possono essere:
\end_layout

\begin_layout Itemize

\emph on
any
\end_layout

\begin_layout Itemize

\emph on
un singolo indirizzo di porta
\end_layout

\begin_layout Itemize

\emph on
un intervalli di numeri di porta
\end_layout

\begin_layout Itemize
Intervalli aperti tipo 
\begin_inset Quotes eld
\end_inset

500:
\begin_inset Quotes erd
\end_inset

, cioè 
\begin_inset Quotes eld
\end_inset

dalla porta 500 in su
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
La direzione può essere:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\emph on
->
\emph default

\begin_inset Quotes erd
\end_inset

 cioè da sinistra a destra
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\emph on
<>
\emph default

\begin_inset Quotes erd
\end_inset

 cioè bidirezionale
\end_layout

\begin_layout Standard
Per i tipi di opzione:
\end_layout

\begin_layout Itemize

\emph on
general : 
\emph default
Opzioni di tipo generale (per 
\emph on
documentare
\emph default
 la regola).
\end_layout

\begin_layout Itemize

\emph on
payload
\emph default
 : Specifica come guardare all'interno del payload del pacchetto.
\end_layout

\begin_layout Itemize

\emph on
non-payload
\emph default
 : Specifica di effettuare il match per campi addizionali dell'header.
\end_layout

\begin_layout Itemize

\emph on
post-detection : 
\emph default
Specifica cosa fare quando la regola è scattata.
\end_layout

\begin_layout Itemize

\emph on
msg
\emph default
 : Specifica il messaggio da scrivere nei log o nell'allarme.
 (Ad esempio 
\emph on
msg: 
\begin_inset Quotes eld
\end_inset

message text
\begin_inset Quotes erd
\end_inset


\emph default
;)
\end_layout

\begin_layout Itemize

\emph on
reference
\emph default
 : Specifica quali sono il database e l'ID di atacco da cui la regola è
 derivata.
 (Ad esempio 
\emph on
reference:bugtraw,1387;
\emph default
)
\end_layout

\begin_layout Itemize

\emph on
classtype 
\emph default
: Assegna la regola ad una categoria di attacco.
 Le categorie hanno una priorità di default.
 Le regole che appartengono ad una categoria possono essere attivate o disattiva
te in gruppo.
\end_layout

\begin_layout Itemize

\emph on
priority
\emph default
 : Assegna la priporità ad una regola (facendo override della priorità di
 default)
\end_layout

\begin_layout Itemize

\emph on
content 
\emph default
: Effettua una operazione di string matching sul contenuto del pacchetto.
 Se il testo fornito come argomento è presente, il test ha successo.
\end_layout

\begin_deeper
\begin_layout Itemize
La stringa può essere:
\end_layout

\begin_deeper
\begin_layout Itemize
Una sequenza di caratteri
\end_layout

\begin_layout Itemize
Dei dati binari racchiusi tra pipes (
\begin_inset Quotes eld
\end_inset

|
\begin_inset Quotes erd
\end_inset

) e rappresentati come numeri esadecimali.
\end_layout

\begin_layout Itemize
Un mix delle due cose
\end_layout

\end_deeper
\begin_layout Itemize
Il carattere 
\begin_inset Quotes eld
\end_inset

!
\begin_inset Quotes erd
\end_inset

 lancia la regola se il match fallisce
\end_layout

\begin_layout Itemize
Esempi:
\end_layout

\begin_deeper
\begin_layout LyX-Code
alert tcp any any -> any 80 (content:!
\begin_inset Quotes erd
\end_inset

GET
\begin_inset Quotes erd
\end_inset

;)
\end_layout

\end_deeper
\begin_layout Itemize
L'opzione 
\emph on
nocase
\emph default
 utilizzata su 
\emph on
content
\emph default
, specifica di ignorare se i caratteri sono maiuscoli o minuscoli
\end_layout

\begin_layout Itemize
L'opzione 
\emph on
depth
\emph default
 utilizzata su 
\emph on
content
\emph default
, specifica dove fermarsi per la ricerca della stringa
\end_layout

\begin_layout Itemize
L'opzione 
\emph on
offset
\emph default
 utilizzata su 
\emph on
content
\emph default
, specifica dove iniziare la ricerca della stringa
\end_layout

\begin_layout Itemize
Esempi:
\end_layout

\begin_deeper
\begin_layout LyX-Code
alert tcp any any -> any 80 (content:
\begin_inset Quotes eld
\end_inset

cgi-bin/phf
\begin_inset Quotes erd
\end_inset

; offset:4; depth:20;)
\end_layout

\begin_layout LyX-Code

\end_layout

\end_deeper
\begin_layout Itemize
Possiamo specificare più ricerche all'interno di un pacchetto.
 In questo caso risulta utilte specificare qual'è la distanza massima tra
 le stringhe che devo cercare.
\end_layout

\begin_layout Itemize
L'opzione 
\emph on
distance
\emph default
 specifica la distanza tra le stringhe su cui effettuare il matching
\end_layout

\begin_layout Itemize
L'opzione 
\emph on
within
\emph default
 specifica la massima distanza tra le stringhe
\end_layout

\begin_layout Itemize
Esempi:
\end_layout

\begin_deeper
\begin_layout LyX-Code
alert tcp any any -> any any (content:
\begin_inset Quotes erd
\end_inset

ABC
\begin_inset Quotes erd
\end_inset

; content:
\begin_inset Quotes erd
\end_inset

DEF
\begin_inset Quotes erd
\end_inset

; distance:1; within:10;)
\end_layout

\end_deeper
\begin_layout Itemize
L'opzione 
\emph on
isdataat
\emph default
 verifica che i dati siano alla posizione specificata
\end_layout

\begin_layout Itemize
Esempi:
\end_layout

\begin_deeper
\begin_layout LyX-Code
alert tcp any any -> any 111 (content:
\begin_inset Quotes erd
\end_inset

PASS
\begin_inset Quotes erd
\end_inset

; isdataat 50, relative; content:!
\begin_inset Quotes erd
\end_inset

|0a|
\begin_inset Quotes erd
\end_inset

; with:50;)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
L'opzione 
\emph on
ttl
\emph default
 effettua dei controlli sul Time-to-Live
\end_layout

\begin_layout Itemize
L'opzione 
\emph on
tos
\emph default
 effettua dei check sul campo ToS di IPv4
\end_layout

\begin_layout Itemize
L'opzione 
\emph on
dsize
\emph default
 controlla la dimensione del payload
\end_layout

\begin_layout Itemize
L'opzione 
\emph on
flags
\emph default
 controlla il valore dei TCP flags
\end_layout

\begin_layout Itemize
L'opzione 
\emph on
itype
\emph default
 controlla l'ICMP type
\end_layout

\begin_layout Itemize
L'opzione 
\emph on
icode
\emph default
 controlla l'ICMP code
\end_layout

\begin_layout Standard
Le regole attive possono essere utilizzate solo se l'IDS comunica con il
 firewall oppure è sullo stesso nodo del firewall.
\end_layout

\begin_layout Subsection*
Il problema della ricerca nelle stringhe
\end_layout

\begin_layout Standard
Ci sono due approcci per fare questa ricerca:
\end_layout

\begin_layout Itemize
Prendo il pacchetto, tiro fuori le regole che a livello 3/4 vanno bene per
 il pacchetto.
 Mi trovo con un set di regole (ammettiamo siano regole semplici i ricerca
 stringa).
 Come capisco se le regole vanno bene? La prima strada è che per ogni regola
 cerco la stringa nel pacchetto (con l'algoritmo 
\series bold
Boyer-Moore
\series default
)
\end_layout

\begin_layout Itemize
Una variante più furba è cercare di fare un integrated string matching in
 un passo solo per tutte le signatures.
 Questo è decisamente più efficiente.
 Il principale algoritmo che si utilizza in questo caso è 
\series bold
Aho-Corasick
\series default
.
\end_layout

\begin_layout Standard
Nel caso medio l'incremento di prestazioni è abbastanza trascurabile.
 Nel caso medio bastano pochi caratteri per capire se il pacchetto matcha
 o non matcha.
\end_layout

\begin_layout Standard
C'è invece un enorme vantaggio per i casi pessimi (che dobbiamo ricordarci!
 Un attaccante potrebbe inviare pacchetti che sfruttano appositamente i
 casi pessimi!).
\end_layout

\begin_layout Standard
Bisogna trovare un compromesso
\end_layout

\begin_layout Subsection*
Aho-Corasick Integrated String Matching
\end_layout

\begin_layout Standard
Cerca in una stringa per qualunque delle parole in un dizionario.
\end_layout

\begin_layout Standard
Se ci pensiamo non cambia molto dalla ricerca che facevamo nel prefix match
 con i trie.
 La differenza è la lungehzza variabile e la possibilit di avere dei 
\begin_inset Quotes eld
\end_inset


\emph on
failure pointers
\emph default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Quando un prefisso viene trovato ma i caratteri successivi non corrispondono:
\end_layout

\begin_layout Itemize
Un nuovo tentativo è fatto dalla posizione successiva
\end_layout

\begin_layout Itemize
Segue un 
\emph on
failure pointer
\end_layout

\begin_layout Standard
Quando il dizionari è noto, la struttura può essere pre-computata.
 La complessità è lineare nella lunghezza dell'input più il numero di parole
 chiave trovate.
\end_layout

\begin_layout Standard
Per risparmiare tempo è possibile fermarsi al primo match di parola.
 La complessità è lineare nella lunghezza dell'input.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename string_matching.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Rispondere agli attacchi
\end_layout

\begin_layout Standard
Uno dei problemi è cosa fare una volta che ho identificato l'intrusione.
 Può essere interessante isolare la sorgente dell'attacco per impostare
 delle regole in modo da bloccare futuri tentativi.
 Quindi il problema è identificare la sorgente dell'attacco.
\end_layout

\begin_layout Standard
Abbiamo attacchi:
\end_layout

\begin_layout Itemize
Attacchi da indirizzi singoli (facile)
\end_layout

\begin_layout Itemize
Attacchi da indirizzi spoofati.
 A questo punto il problema è capire qual'è la 
\series bold
vera
\series default
 sorgente.
\end_layout

\begin_layout Itemize
Attacchi distribuiti su una rete di host remoti (una botnet solitamente)
\end_layout

\begin_deeper
\begin_layout Itemize
In questo caso occorre identificare i membri di questa botnet e redirigere
 i membri della botnet dentro un 
\begin_inset Quotes eld
\end_inset


\emph on
blackhole
\emph default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Dato che non è facile identificare dagli IP, solitamente i 
\begin_inset Quotes eld
\end_inset

candidati
\begin_inset Quotes erd
\end_inset

 alla botnet vengono inviati a dei dispositivi chiamati 
\begin_inset Quotes eld
\end_inset


\emph on
scrubbers
\emph default

\begin_inset Quotes erd
\end_inset

 che analizzano meglio se gli indirizzi sono pericolosi.
 
\end_layout

\begin_deeper
\begin_layout Itemize
Qua viene spesso utilizzata la geolocalizzazione, ASN e deep packet inspection
\end_layout

\end_deeper
\end_deeper
\begin_layout Section*
Traceback IP
\end_layout

\begin_layout Standard
Supponiamo di aver trovato un pacchetto sospetto e vogliamo capire da dove
 è arrivato.
 Vogliamo evitare che pacchetti che si presentano con un indirizzo ip alterato
 vengano bloccati.
 Le tecniche che vediamo sono efficaci contro attacchi DoS (Denial of Service)
 e quindi con un solo attaccante.
\end_layout

\begin_layout Standard
Non possiamo semplicemente filtrare i pacchetti che hanno l'indirizzo filtrato
 o non veritierio? Non siamo in grado di distinguere un indirizzo legittimo
 da un indirizzo verificato.
 Quindi per prima cosa dobbiamo capire se l'indirizzo è corretto oppure
 no.
\end_layout

\begin_layout Standard
Nello standard RFC2827 si consiglia un filtraggio in ingresso alla rete.
 Il filtraggio in ingresso alla rete è possibile però solo se il punto d'ingress
o non è compromesso.
\end_layout

\begin_layout Standard
Una alternativa è la 
\emph on
Unicast Reverse Path Forwarding
\emph default
 : posso forwardare pacchetti solo se arrivano dalla stessa direzione da
 cui li avrei instradati se avessi dovuto raggiungere il mittente.
\end_layout

\begin_layout Standard
Questa soluzione soluzione funziona solo se il routing è 
\series bold
simmetrico
\series default
.
 In caso contrario questa tecnica non solo non serve, ma tende a scartare
 pacchetti legittimi.
\end_layout

\begin_layout Standard
Quella che vedremo come soluzione ottima è quella di tenere un 
\emph on
log
\emph default
 del percorso dei pacchetti e poi cercare in questi log i pacchetti che
 strada hanno fatto.
\end_layout

\begin_layout Subsection*
Ingress filtering
\end_layout

\begin_layout Standard
Definita in RFC 2827.
\end_layout

\begin_layout Standard
Tutti i router in ingresso dovrebbero rifiutare pacchetti provenienti da
 indirizzi non attesi dall'altra interfaccia.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename rfc2827.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Succede però che tutti i nodi di internet devono fidarsi a vicenda per far
 funzionare questo sistema.
\end_layout

\begin_layout Subsection*
uRPF Checks
\end_layout

\begin_layout Standard

\emph on
Unicast Reverse Path Forwarding
\end_layout

\begin_layout Standard
Il router sarà dotato di una tabella di routing che definisce dove recapitare
 i pacchetti.
\end_layout

\begin_layout Standard
Quando arriva un pacchetto, oltre a guardare dove deve andare guardo anche
 l'indirizzo sorgente e guardo qual'è l'interfaccia verso cui dovremmo mandare
 quel pacchetto se mi si presentasse da inviare.
 Se l'interfaccia è diversa da quella da cui l'ho ricevuto, lo scarto.
\end_layout

\begin_layout Standard
Il problema principale è che richiede 
\series bold
routing simmetrico: 
\series default
i pacchetti devono fare la stessa strada anche nella direzione opposta.
 Questa cosa è spesso errata nei 
\begin_inset Quotes eld
\end_inset

core
\begin_inset Quotes erd
\end_inset

 della rete.
 È abbastanza comune che ci siano più percorsi ed è perfettamente plausibile
 che i pacchetti passiano da collegamenti diversi.
\end_layout

\begin_layout Standard
È anche molto plausibile che per fare load-balacing delle linee alcuni pacchetti
 facciano un percorso diverso.
\end_layout

\begin_layout Standard
Dal punto di vista economico può succedere spesso che il routing sia dettato
 dai costi di transito sulle linee.
 Questo porta 
\series bold
molto spesso routing asimmetrico
\series default
.
\end_layout

\begin_layout Standard
Per abilitare su cisco si utilizza il comando:
\end_layout

\begin_layout LyX-Code
ip verify unicast reverse-path
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename rpfilter.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Per quanto riguarda invece il problema del routing asimmetrico:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename rpfilter2.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
IP Traceback via logging
\end_layout

\begin_layout Standard
Un'idea è quella di utilizzare dei log per le interfacce su cui ho ricevuto.
\end_layout

\begin_layout Itemize
Il pacchetto fa una certa strada per arrivare a destinazione
\end_layout

\begin_layout Itemize
Come facciamo a risalire alla strada che ha fatto? È necessario che 
\series bold
tutti
\series default
 i nodi tengano traccia del passaggio dei pacchetti.
\end_layout

\begin_layout Itemize
Il destinatario chiede a tutti i vicini se hanno visto arrivare il pacchetto
 e da dove l'hanno visto arrivare.
\end_layout

\begin_layout Itemize
Siamo in grado di spingerci il più vicino possibile al reale punto d'ingresso.
\end_layout

\begin_deeper
\begin_layout Itemize
La cosa più importante da fare è cercare di stringere il più possibile la
 mia conoscenza della provenienza dell'attaco di modo che posso concentrarmi
 su quello e mettere dei filtri lì
\end_layout

\end_deeper
\begin_layout Standard
Come faccio a gestire questo meccanismo in modo efficiente senza tenere
 tutti i pacchetti in un log.
\end_layout

\begin_layout Standard
A me non interessa il percorso che è stato fatto da un generico pacchetto.
 Mi interessa fare il traceback solo di un flusso continuo di grande intensità.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename rpfilter3.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Logging challanges
\end_layout

\begin_layout Itemize
Ricostruire il percorso, in generale è difficile.
\end_layout

\begin_layout Itemize
Tenere tutti i pacchetti nei log è impossibile e costituisce un significativo
 rischio per la privacy.
\end_layout

\begin_layout Standard
Qual'è la strada che possiamo seguire? Possiamo dire: non teniamo l'intero
 pacchetto perché è troppo grosso.
 Teniamo nei log un tag piccolo di pochi byte, che siano sufficienti per
 identificare univocamente il pacchetto se dovessi cercarlo.
\end_layout

\begin_layout Standard
Per calcolare l'hash devo identificare un 
\series bold
insieme di campi che non sono cambiati nel transito del pacchetto 
\series default
(ad esempio il payload, l'intestazione di livello 4, etc...).
 Scelto un hash di 28 byte ad esempio, la probabilità di due paccheti con
 lo stesso hash è 
\begin_inset Formula $0.00092\%$
\end_inset


\end_layout

\begin_layout Standard
Se pensiamo di avere problemi di collisione possiamo fare calcoli indipendenti.
\end_layout

\begin_layout Standard
Possiamo sfruttare tutti i campi dell'header ip
\bar under
 a parte
\bar default
:
\end_layout

\begin_layout Itemize
TOS
\end_layout

\begin_layout Itemize
TTL
\end_layout

\begin_layout Itemize
Checksum
\end_layout

\begin_layout Itemize
Opzioni
\end_layout

\begin_layout Standard
Supponiamo di aver identificato un insieme di byte su cui poi calcolare
 l'hash.
 Prendiamo una funzione 
\begin_inset Formula $h_{1}\left(x\right)$
\end_inset

 con probabilità di collisione molto bassa.
 La funzione 
\begin_inset Formula $h_{1}\left(x\right)$
\end_inset

 deve inoltre essere distribuita in modo uniforme tra ingresso e uscita
 cioè: 
\begin_inset Formula $h_{1}\left(x\right)=h_{1}\left(y\right)$
\end_inset

 per qualche 
\begin_inset Formula $x,y\rightarrow\text{inprobabile}$
\end_inset


\end_layout

\begin_layout Standard
Decidiamo di utilizzare 
\begin_inset Formula $k$
\end_inset

 funzioni di hash indipendenti in modo da avere: 
\begin_inset Formula $h_{1}\left(x\right)=h_{2}\left(y\right)$
\end_inset

 per qualche 
\begin_inset Formula $x,y\rightarrow\text{inprobabile}$
\end_inset


\end_layout

\begin_layout Standard
Inoltre cambiamo queste 
\begin_inset Formula $k$
\end_inset

 funzioni in modo indipendente nel tempo.
 Così se ci sono dei problemi, avvengono solo per poco tempo.
\end_layout

\begin_layout Subsection*
Bloom Filters 
\end_layout

\begin_layout Standard
Poi per costruire i log decidiamo di sfruttare un 
\series bold
filtro di Bloom
\series default
.
\end_layout

\begin_layout Standard
I filtri di Bloom sono delle strutture dati che permettono di fare il 
\series bold
test di presenza di un elemento in un insieme
\series default
.
 Questo è esattamente quello che serve a noi per cercare un hash nella lista
 di quelli passati in un nodo.
\end_layout

\begin_layout Standard
Sono strutture più efficienti perché hanno una possibilità di errore.
 Quindi possono rispondere che il pacchetto è passato anche se in realtà
 non è successo.
\end_layout

\begin_layout Standard
Più elementi metto nell'insieme, più c'è la probabilità di 
\series bold
falsi positivi
\series default
.
 Quindi periodicamente, come tutti i filtri, lo si svuota.
\end_layout

\begin_layout Standard
Nella sua versione più semplice è un array di 
\begin_inset Formula $m$
\end_inset

 bit (solitamente una potenza di 
\begin_inset Formula $2$
\end_inset

 cioè 
\begin_inset Formula $m=2^{b}$
\end_inset

).
\end_layout

\begin_layout Standard
Per inserire un elemento bisogna disporre 
\begin_inset Formula $k$
\end_inset

 funzioni di hash indipendenti, ciascuna di 
\begin_inset Formula $p$
\end_inset

 bit.
\end_layout

\begin_layout Standard
Ogni pacchetto viene dato in pasto alle 
\begin_inset Formula $k$
\end_inset

 funzioni di hash ed escono stringhe di 
\begin_inset Formula $p$
\end_inset

 bit che teoricamente sono casuali.
 In realtà tutto è deterministico.
\end_layout

\begin_layout Standard
Tuttavia, ad un osservatore esterno, queste stringhe di bit 
\series bold
sembreranno
\series default
 casuali.
\end_layout

\begin_layout Standard
Quindi avrò in uscita 
\begin_inset Formula $k$
\end_inset

 stringhe, ciascuna la interpreto come un indice dell'array lungo 
\begin_inset Formula $n$
\end_inset

 bit, e pongo a 1 il relativo bit.
 Se il bit è già a 1, rimane a 1.
 (Inizialmente il filtro è tutto di zeri)
\end_layout

\begin_layout Standard
Per capire se un elemento è nell'insieme: faccio 
\begin_inset Formula $k$
\end_inset

 hash e ottengo 
\begin_inset Formula $k$
\end_inset

 indici.
 Verifico se tutti questi 
\begin_inset Formula $k$
\end_inset

 indici sono posti ad 1.
 Se almeno uno di quelli è 0 so che non c'è quel pacchetto.
 Se l'array di bit non è mai stato cancellato la risposta è 
\series bold
sicuramente 
\series default
corretta.
 Invece se i bit sono tutti a 1 c'è la possibilità che due o più elementi
 diversi da quello che sto testando hanno nella loro intersezione messo
 a 1 tutti i 
\begin_inset Formula $k$
\end_inset

 bit che sono posti a 1 da quell'unico elemento.
\end_layout

\begin_layout Standard
Posso calcolare qual'è la probabilità di sbagliare.
 Se ci sono 
\begin_inset Formula $n$
\end_inset

 pacchetti nel filtro:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left(1-\left(1-\frac{1}{m}\right)^{kn}\right)^{k}\thickapprox\left(1-e^{\left(\frac{kn}{m}\right)}\right)^{k}
\]

\end_inset


\end_layout

\begin_layout Standard
Questa formula ci permette di dimensionare correttamente il filtro.
\end_layout

\begin_layout Standard
Fissato il mio obbiettivo di tasso di errore posso fissare i vari valori
 numerici.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename bloom.png
	scale 40

\end_inset


\end_layout

\begin_layout Section*
Attachi distribuiti: le 
\emph on
botnets
\end_layout

\begin_layout Standard
Un 
\begin_inset Quotes eld
\end_inset


\emph on
bot
\emph default

\begin_inset Quotes erd
\end_inset

 in informatica è un programma che svolge in automatico una serie di operazioni.
\end_layout

\begin_layout Standard
Una 
\begin_inset Quotes eld
\end_inset


\emph on
botnet
\emph default

\begin_inset Quotes erd
\end_inset

 è un insieme di bot solitamente sfruttati per scopi distruttivi all'interno
 di molte macchine connesse in rete.
 Solitamente i bot comunicano poi con un punto di comando centrale dove
 qualcuno li controlla.
\end_layout

\begin_layout Standard
Dalle ultime notizie le botnet più grandi che sono state scoperte avevano
 fino a 350000 nodi.
\end_layout

\begin_layout Standard
Una botnet viene solitamente realizzata combinando un worm con una funzionalità
 di backdoor per il suo controllo.
 Per diffondersi solitamente utilizzano la posta elettronica.
\end_layout

\begin_layout Standard
Chi si occupa di controllare la botnet solitamente utilizza dei server di
 chat IRC a cui fa collegare i vari bot per impartirgli comandi.
 Il server IRC è definito in base ad un indirizzo DNS controllato dal master
 della botnet.
\end_layout

\begin_layout Section*
Traffic Engineering con MPLS
\end_layout

\begin_layout Standard
Parleremo di uno strumento che viene utilizzato in tutte le reti che necessitano
 ingegneria del traffico avanzata, ed è il protocollo MPLS.
\end_layout

\begin_layout Standard
Abbiamo visto che per agire su una rete bisogna prima di tutto osservarla.
 Questo è il compito del traffic measurement.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\text{Conosci la tua rete}\rightarrow\text{misura il traffico della rete}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\text{Ottimizza la tua rete }\rightarrow\text{Ingegneria del traffico (TE)}
\]

\end_inset


\end_layout

\begin_layout Standard
Ci sono svariate tecniche che possono essere utilizzate a seconda del protocollo
 che c'è sulla rete e che vogliamo utilizzare:
\end_layout

\begin_layout Itemize
IP traffic engineering
\end_layout

\begin_layout Itemize
MPLS traffic engineering
\end_layout

\begin_layout Itemize
Altre nuove tecniche (ad esempio che sfruttano Ethernet)
\end_layout

\begin_layout Standard
Qual'è la differenza tra l'ingegneria del traffico a livello IP e a livello
 MPLS?
\end_layout

\begin_layout Subsection*
IP Traffic Engineering (IP-TE)
\end_layout

\begin_layout Standard
Data la matrice del traffico, scegliere i pesi da assegnare ai collegamenti.
 Il nostro obbiettivo è scegliere i valori ottimi da dare ai collegamenti.
 
\end_layout

\begin_layout Standard
L'ottimizzazione avvine in base a varie metiche: 
\end_layout

\begin_layout Itemize
minimizzare il ritardo
\end_layout

\begin_layout Itemize
massimizzare la banda libera
\end_layout

\begin_layout Itemize
...
\end_layout

\begin_layout Standard
Perché non possiamo spingerci oltre? Il routing in Internet è 
\emph on
topology-based
\emph default
, cioè dipende dalla struttura della rete, sia essa carica o scarica.
 Il routing 
\series bold
non dipende
\series default
 dall'occupazione dei link.
\end_layout

\begin_layout Standard
Inoltre è 
\series bold
destination-driven
\series default
: l'unica informazione di cui si tiene conto per il routing è la sua destinazion
e.
 Il fatto che il pacchetto arrivi da una certa sorgente o sia di un certo
 tipo di traffico, non ha alcun impatto.
 Ad esempio i pacchetti del p2p fanno la stessa strada di quelli della posta
 elettronica.
\end_layout

\begin_layout Standard
Come facciamo a superare queste limitazioni? L'unico modo è introdurre un
 nuovo strato protocollare tra IP e il livello sottostante e che permetta
 di instradare i pacchetti anche sulla base della occupazione dei collegamenti
 e in generale su politiche più estese.
\end_layout

\begin_layout Subsection*
MPLS Traffic Engineering
\end_layout

\begin_layout Standard
Abbiamo bisogno di un meccanismo in grado di prendere decisione ai bordi
 della rete, dove c'è più disponibilità di risorse di calcolo e dove la
 numerosità dei flussi non è elevata e consente quindi di fare classificazione.
 Spostiamo allora le decisioni di instradamento (dove il policy-based routing
 è difficile da applicare) verso i bordi della rete.
\end_layout

\begin_layout Standard
Potremo prendere delle decisioni in generale non più sulla destinazione
 ma anche sul 
\begin_inset Quotes eld
\end_inset


\series bold
flusso
\series default

\begin_inset Quotes erd
\end_inset

 del pacchetto.
\end_layout

\begin_layout Standard
Inolte nello scegliere l'instradamento possiamo tenere conto anche della
 
\series bold
situazione dei collegamenti
\series default
.
 Poiché l'instradamento viene fatto dove non c'è congestione (che è invece
 al centro della rete), possiamo tenere conto della situazione interna della
 rete e prendere delle decisioni per tentare di non congestionare ulteriormente.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename mpls.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
MPLS aggiunge una intestazione tra il livello 3 e il livello 2.
\end_layout

\begin_layout Standard
In alcuni casi (ad esempio reti a circuito virtuale tipo ATM) è possibile
 integrare parte di questo header già nel pacchetto di livello 2.
\end_layout

\begin_layout Standard
Nel caso il livello 2 sia di tipo datagramma si mette nel playload.
\end_layout

\begin_layout Standard
C'è uno 
\emph on
stack
\emph default
 di elementi all'interno dell'header MPLS:
\end_layout

\begin_layout Itemize
Una etichetta (
\series bold
\emph on
label
\series default
\emph default
) di 20 bit: Viene utilizzata per prendere una decisione sull'instradamento.
\end_layout

\begin_layout Itemize
3 bit 
\series bold
\emph on
EXP
\series default
\emph default
 (experimental) che ad oggi vengono utilizzate per distinguere le qualità
 di servizio.
\end_layout

\begin_layout Itemize
1 Bit (
\series bold
\emph on
S
\series default
\emph default
) viene utilizzato per identificare l'elemento più esterno dello stack,
 l'ultimo label.
\end_layout

\begin_layout Itemize
Un campo 
\series bold
\emph on
TTL
\series default
\emph default
 (Time To Live).
 Il motivo per cui c'è è che se c'è MPLS è vietato prendere decisioni in
 base al pacchetto IP.
 È vietato toccare le intestazioni più interne.
 Quindi è vietato anche modificare il campo TTL del pacchetto IP traportato
 da MPLS.
 Quando i pacchetti verranno tolti da MPLS si farà una sottrazione del TTL
 di MPLS dentro IP.
\end_layout

\begin_deeper
\begin_layout Itemize
Questo ha senso anche perché non è detto che ci sia solo IP dentro MPLS.
\end_layout

\end_deeper
\begin_layout Standard
Le etichette più interne vengono utilizzate per sfruttarle all'interno di
 altre reti.
 In ogni caso si prende sempre la riga con 
\begin_inset Formula $S=1$
\end_inset


\end_layout

\begin_layout Standard
Abbiamo visto che c'è una etichetta da 20 bit per prendere una decisione
 sull'instradamento.
\end_layout

\begin_layout Standard
Facciamo una exact-match classification su questa etichetta.
\end_layout

\begin_layout Subsubsection*
MPLS - 
\emph on
Multi Protocol Label Swtiching
\end_layout

\begin_layout Itemize
I router che stanno al bordo della rete (
\emph on
Label Edge Router, 
\series bold
LER
\series default
\emph default
) classificano il pacchetto (possono basarsi sulla destinazione o qualunque
 altra policy di filtraggio).
\end_layout

\begin_deeper
\begin_layout Itemize
Il router applica al pacchetto una etichetta di lunghezza fissa.
\end_layout

\end_deeper
\begin_layout Itemize
I router nel centro della rete (
\emph on
Label Swithcing Router, 
\series bold
LSR
\series default
\emph default
) ricevono il pacchetto MPLS
\end_layout

\begin_deeper
\begin_layout Itemize
Viene spostato il pacchetto 
\bar under
in base all'etichetta
\bar default
.
\end_layout

\end_deeper
\begin_layout Itemize
Un protocollo di routing modificato deve collezionare le informazioni sui
 link.
\end_layout

\begin_deeper
\begin_layout Itemize
Per distribuire ai nodi che prendono le decisioni le informazioni relative
 alla topologia della rete e alla occupazione interna delle risorse, è necessari
o un protocollo di routing, che oltre a propagare informazioni topologiche,
 propaghi anche informazioni sulla occupazione corrente dei nodi interni.
 Di questi algoritmi il più noto è una modifica di 
\emph on
OSPF 
\emph default
che ha dei campi aggiuntivi che propagano anche il carico dei collegamenti.
\end_layout

\end_deeper
\begin_layout Itemize
Un protocollo di segnalazione che:
\end_layout

\begin_deeper
\begin_layout Itemize
Riempie le tabelle di switching nei LSRs.
\end_layout

\begin_layout Itemize
Riserva la banda dei link.
\end_layout

\end_deeper
\begin_layout Subsubsection*
Switching in una rete MPLS
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename mpls2.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
Il 
\series bold
LER
\series default
 classifica i pacchetti che entrano della rete e li assegna ad una classe
 di equivalenza, una 
\emph on
Forwarding Equivalence Class
\emph default
 (
\series bold
FEC
\series default
)
\end_layout

\begin_layout Itemize
Il 
\series bold
LER
\series default
 avrà una tabella che assegna una etichetta ad ogni 
\series bold
FEC
\series default
 (imposizione dell'etichetta)
\end_layout

\begin_layout Itemize
Il 
\series bold
LSR
\series default
 classifica il pacchetto in arrivo in base alla clase di equivalenza.
 Ha il divieto di mandare su strade diverse pacchetti con la stessa etichetta
 (il percorso in un certo senso viene deciso dal LER).
 Il LSR può modificare poi l'etichetta (
\emph on
label switching
\emph default
).
\end_layout

\begin_layout Itemize
Gli altri LSR fanno la stessa cosa.
\end_layout

\begin_deeper
\begin_layout Itemize
NB: I protocolli di livello 2 possono cambiare tra un LSR e l'altro.
\end_layout

\end_deeper
\begin_layout Itemize
Il 
\series bold
LER
\series default
 alla fine della rete rimuove l'etichetta (
\emph on
label disposition
\emph default
) e instrada il pacchetto in base dalle regole di routing standard del pacchetto
 di livello 3.
\end_layout

\begin_layout Standard
In linea teorica MPLS funziona con qualunque protocollo di livello 3 e di
 livello 2.
\end_layout

\begin_layout Subsection*
Label Switched Path (LSP)
\end_layout

\begin_layout Standard
Il meccanismo che abbiamo visto assomiglia molto alla costituzione di un
 circuto virtuale.
 Però ha alcune differenze.
\end_layout

\begin_layout Standard
La sequenza di etichette e link attraversati dai pacchetti che appartengono
 ad una data FEC formano un Label Switched Path (
\series bold
\emph on
LSP
\series default
\emph default
).
\end_layout

\begin_layout Itemize
I LSP possono essere innestati uno nell'altro.
 Possono essere predenti più etichette.
 L'uso dello stacking permette di innestare i LSP uno nell'altro.
\end_layout

\begin_layout Itemize
Gli LSP sono unidirezionali.
 Non è detto che venga rispettato lo stesso percorso per le risposte.
\end_layout

\begin_layout Itemize
Solo le etichette esterne possono essere utilizzate per fare routing.
\end_layout

\begin_layout Standard
Ci sono due tipi di LSP:
\end_layout

\begin_layout Itemize

\series bold
LSP 
\emph on
hop-by-hop
\series default
\emph default
: Il prossimo hop è ottenuto con i normali algoritmi di routing e cambia
 se cambia la topologia di rete.
\end_layout

\begin_layout Itemize

\series bold
LSP 
\emph on
Explicit
\series default
\emph default
: il prossimo hop è segnalato da un Traffic Engineering protocol (
\series bold
\emph on
RSVP-TE
\series default
\emph default
) e le modifiche devono essere comunicate con lo stesso protocollo.
 Questi sistemi sono spesso chiamati 
\emph on
Traffic Engineering tunnels
\emph default
 perché attraversano una rete MPLS.
\end_layout

\begin_layout Standard
Può succedere che grazie ad alcuni LSR il 
\emph on
Label Switched Path
\emph default
 venga congiunto:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename mpls3.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Struttura logica di un LSR
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename mpls4.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection*

\series bold
Piano di controllo
\end_layout

\begin_layout Itemize

\series bold
\emph on
IP routing protocols
\series default
\emph default
: propagano le informazioni sulla rete
\end_layout

\begin_layout Itemize

\series bold
\emph on
Routing table
\end_layout

\begin_layout Itemize
Dalla tabella di routing con una apposita proceduta di estraggono le decisioni
 di instradamento e si popola la 
\series bold
\emph on
Label Information Base
\series default
\emph default
 (
\series bold
\emph on
LIB
\series default
\emph default
).
 Contiene per tutte le etichette che potrebbero entrare tutte le opzioni.
\end_layout

\begin_layout Subsubsection*

\series bold
Piano dati
\end_layout

\begin_layout Itemize

\series bold
\emph on
Label Forwarding Information Base
\series default
\emph default
 (
\series bold
LFIB
\series default
) contiene tutte le etichette che mi aspetto in entrata e cosa fare come
 conseguenza
\end_layout

\begin_layout Itemize

\series bold
\emph on
Packet Forwarding Engine
\series default
\emph default
: effettua le operazioni sul singolo pacchetto in ingresso guardando la
 
\emph on
Label Forwarding Information Base
\end_layout

\begin_layout Standard
Rivediamo la struttura
\end_layout

\begin_layout Itemize
La 
\emph on
Label Information Base
\emph default
 (
\series bold
\emph on
LIB
\series default
\emph default
) contiene per ogni 
\emph on
FEC
\emph default
, le associazioni 
\emph on
tra FEC e label.
\end_layout

\begin_layout Itemize
Ogni entry nella 
\emph on
LIB
\emph default
 contiene:
\end_layout

\begin_deeper
\begin_layout Itemize
La definizione della 
\emph on
FEC
\end_layout

\begin_layout Itemize
Le etichette locali che mi aspetto di ricevere per una certa FEC, anche
 per FEC che nessuno instrada verso di me.
\end_layout

\begin_layout Itemize
L'etichetta remota e il nodo remoto.
 Per ogni vicino il nodo conosce l'etichetta che deve essere utilizzata
 per inviare a quel nodo pacchetti appartenenti alla specifica FEC.
\end_layout

\end_deeper
\begin_layout Itemize
La LIB viene popolata da un protocollo di segnalazione
\end_layout

\begin_deeper
\begin_layout Itemize
Per gli LSP 
\emph on
hop-by-hop
\emph default
 dal 
\emph on
Label Distribution Protocol 
\emph default
(
\series bold
\emph on
LDP
\series default
\emph default
)
\end_layout

\begin_layout Itemize
Per gli LSP 
\emph on
explicit
\emph default
 dal 
\emph on
Reservation Protocol for Traffic Engineering 
\emph default
(
\series bold
RSVP-TE
\series default
)
\end_layout

\end_deeper
\begin_layout Standard
Per ogni FEC, la LIB contiene informazioni riguardo a diversi vicini, che
 non possono essere utilizzate per inoltrare pacchetti.
\end_layout

\begin_layout Subsubsection*
Esempio di procedura di riempimento della LIB
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename lib.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection*
Label Forwarding Information Base
\end_layout

\begin_layout Standard
È ottenuta dalla LIB tenendo solo le informazioni essenziali per l'instradamento
 riguardo agli LSP attualmente in uso.
\end_layout

\begin_layout Standard
Quindi abbiamo due tipi di tabelle:
\end_layout

\begin_layout Itemize
LERs utilizzano la FEC-to-NHLFE (
\series bold
FTN table
\series default
)
\end_layout

\begin_layout Itemize
LSRs utilizza la 
\emph on
Incoming Label Map
\emph default
 (
\series bold
\emph on
ILM
\series default
\emph default
).
\end_layout

\begin_layout Subsubsection*
FTN Table
\end_layout

\begin_layout Itemize
Utilizzato nei 
\series bold
LER
\end_layout

\begin_layout Itemize
Per ogni FEC dà la NHLFE
\end_layout

\begin_layout Subsubsection*
ILM Table
\end_layout

\begin_layout Itemize
Viene utilizzata nei LSR
\end_layout

\begin_layout Itemize
Per ogni etichetta fornisce la NHLFE
\end_layout

\begin_layout Subsubsection*
NHLFE
\end_layout

\begin_layout Itemize
Contiene le istruzioni riguardo a cosa fare con il pacchetto:
\end_layout

\begin_deeper
\begin_layout Itemize
Il 
\emph on
next-hop
\emph default
 e l'interfaccia di uscita
\end_layout

\begin_layout Itemize
Le operazioni da effettuare sul label (
\emph on
swap,push,pop
\emph default
)
\end_layout

\begin_layout Itemize
Le informazioni di 
\emph on
QoS
\emph default
 (la priorità)
\end_layout

\end_deeper
\begin_layout Subsubsection*
Operazioni sulle etichette
\end_layout

\begin_layout Itemize

\series bold
Swap
\end_layout

\begin_deeper
\begin_layout Itemize
Sovrascrive la 
\emph on
top-label
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Pop
\end_layout

\begin_deeper
\begin_layout Itemize
Rimuove la 
\emph on
top-label
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Push
\end_layout

\begin_deeper
\begin_layout Itemize
Se il pacchetto è già etichettato, sovrascrive la 
\emph on
top-label
\end_layout

\begin_layout Itemize
Altrmenti aggiunge una nuova 
\emph on
top-label
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Graphics
	filename lsr.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Componenti di MPLS Traffic Engeering
\end_layout

\begin_layout Standard
Ci servono 5 strumenti per realizzare questo meccanismo completo di ingegneria
 del traffico
\end_layout

\begin_layout Itemize
Un modo per 
\series bold
definire i flussi di traffico
\end_layout

\begin_deeper
\begin_layout Itemize
Possiamo fare classificazione e associazione con FEC.
 Basta mettere nei LER un algoritmo di classificazione che impementi scelte
 
\emph on
policy-based
\emph default
.
\end_layout

\end_deeper
\begin_layout Itemize
Abbiamo bisogno di una descrizione 
\series bold
quantitavia del traffico
\series default
 generato dal flusso in oggetto.
 Se vogliamo ingegnerizzare abbiamo bisogno di sapere quanta banda necessita
 questo flusso.
\end_layout

\begin_deeper
\begin_layout Itemize
Qualcuno deve dirci qual'è la caratterizzazione quantitavia del flusso.
 Di solito si prendono misure
\end_layout

\begin_layout Itemize
Solitamente si prende come misurazione la banda di picco.
\end_layout

\end_deeper
\begin_layout Itemize
Dobbiamo avere conoscenza della 
\series bold
topologia della rete 
\series default
e dell'
\series bold
attuale utilizzo
\series default
 di risorse
\end_layout

\begin_deeper
\begin_layout Itemize
La topologia la possiamo ottenere da qualunque protocollo di routing 
\emph on
link-state
\emph default
.
\end_layout

\begin_layout Itemize
Però nessun protocollo di routing da le informazioni sullo stato delle risorse
\end_layout

\begin_layout Itemize
Fortunatamente è stato inventato 
\series bold
\emph on
OSPF-TE
\end_layout

\end_deeper
\begin_layout Itemize
Ho bisogno un meccanismo per scegliere come instradare i tunnel di Traffic
 Engineering
\end_layout

\begin_deeper
\begin_layout Itemize
Dobbiamo definire un algoritmo 
\series bold
centralizzato
\end_layout

\begin_deeper
\begin_layout Itemize
Può essere implementato offline nelle stazioni di controllo e gestione della
 rete
\end_layout

\begin_layout Itemize
Può essere online (come ad esempio CSPF)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Ci vuole un protocollo per configurare i nuovi tunnel nei nodi LIB coinvolti
\end_layout

\begin_deeper
\begin_layout Itemize
Possiamo utilizzare RSVP-TE
\end_layout

\end_deeper
\begin_layout Standard
Vediamo un esempio di algoritmo online per l'instradamento dei tunnel di
 Traffic Engineering, il 
\emph on
Constrained Shortest Path First
\end_layout

\begin_layout Subsection*
Constrained Shortest Path First
\end_layout

\begin_layout Standard
Prima di eseguire l'algoritmo di instradamento, mettiamo temporaneamente
 all'infinito i costi di quei collegamenti che non soddisfano le richieste.
\end_layout

\begin_layout Standard
Quindi si tratta di una variazione dell'algoritmo 
\emph on
Shortest Path First
\emph default
.
\end_layout

\begin_layout Standard
Un link viene considerato solo se ha abbastanza banda per soddisfare la
 richiesta.
\end_layout

\begin_layout Standard
Un percorso deve essere calcolato solo per una specifica destinazione data.
\end_layout

\begin_layout Standard
Non è difficile trovare un algoritmo euristico dove la funzione obbiettivo
 è una grandezza 
\series bold
addittiva
\series default
 della rete (ad esempio la somma dei link attraversati) e dove i vincoli
 sui link siano 
\series bold
locali
\series default
.
 Se queste due caratteristiche sono soddisfatte, posso utilizzare algoritmi
 di questo tipo, altrimenti bisogna cercare altri tipi di algoritmi.
\end_layout

\begin_layout Standard
L'implementazione è simile a 
\emph on
Shortest Path First
\emph default
:
\end_layout

\begin_layout Itemize
Impostiamo temporaneamente a infinito i links che non soddisfano le richieste
\end_layout

\begin_layout Itemize
Ci fermiamo quando raggiungiamo il nodo di destinazione
\end_layout

\begin_layout Standard
L'algoritmo viene eseguito da ogni nodo della rete, è possibile che ci siano
 dei ritardi per cui alcuni nodi hanno informazioni non aggiornate.
 Quindi anche se l'algoritmo trova una soluzione, l'allocazione delle risorse
 può fallire.
\end_layout

\begin_layout Standard
[Esempio]
\end_layout

\begin_layout Subsection*
MPLS con Netkit
\end_layout

\begin_layout Standard
Netkit include una implementazione minimale di MPLS che include le funzionalità
 di:
\end_layout

\begin_layout Itemize

\series bold
Packet tagging
\end_layout

\begin_layout Itemize

\series bold
Label switching
\end_layout

\begin_layout Standard
Quello che non è incluso è un protocollo di distribuzione delle etichette.
 Quindi le etichette vanno assegnate manualmente via CLI.
\end_layout

\begin_layout Standard
In netkit non ci sono proprio le stesse tabelle che abbiamo già visto.
\end_layout

\begin_layout Standard
Ci sono le tabelle:
\end_layout

\begin_layout Itemize

\series bold
NHLFE
\series default
: Contiene le informazioni su come inoltrare i pacchetti
\end_layout

\begin_layout Itemize

\series bold
ILM
\series default
: contiene una lista di etichette
\end_layout

\begin_layout Itemize

\series bold
XC
\series default
 (
\emph on
Cross-connect
\emph default
): Mappa le etichette della ILM in una riga della NHLFE.
\end_layout

\begin_layout Itemize
(Quella che avevamo chiamato 
\series bold
FTN
\series default
 non c'è e il suo ruolo viene svolto dalla tabella di routing IP)
\end_layout

\begin_layout Itemize

\series bold
LABELSPACE
\series default
: È una tabella che specifica i set di etichette attesi entranti per ogni
 interfaccia.
 La stessa etichetta può essere attribuita ad un diverso spazio di etichette.
\end_layout

\begin_layout Subsubsection*
Operazioni con i label
\end_layout

\begin_layout Itemize

\series bold
Le operazioni in un LER
\series default
 (nodo di 
\series bold
ingresso
\series default
)
\end_layout

\begin_deeper
\begin_layout Itemize
Il pacchetto viene mappato ad un NHLFE tramite la tabella di routing IP
 (o via IPtables con cui possiamo classificare fino a livello 4)
\end_layout

\begin_layout Itemize
La NHLFE specifica l'etichetta (operazione di push)
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Operazioni in un LSR
\end_layout

\begin_deeper
\begin_layout Itemize
I pacchetti sono mappati ad un NHLFE utilizzando la tabella XC
\end_layout

\begin_deeper
\begin_layout Itemize
La lettura della tabella XC 
\begin_inset Quotes eld
\end_inset

consuma
\begin_inset Quotes erd
\end_inset

 l'etichetta (viene effettuato implicitamente un pop)
\end_layout

\end_deeper
\begin_layout Itemize
La NHLFE specifica una nuova etichetta (operazione di push)
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Operazioni in un LER
\series default
 (nodo di 
\series bold
uscita
\series default
)
\end_layout

\begin_deeper
\begin_layout Itemize
IL pacchetto è mappato ad un NHLFE utilizzando la tabella XC
\end_layout

\begin_deeper
\begin_layout Itemize
La lettura della tabella XC consuma una etichetta (operazione di pop)
\end_layout

\end_deeper
\begin_layout Itemize
La NHLFE non specifica una nuova etichetta
\end_layout

\end_deeper
\begin_layout Subsection*
Struttura del nostro laboratorio MPLS
\end_layout

\begin_layout Standard
[omissis]
\end_layout

\begin_layout Subsubsection*
Spiegazione della configurazione del ler1
\end_layout

\begin_layout Standard
Chi sta fuori usa routing IP, chi sta dentro usa routing MPLS e i due meccanismi
 convivono insieme
\end_layout

\begin_layout Itemize
Le macchine vuori dalla rete MPLS:
\end_layout

\begin_deeper
\begin_layout Itemize
Fanno routing in base all'indirizzo ip
\end_layout

\begin_layout Itemize
Conoscono solo i percorso di ingresso alla rete MPLS
\end_layout

\end_deeper
\begin_layout Itemize
Le macchine nella rete MPLS
\end_layout

\begin_deeper
\begin_layout Itemize
[omissis]
\end_layout

\end_deeper
\begin_layout Part*
BGP - Border Gataway Protocol
\end_layout

\begin_layout Section*
Struttura di Internet
\end_layout

\begin_layout Standard
Iniziamo a rivedere la struttura alla base di Internet.
\end_layout

\begin_layout Standard
La connettività ad Internet viene fornita da una serie di formitori chiamati
 
\emph on
Internet Service Providers
\emph default
 (
\series bold
\emph on
ISP
\series default
\emph default
).
\end_layout

\begin_layout Standard
Gli 
\series bold
ISP
\series default
 sono tipicamente organizzati in modo gerarchico.
 Esistono infatti:
\end_layout

\begin_layout Itemize
ISP Internazionali (
\series bold
Tier-1
\series default
)
\end_layout

\begin_layout Itemize
ISP Nazionali (
\series bold
Tier-1
\series default
)
\end_layout

\begin_layout Itemize
ISP Regionali (
\series bold
Tier-2
\series default
)
\end_layout

\begin_layout Itemize
(ISP Locali)
\end_layout

\begin_layout Standard
Solitamente sono organizzati in modo gerarchico ad albero, quindi gli ISP
 di livello inferiore pagano quelli di livello superiore per ottenere un
 servizio di connettività.
\end_layout

\begin_layout Standard
Spesso però esistono anche di collegamenti tra ISP dello stesso livello
 (ad esempio tra ISP regionali).
 Questo tipo di collegamenti sono chiamati 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
peering links
\series default
\emph default

\begin_inset Quotes erd
\end_inset

.
 Solitamente i collegamenti di peering non sono associati ad un pagamento
 per il servizio.
 Si tratta di una sorta di baratto: vi forniamo il nostro traffico in cambio
 del vostro.
\end_layout

\begin_layout Standard
Inoltre gli ISP 
\series bold
Tier-1
\series default
 sono collegati tra di loro, solitamente sempre con link di tipo 
\begin_inset Quotes eld
\end_inset

peering
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection*
Autonomous System (AS)
\end_layout

\begin_layout Standard
Sono stati definiti nella RFC 1930 come 
\begin_inset Quotes eld
\end_inset

un guppo connesso di uno o più prefissi IP gestiti da una o più operatori
 di rete che hanno una politica di routing singola e ben definita
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
In altre parole:
\end_layout

\begin_layout Itemize
È un insieme di sottoreti controllate in modo consistente, connesse da router
 omogenei con una unica entità amministrativa e un unico protocollo di routing
\end_layout

\begin_layout Itemize
Potrebbe trattarsi di un ISP, ma
\end_layout

\begin_deeper
\begin_layout Itemize
Un ISP può avere più 
\emph on
autonomous systems
\emph default
.
\end_layout

\begin_layout Itemize
Più ISP possono condividere lo stesso 
\emph on
autonomous system
\emph default
.
\end_layout

\end_deeper
\begin_layout Standard
Ogni AS ha un numero unico allocato dalla 
\series bold
\emph on
IANA
\series default
\emph default
.
 Si tratta di un numero identificativo a 32 bit (erano 16 bit fino al 2007).
 Ad oggi ci sono più di 37000 autonomous systems in Internet.
\end_layout

\begin_layout Subsection*
Tipi di routing
\end_layout

\begin_layout Itemize
Routing diretto:
\end_layout

\begin_deeper
\begin_layout Itemize
Sorgente e destinazione hanno lo stesso 
\emph on
net-id.
\end_layout

\begin_layout Itemize
Si effettua inoltro a livello 2 del pacchetto da inviare.
\end_layout

\end_deeper
\begin_layout Itemize
Routing indiretto:
\end_layout

\begin_deeper
\begin_layout Itemize
La sorgente e destinazione hanno 
\emph on
net-id
\emph default
 diverso.
\end_layout

\begin_layout Itemize
Il pacchetto viene inoltrato da router che utilizzano routing statico o
 
\series bold
\emph on
IGP 
\series default
\emph default
(
\emph on
Interior Gateway Protocol
\emph default
)
\end_layout

\end_deeper
\begin_layout Itemize
Routing gerarchico:
\end_layout

\begin_deeper
\begin_layout Itemize
La sorgente e destinazione sono su 
\emph on
autonomous systems
\emph default
 diversi
\end_layout

\begin_layout Itemize
Nell'autonomous system sorgente il pacchetto viene inoltrato da dei router
 che utilizzano 
\emph on
IGP
\emph default
 verso un router che può utilizzare 
\series bold
\emph on
EGP
\series default
\emph default
 (
\emph on
Exterior Gataway Protocol
\emph default
).
\end_layout

\begin_layout Itemize
I router che utilizzano EGP si occuperanno del routing tra AS diversi.
\end_layout

\begin_layout Itemize
Nell'AS di destinazione il pacchetto viene inoltrato dall'ultimo router
 EGP vino all'host di destinazione tramite IGP.
\end_layout

\end_deeper
\begin_layout Standard
Per il routing all'interno dell'
\emph on
autonomous system 
\emph default
abbiamo fondamentalmente tre possibilità: routing 
\emph on
statico
\emph default
, protocolli di routing 
\emph on
distance-vector
\emph default
 (come RIP) e protocolli di routing 
\emph on
link-state
\emph default
 (come OSPF).
\end_layout

\begin_layout Itemize
Il routing 
\series bold
statico
\end_layout

\begin_deeper
\begin_layout Itemize
Richiede configurazioni manuali e non richiede comunicazione tra i router.
\end_layout

\begin_layout Itemize
È una scelta appropiata quando si hanno reti molto piccole o ci sono politiche
 di routing o di sicurezza particolari.
\end_layout

\begin_layout Itemize
Non possiamo gestire i malfunzionamenti.
\end_layout

\end_deeper
\begin_layout Itemize
Il routing con protocolli 
\series bold
\emph on
distance-vector
\series default
\emph default
 
\end_layout

\begin_deeper
\begin_layout Itemize
Si parla solitamente di 
\series bold
\emph on
RIP
\series default
\emph default
 (
\emph on
Routing Information Protocol
\emph default
).
 È un protocollo di livello 4 che utilizza UDP (sulla porta 520) per inviare
 messaggi incapsulati in pacchetti IP.
\end_layout

\begin_layout Itemize
Un router RIP:
\end_layout

\begin_deeper
\begin_layout Itemize
Riceve informazioni di tipo distance-vector da altri router.
 Utilizza come metrica il numero di hop.
\end_layout

\begin_layout Itemize
Calcola la rotta migliore per ogni destinazione e aggiorna la tabella di
 routing.
\end_layout

\begin_layout Itemize
Invia messaggi di aggiornamento a tutti gli altri router periodicamente
 ogni 30 secondi (
\emph on
update timer
\emph default
) dopo una modifica nella rete.
 I messaggi sono inviati in modo flooding.
\end_layout

\begin_layout Itemize
La distanza massima è 16 hop (per evitare il fenomeno del count-to-infinity)
\end_layout

\end_deeper
\begin_layout Itemize
Ha lo svantaggio di reagire lentamente alle modifiche della topologia di
 rete, creando percorso lunghi, pacchetti in loop e altre cose.
\end_layout

\begin_layout Itemize
Può essere una scelta sensata per piccole reti.
\end_layout

\end_deeper
\begin_layout Itemize
Il routing con protocolli 
\series bold
\emph on
link-state
\end_layout

\begin_deeper
\begin_layout Itemize
Si parla solitamente di 
\series bold
\emph on
OSPF
\series default
\emph default
 (
\emph on
Open Shortest Path First
\emph default
), un protocollo non proprietario che fa uso dell'algoritmo di Dijkstra
 per calcolare le rotte migliori.
\end_layout

\begin_layout Itemize
Ogni router inviare informazioni riguardo ai propri links adiacenti inviando
 in 
\emph on
selective 
\emph default
flooding
\emph on
 un
\emph default
 
\series bold
\emph on
LSP
\series default
\emph default
 (
\emph on
Link State Packet
\emph default
) 
\end_layout

\begin_deeper
\begin_layout Itemize
I pacchetti sono inviati in selective flooding cioè:
\end_layout

\begin_deeper
\begin_layout Itemize
Si reinvia un pacchetto su tutte le interfaccie a parte quella dove lo si
 è ricevuto
\end_layout

\begin_layout Itemize
Il router memorizza i pacchetti già inviati per evitare di reinviarli e
 creare loop
\end_layout

\begin_layout Itemize
Non si reinvia un pacchetto che contiene informazioni già inviate
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Ogni router riceve gli LSP da tutti gli altri routers dell'AS.
\end_layout

\begin_layout Itemize
Ogni router crea al suo interno un grafo della rete e utilizza l'algoritmo
 SPF (Dikstra) per calcolare la sua tabella di routing
\end_layout

\begin_layout Itemize
Viene gestito il bilanciamento del carico se più rotte conducono alla stessa
 destinazione allo stesso costo.
\end_layout

\begin_layout Itemize
Tutti i routers periodicamente notificano che sono online e inviano pacchetti
 di 
\begin_inset Quotes eld
\end_inset


\emph on
hello
\emph default

\begin_inset Quotes erd
\end_inset

 per controllare lo stato dei collegamenti.
\end_layout

\begin_layout Itemize
Con OSPF è possibile separare un AS in aree differenti.
\end_layout

\begin_layout Itemize
Le informazioni topologiche sono trasmette mediante 
\series bold
\emph on
LSA
\series default
\emph default
 (
\emph on
Link State Advertisements
\emph default
)
\end_layout

\end_deeper
\begin_layout Section*
Border Gateway Protocol
\end_layout

\begin_layout Standard
È il protocollo di tipo EGP utilizzato ad oggi su Internet.
\end_layout

\begin_layout Standard
Comunica informazioni riguardo alle reti.
 Le reti sono definite come blocchi di indirizzi IP (in notazione CIDR)
\end_layout

\begin_layout Standard
Le informazioni vengono scambiate tra vari 
\emph on
autonomous systems
\end_layout

\begin_layout Itemize
L'attuale versione di BGP è chiamata 
\series bold
BGP4
\series default
 ed è stata definita inizialmente nella RFC 4271 del 2006.
 Questa RFC è frutto di una serie di revisioni che sono iniziate dalla prima
 RFC del 1989.
 La RFC di BGP è in continua revisione (vista la sua fondamentale importanza).
 L'
\begin_inset Quotes erd
\end_inset

ultimo
\begin_inset Quotes erd
\end_inset

 aggiornamento è la RFC 6286 del 2011.
\end_layout

\begin_layout Itemize
BGP basa le proprie comunicazioni all'interno di sessioni TCP in modo da
 garantire l'affidabilità.
\end_layout

\begin_layout Itemize
BGP utilizza per il calcolo dei percorsi un algoritmo di tipo 
\emph on
distance-vector
\emph default
.
 In realtà è una variante.
 Si tratta di un algoritmo di tipo 
\series bold
\emph on
path-vector.

\series default
\emph default
 Viene garantita l'assenza di loop.
\end_layout

\begin_layout Itemize
BGP è totalmente indipendente dal protocollo di tipo IGP adottato all'interno
 dell' AS.
\end_layout

\begin_layout Itemize
BGP è un misto di protocollo di routing unito a insieme di policy:
\end_layout

\begin_deeper
\begin_layout Itemize
Mantiene le tabelle di routing aggiornate e propaga le informazioni di routing
\end_layout

\begin_layout Itemize
Considera la possibilità che chi gestisce il router potrebbe voler agire
 sul processo di routing per favorire certi collegamenti rispetto ad altri
 (tipicamente per costi e motivi economici)
\end_layout

\end_deeper
\begin_layout Itemize
BGP viene utilizzato per:
\end_layout

\begin_deeper
\begin_layout Itemize
Clienti collegati ad uno o più ISP.
\end_layout

\begin_layout Itemize
Providers di transito che intercollegano più ISP tra loro.
\end_layout

\begin_layout Itemize
ISP che scambiano il proprio traffico in un NAP.
\end_layout

\begin_layout Itemize
Clienti con reti molto vaste.
\end_layout

\end_deeper
\begin_layout Itemize
BGP viene utilizzato sia per comunicare tra 
\emph on
autonomous systems 
\emph default
diversi, sia all'interno dello stesso 
\emph on
autonomous system
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Internal BGP
\series default
 (All'interno dello stesso AS)
\end_layout

\begin_layout Itemize

\series bold
External BGP
\series default
 (Con altri AS)
\end_layout

\begin_layout Itemize
In realtà è lo stesso protocollo.
 Semplicemente all'inizio (nel messaggio di 
\emph on
open
\emph default
) viene scambiato il numero di AS, se è lo stesso si utilizza IBGP, altrimenti
 EBGP.
\end_layout

\begin_layout Itemize
IBGP viene utilizzato perché all'interno di un AS possono esserci più routers
 di frontiera ed essi necessitano di comunicare tra loro.
 IBGP si basa sui protocolli di IGP (RIP , OSPF presenti all'interno della
 rete per poter raggiungere l'altro router BGP)
\end_layout

\end_deeper
\begin_layout Itemize
Problema: come colleghiamo due speakers via TCP se le informazioni di routing
 non sono ancora propagate? Solitamente i router BGP di frontiera sono collegati
 direttamente tra di loro e possono comunicare direttamente.
\end_layout

\begin_layout Subsection*

\series bold
Tipi di collegamenti tra 
\emph on
autonomous systems
\series default
:
\end_layout

\begin_layout Itemize

\series bold
AS single-homed
\end_layout

\begin_deeper
\begin_layout Itemize
Sono degli AS dove è presente un solo router BGP verso un'unica rete 
\end_layout

\begin_layout Itemize
Eventualmente è possibile anche utilizzare IBGP per comunicare con l'ISP
 a cui ci si collega (così però si diventa parte del suo AS)
\end_layout

\begin_layout Itemize
Utilizzando EBGP è necessario ottenere un numero registrato
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Non-transit multi-homed AS
\end_layout

\begin_deeper
\begin_layout Itemize
Sono degli AS dove sono presenti più router BGP di frontiera verso altre
 reti (solitamente ISP) ma non si vuole permette il transito di traffico
 proveniente da reti esterne attraverso il proprio AS
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Transit multi-homed AS
\end_layout

\begin_deeper
\begin_layout Itemize
Sono degli AS dove sono presenti più router BGP di frontiera verso altre
 reti (solitamente ISP) e si permette il transito di traffico esterno all'intern
o del proprio AS.
\end_layout

\begin_layout Itemize
Si utilizza IBGP tra i router BGP dell'AS, EBGP sui collegamenti esterni.
\end_layout

\end_deeper
\begin_layout Subsection*

\series bold
Path Vector
\end_layout

\begin_layout Itemize
BGP utilizza un approccio di tipo distance-vector, chiamato 
\series bold
\emph on
path-vector
\series default
\emph default
.
 Invece della 
\begin_inset Quotes eld
\end_inset

distanza
\begin_inset Quotes erd
\end_inset

, comunica il 
\begin_inset Quotes eld
\end_inset

percorso
\begin_inset Quotes erd
\end_inset

 (cioè la lista degli AS percorsi per arrivare a destinazione)
\end_layout

\begin_layout Itemize
Sfrutta sessioni affidabili per scambiare le informazioni.
\end_layout

\begin_layout Itemize
La rete viene rappresentata come un albero dove ogni nodo rappresenta un
 AS (identificato dal suo identificativo)
\end_layout

\begin_layout Itemize
Esempio:
\end_layout

\begin_deeper
\begin_layout Itemize
AS6 comunica ad AS5 le reti che contiene: 
\begin_inset Formula $\left(AS6\right)\rightarrow\left\{ N13,N14\right\} $
\end_inset


\end_layout

\begin_layout Itemize
AS5 riceve le informazioni e le inoltra ad AS4 in questo modo: 
\begin_inset Formula $\left(AS5,AS6\right)\rightarrow\left\{ N13,N14\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
La 
\begin_inset Quotes eld
\end_inset

lunghezza
\begin_inset Quotes erd
\end_inset

 del percorso è definita dal numero di AS da attraversare.
 
\begin_inset Formula $\left(AS5,AS6\right)\rightarrow\left\{ N13,N14\right\} $
\end_inset

 ha costo 2.
\end_layout

\begin_layout Itemize
Esiste il costo implicito di 1 per attraversare un AS.
\end_layout

\begin_layout Itemize
Per 
\begin_inset Quotes eld
\end_inset

ingegnerizzare il traffico
\begin_inset Quotes erd
\end_inset

 è possibile aggiungere più volte lo stesso AS in un percorso per aumentarne
 il costo.
 Ad esempio è possibile comunicare un percorso del tipo 
\begin_inset Formula $\left(AS5,AS5,AS6\right)\rightarrow\left\{ N13,N14\right\} $
\end_inset

 dove il costo è 3
\end_layout

\begin_layout Subsection*
Procedure funzionali
\end_layout

\begin_layout Itemize

\series bold
Acqusizione della rete
\end_layout

\begin_deeper
\begin_layout Itemize
Utilizzata dai router per acconsentire a diventare vicini o 
\emph on
peers
\end_layout

\begin_layout Itemize
Un router invia 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
open
\series default
\emph default

\begin_inset Quotes erd
\end_inset

 ad un altro.
 L'altro accetta rispondendo con un 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
keep-alive
\series default
\emph default

\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Raggiungibilità dei vicini
\end_layout

\begin_deeper
\begin_layout Itemize
Utilizzata dai router per mantenere i vicini.
\end_layout

\begin_layout Itemize
I due routers vicini inviano periodicamente un 
\series bold
\emph on
keep-alive
\series default
\emph default
 per sapere che i collegamenti sono attivi.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Raggiungibilità delle reti
\end_layout

\begin_deeper
\begin_layout Itemize
Ogni router mantiene un database delle sottoreti raggiungibili e le rotte
 preferite per ciascuna di esse.
 
\end_layout

\begin_layout Itemize
Nel database tiene delle tuple nel formato: 
\begin_inset Formula $\left\langle \text{net address}/n\quad\text{(lunghezza del prefisso)}\right\rangle $
\end_inset

 (formato CIDR)
\end_layout

\begin_layout Itemize
Quando ci sono delle modifiche nel database, il router invia dei messaggi
 di 
\series bold
\emph on
update
\series default
\emph default
 a tutti o alcuni dei router vicini.
\end_layout

\begin_layout Itemize
I messaggi di 
\series bold
\emph on
update
\series default
\emph default
 contengono informazioni riguardo alle destinazioni che possono essere raggiunte
 tramite un router e gli attributi delle rotte.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Processing delle informazioni di
\emph on
 update
\end_layout

\begin_deeper
\begin_layout Itemize
La tabella di route BGP è separata dalla tabella di routing IP
\end_layout

\begin_layout Itemize
Solo dei sottoinsiemi degli aggiornamenti ricevuti diventano effettivamente
 parte della tabella di routing IP e comunicati agli altri peer BGP.
\end_layout

\begin_layout Itemize
I sottoinsiemei vengono selezionati in base ad una serie di policy di selezione
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Componenti logici del processing dei messaggi BGP
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Input policy engine
\end_layout

\begin_deeper
\begin_layout Itemize
Filtra l'insieme delle rotte ricevute dai peers in base agli attributi
\end_layout

\begin_layout Itemize
Manipola gli attributi per prepararli al processo decisionale
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Decision process
\end_layout

\begin_deeper
\begin_layout Itemize
Si confrontano tutte le rotte disponibili per ogni destinazione 
\end_layout

\begin_layout Itemize
Si seleziona la rotta migliore in base agli attributi
\end_layout

\begin_layout Itemize
Le rotte scelte vengono effettivamente impostate nella tabella di routing
 IP
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
IP routing table
\end_layout

\begin_deeper
\begin_layout Itemize
Tiene le rotte selezionate nel processo decisionale
\end_layout

\begin_layout Itemize
Le rotte generate localmente dal router riguardo all'AS sono aggiunte.
\end_layout

\begin_layout Itemize
Le rotte inattive sono rimosse
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Output policy engine
\end_layout

\begin_deeper
\begin_layout Itemize
Si filtra l'insieme di aggiornamenti trovatinella tabella di routing IP,
 eliminando le rotte che non devono essere trasmesse pubblicamente.
\end_layout

\begin_layout Itemize
Si selezionano le rotte che devono essere notificate ai peer IBGP.
\end_layout

\begin_layout Itemize
Si selezionano le rotte che devono essere notificate ai peer EBGP.
\end_layout

\begin_layout Itemize
Si manipolano gli attributi di output.
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection*
Routing information Bases (RIBs)
\end_layout

\begin_layout Standard
Ogni interlocutore BGP mantiene le seguenti RIBs:
\end_layout

\begin_layout Itemize

\series bold
Adiacent-RIBs-In
\series default
: Mantiene tutte le informazioni in ingresso riguardo ai prefissi
\end_layout

\begin_layout Itemize

\series bold
Local-RIB
\series default
 (Tabella di routing IP): Per ogni prefisso memorizza la rotta selezionata
 nel processo decisionale.
\end_layout

\begin_layout Itemize

\series bold
Adiacent-RIBs-Out
\series default
: Memorizza le informazioni inviate agli interlocutori vicini
\end_layout

\begin_layout Subsection*
BGP Decision Process
\end_layout

\begin_layout Enumerate
Ricevo 
\series bold
\emph on
updates
\series default
\emph default
 dai vicini e li memorizzo nell 
\emph on
Adj-RIBs-In
\end_layout

\begin_layout Enumerate
Applico i filtri di import (un interlocutore può ignorare prefissi in base
 alla sua policy interna)
\end_layout

\begin_layout Enumerate
Determino la migliore rotta e la memorizzo nel 
\emph on
Loc-RIB
\end_layout

\begin_layout Enumerate
Per ogni vicino:
\end_layout

\begin_deeper
\begin_layout Enumerate
si effettua la 
\emph on
route aggregation
\emph default
 (opzionale)
\end_layout

\begin_layout Enumerate
applico i filtri di export
\end_layout

\begin_layout Enumerate
memorizzo nella 
\emph on
Adj-RIBs-Out
\end_layout

\end_deeper
\begin_layout Enumerate
Invio 
\series bold
\emph on
updates
\series default
\emph default
 ai vicini
\end_layout

\begin_layout Subsection*
Formato dei messaggi
\end_layout

\begin_layout Standard
I mesaggi BGP hanno una lunghezza totale da 19 a 4096 bytes.
\end_layout

\begin_layout Itemize
L'
\series bold
header
\series default
 è composto da:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Marker
\series default
 (16 bytes)
\end_layout

\begin_deeper
\begin_layout Itemize
Non più utilizzati (mantenuti per compatibilità e tenuti tutti a 1)
\end_layout

\begin_deeper
\begin_layout Itemize
Venivano utilizzati per l'autenticazione.
\end_layout

\begin_layout Itemize
Attualmente per l'autenticazione si sfrutta l'opzione di TCP chiamata 
\begin_inset Quotes eld
\end_inset


\emph on
TCP Authentication Option
\emph default

\begin_inset Quotes erd
\end_inset

 (RFC 5925).
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Length
\series default
 (2 bytes)
\end_layout

\begin_layout Itemize

\series bold
Type
\series default
 (1 byte)
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Open
\series default
: Stabilisce una sessione BGP
\end_layout

\begin_layout Itemize

\series bold
Update
\series default
: Propaga informazioni riguardo un prefisso (utilizzato anche per annunciare
 quando un prefisso non è più raggiungibile).
\end_layout

\begin_layout Itemize

\series bold
Notification
\series default
: Viene utilizzato per chiudere in modo corretto una sessione (altrimenti
 una sessione viene chiusa quando non arrivano messaggi per un po' di tempo).
\end_layout

\begin_layout Itemize

\series bold
Keep-alive
\series default
: Inviato periodicamente per controllare lo stato di una sessione.
\end_layout

\begin_layout Itemize

\series bold
Route-refresh
\series default
: richiede al vicino BGP di reinviare gli update di tutti i prefissi.
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
Alcuni messaggi contengono solo l'header.
\end_layout

\begin_layout Subsection*
Messaggi di update
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename bgpupdate.png
	scale 35

\end_inset


\end_layout

\begin_layout Itemize

\series bold
NLRI (Network Layer Reachability Information)
\series default
 (riguardo ad un solo percorso)
\end_layout

\begin_deeper
\begin_layout Itemize
Insieme di nuove destinazioni IP notificate dai router vicini.
\end_layout

\begin_layout Itemize

\emph on
prefix
\emph default
 è il normale indirizzo IP di rete
\end_layout

\begin_layout Itemize

\emph on
Length
\emph default
 è il numero di 1 nella maschera (formato CIDR)
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Path attributes
\end_layout

\begin_deeper
\begin_layout Itemize
Insieme di parametri che caratterizzano una rotta
\end_layout

\begin_layout Itemize
Sono nella forma: 
\begin_inset Formula $\left\langle type,length,value\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
Vediamo alcuni attributi:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
AS_path
\series default
: è la sequenza di AS attraversati dalla rotta.
\end_layout

\begin_layout Itemize

\series bold
Next_hop
\series default
: indirizzo IP di:
\end_layout

\begin_deeper
\begin_layout Itemize
Nodo vicino che ha generato la rotta EBGP
\end_layout

\begin_layout Itemize
Nodo vicino che ha generato l'origine interna IBGP
\end_layout

\begin_layout Itemize
Prossimo hop dal nodo EBGP di origine esterna.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Multi_exit_disc (MED)
\series default
: avviso del prefisso locale esterno
\end_layout

\begin_layout Itemize

\series bold
Local_pref
\series default
: deciso dall'AS e scambiato solo via IBGP
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Rotte inutilizzate
\end_layout

\begin_deeper
\begin_layout Itemize
Insieme di destinazioni che non sono più raggiungibili.
\end_layout

\begin_layout Itemize
Utilizza lo stesso formato di NLRI
\end_layout

\end_deeper
\begin_layout Standard
Vediamo la sequenza di decisioni prese da un router BGP in base agli attributi:
\end_layout

\begin_layout Itemize
Se il next hop non è disponibile, ignora la rotta
\end_layout

\begin_layout Itemize
Scegli la rotta con la preferenza locale massima
\end_layout

\begin_layout Itemize
Sceglia la rotta con una origine locale (AS che ha generato la rotta)
\end_layout

\begin_layout Itemize
Scegli la rotta con il più corto AS_path
\end_layout

\begin_layout Itemize
Scegli la rotta con il più basso tipo di origine (1: rotta derivata da IGP,
 2: rotta derivata da EGP, 3: rotta incompleta)
\end_layout

\begin_layout Subsection*
Path attributes
\end_layout

\begin_layout Itemize

\series bold
NEXT_HOP
\end_layout

\begin_deeper
\begin_layout Itemize
L'IP del router che può gestire il traffico per questo prefisso (dice dove
 inviare i pacchetti per una specifica rete IP)
\end_layout

\begin_layout Itemize

\emph on
Prefix
\emph default
: è una parte di indirizzamento IP annunciata
\end_layout

\begin_layout Itemize
Gli annunci delle rotte possono essere aggregati
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
AS_PATH
\series default
: la lista dei numeri di AS visitati fino ad ora
\end_layout

\begin_deeper
\begin_layout Itemize
Dice la sequenza di AS che devono essere attraversati per raggiungere il
 prefisso della destinazione (utilizzato il percorso anche per evitare loops
 come già detto)
\end_layout

\begin_layout Itemize
Ogni interlocutore BGP aggiunge il proprio numero AS quando propaga le informazi
oni sulla rotta ad un altro peer.
 La lista è vuota per rotte locali.
\end_layout

\begin_layout Itemize
Non cambia in sessioni IBGP
\end_layout

\begin_layout Itemize
Può essere modificata da qualunque interlocutore BGP.
 Le rotte possono essere 
\bar under
potenzialmente falsificate
\bar default
.
\end_layout

\begin_layout Itemize

\series bold
Route aggregation
\end_layout

\begin_deeper
\begin_layout Itemize
Ogni interlocautore BGP può decidere di aggregare più rotte e propagare
 il singolo annuncio (
\emph on
prefix aggregation
\emph default
)
\end_layout

\begin_layout Itemize
Il router BGP che effettua l'aggregamento diventa l'origine.
 Esso deve cancellare l'AS_path (ci sono potenziali loop!)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
LOCAL_PREF
\series default
: Imposta le preferenze locali per una specifica rotta
\end_layout

\begin_deeper
\begin_layout Itemize
Viene utilizzato solo in IBGP per dare priorità in caso di rotte multiple
 per lo stesso prefisso.
\end_layout

\begin_layout Itemize
Vengono preferiti valori elevati.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
WEIGHT
\series default
 (opzione proprietaria Cisco): simile a Local_pref
\end_layout

\begin_layout Itemize

\series bold
MULTI_EXIT_DISCRIMINATOR (MED)
\series default
: utilizzato per dare priorità in caso di più link tra gli stessi AS.
\end_layout

\begin_deeper
\begin_layout Itemize
Utile per fare load balancing
\end_layout

\begin_layout Itemize
Ha senso tra due AS collegati con più link.
 A collegato a B con i link 1 e 2.
 A indica a B che in base as A, B dovrebbe utilizzare il link 1 quando invia
 traffico ad A.
\end_layout

\begin_layout Itemize
Solitamente viene disabilitato: Se A e B non sono d'accordo su MED, esso
 può causare oscillazioni delle rotte.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ORIGIN
\series default
: come il prefisso è entrato nella rete BGP
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
IGP
\series default
: La rotta è derivata da un protocollo IGP (OSPF,IS-IS,RIP,...)
\end_layout

\begin_layout Itemize

\series bold
EGP
\series default
: La rotta è derivata da EGP (un vecchio protocollo reso obsoleto da BGP)
\end_layout

\begin_layout Itemize

\series bold
Incomplete
\series default
: La rotta è stata derivata in qualche altro modo (rotta statica?)
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
COMMUNITY
\series default
: associa una comunità di AS ad una rotta.
\end_layout

\begin_deeper
\begin_layout Itemize
Una comunità è un insieme di prefissi che condividono proprietà comuni (ad
 esempio nazionalità, ...)
\end_layout

\begin_layout Itemize
Utile per politiche di import/export.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ATOMIC_AGGREGATE
\series default
: indica l'entità di cui vengono perse le informazioni a causa di una aggregazio
ne di rotte
\end_layout

\begin_deeper
\begin_layout Itemize
Non deve essere utilizzato quando AS_SET viene utilizzato
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
AGGREGATOR
\series default
: speciica l'AS e il router che effettua l'aggregazione
\end_layout

\begin_layout Standard
Gli attributi possono essere:
\end_layout

\begin_layout Itemize

\emph on
well-known
\emph default
 o opzionali (capiti da qualunque interlocutore BGP4)
\end_layout

\begin_deeper
\begin_layout Itemize
Mandatory well-known: as-path,next-hop,origin
\end_layout

\begin_layout Itemize
Discretionary well-known: local_preference, atomic_aggregate
\end_layout

\begin_layout Itemize
Non transitve optional: multi-exit-discriminator
\end_layout

\begin_layout Itemize
Transitive optional: aggregator, community
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
mandatory or discretionary
\emph default
 (attributi obbligatori che devono essere presenti in ogni update)
\end_layout

\begin_layout Itemize

\emph on
transitive or nontransitive
\emph default
 
\end_layout

\begin_layout Standard
Per ogni prefisso, il router sceglie uno degli annunci ricevuti come il
 
\begin_inset Quotes eld
\end_inset

migliore
\begin_inset Quotes erd
\end_inset

.
 Il processo decisionare è basato sulla valutazione degli attributi BGP
 ed è totalmente deterministico (non vengono prese scelte casuali)
\end_layout

\begin_layout Standard
Solo le rotte migliori sono 
\begin_inset Quotes eld
\end_inset

inoltrate
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection*
Best Route Determination
\end_layout

\begin_layout Standard
Se, dopo avter filtrato, più di una rotta esiste, allora ne scelgo una in
 questo ordine di preferenza:
\end_layout

\begin_layout Enumerate
Se il NEXT_HOP non è disponibile, ignoro la rotta
\end_layout

\begin_layout Enumerate
Prendo il più alto LOCAL_PREF
\end_layout

\begin_layout Enumerate
Preferisco percorsi originati localmente
\end_layout

\begin_layout Enumerate
Preferisco AS_PATH più corto
\end_layout

\begin_layout Enumerate
Il valore più basso di ORIGIN (IGP<EGP<Incomplete)
\end_layout

\begin_layout Enumerate
Il valore più basso di MED
\end_layout

\begin_layout Enumerate
Preferisco EBGP rispetto a IBGP
\end_layout

\begin_layout Enumerate
Minimo costo interno a NEXT_HOP (
\emph on
hot potato
\emph default
)
\end_layout

\begin_layout Enumerate
Preferisco la rotta che arriva dall'interlocuatore con il più basso router
 ID (il router ID è l'ip più alto del router)
\end_layout

\begin_layout Subsection*
Policy di Import/Export
\end_layout

\begin_layout Itemize
Il routing tra AS dipende da accordi economici tra gli AS
\end_layout

\begin_layout Itemize
Come risultati, BGP si basa massicciamente su politiche di filtraggio e
 preferenze locali
\end_layout

\begin_layout Itemize
Ad esempio:
\end_layout

\begin_deeper
\begin_layout Itemize
I prefissi dentro AS123 non devono essere instradati attraverso AS456
\end_layout

\begin_layout Itemize
I prefissi dentro AS123 devono essere instradati preferibilmente attraverso
 AS789
\end_layout

\end_deeper
\begin_layout Itemize
Filtro negli annunci:
\end_layout

\begin_deeper
\begin_layout Itemize
Invio/accetto un annuncio solo se alcune condizioni sono verificate
\end_layout

\end_deeper
\begin_layout Itemize
Miglioramento negli annunci:
\end_layout

\begin_deeper
\begin_layout Itemize
Aggiungiamo agli annunci alcune informazioni (attributi) che possono essere
 considerati dal ricevitore.
\end_layout

\end_deeper
\begin_layout Itemize
Nodi che implementano regole incompatibili possono portare all'instabilità.
\end_layout

\begin_layout Itemize
Le regole BGP sono:
\end_layout

\begin_deeper
\begin_layout Itemize
Regola 0: Il numero di AS è rilevante solo quando si utilizza EBGP
\end_layout

\begin_layout Itemize
Regola 1: Un interlocutore BGP può avvisare via IBGP prefissi derivati via
 EBGP e viceversa.
\end_layout

\begin_layout Itemize
Regola 2: Un interlocutore BGP non può comunicare via IBGP prefissi derivati
 tramite IBGP.
\end_layout

\begin_layout Itemize
La regola 0 viola la prevenzione di loop, che deve essere ripristinata con
 la regola 2.
\end_layout

\begin_layout Itemize
La regola 2 implica che gli interlocutori BGP devono formare una rete a
 maglia completa
\end_layout

\end_deeper
\begin_layout Subsection*
BGP Synchronization
\end_layout

\begin_layout Itemize
BGP deve essere sincronizzato con l'IGP dell'AS.
 Prima di notificare nuove destinazioni ad una AS, un router BGP dovrebbe
 controllare che è supportato dall'IGP del suo AS.
\end_layout

\begin_layout Itemize
Effetti della mancanza di sincronizzazione:
\end_layout

\begin_deeper
\begin_layout Itemize
Una rotta esterna è ricevuta da un router EBGP di AS3.
\end_layout

\begin_layout Itemize
L'informazione è propagata con IBGP ad un altro router BGP
\end_layout

\begin_layout Itemize
L'informazione è anche interamente comunicata al protocollo IGP di AS3
\end_layout

\begin_layout Itemize
Il roter BGP ristribuite le informazioni a AS2 tramite EBGP prima che tutti
 i router IGP di AS3 siano aggiornati
\end_layout

\begin_layout Itemize
AS2 inizia a inviare pacchetti IP a destinazioni non note a indirizzi di
 AS3 che non corrispondono a router BGP.
\end_layout

\end_deeper
\begin_layout Itemize
BGP può operare in modalità statica o dinamica
\end_layout

\begin_layout Itemize
Modalità 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
fully-dynamic
\series default
\emph default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Tutte le rotte IGP di un AS vengono ridistribuite
\end_layout

\begin_layout Itemize
Si utilizza il comando 
\begin_inset Quotes eld
\end_inset


\emph on
redistribute
\emph default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Ci sono problemi per la propagazione di errori, indirizzi privati trasmetti
 in pubblico
\end_layout

\end_deeper
\begin_layout Itemize
Modalità 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
semi-dynamic
\series default
\emph default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Solo una selezione delle rotte IGP viene ridistribuita
\end_layout

\begin_layout Itemize
Il comando 
\begin_inset Quotes eld
\end_inset


\emph on
network
\emph default

\begin_inset Quotes erd
\end_inset

 viene utilizzato per specificare il sottoinsieme delle rotte 
\begin_inset Quotes eld
\end_inset

pubbliche
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Alcune implementazioni di IGP permettono già di distinguere rotte interne
 ed esterne (ad esempio 
\emph on
OSPF
\emph default
)
\end_layout

\begin_layout Itemize
È difficile da utilizzare in reti molto vaste
\end_layout

\end_deeper
\begin_layout Itemize
Il problema principale è l'instabilità se le rotte IGP generano grandi cicli
 di aggiornamenti BGP attraverso diversi AS.
 Le soluzioni sono:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
\emph on
Route dampening
\end_layout

\begin_deeper
\begin_layout Itemize
L'annuncio delle rotte è regolato in base alla stabilità attuale
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
\emph on
Address aggregation
\end_layout

\begin_deeper
\begin_layout Itemize
Meglio la fluttuazione di una singola rotta rispetto a diverse (ha effetti
 più limitati)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Operazioni statiche di BGP
\end_layout

\begin_deeper
\begin_layout Itemize
Quando nell'AS viene utilizzato routing statico si possono utilizzare normalment
e i comandi 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
redistribute
\series default
\emph default

\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
network
\series default
\emph default

\begin_inset Quotes erd
\end_inset

 come nel caso dinamico
\end_layout

\begin_layout Itemize
Si risolvono problemi legati al caso dinamico
\end_layout

\begin_layout Itemize
Ci sono però problemi di 
\emph on
fault-tolerance
\emph default
.
 Alcune destinazioni potrebbero risultare non riaggiungibili anche se sono
 fisicamente connesse
\end_layout

\end_deeper
\begin_layout Subsection*
Gestione delle sessioni BGP
\end_layout

\begin_layout Itemize
BGP mantiene diversi 
\series bold
timers
\series default
 per ogni sessione:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
ConnectRetryTimer
\series default
: solitamente impostato a 
\bar under
120 secondi
\bar default
.
\end_layout

\begin_layout Itemize

\series bold
HoldTimer
\series default
: è il tempo massimo senza messaggi in una sessione, solitamente è impostato
 a 
\bar under
90 secondi
\bar default
.
\end_layout

\begin_layout Itemize

\series bold
KeepAliveTimer
\series default
: è il tempo tra due 
\emph on
keepalive
\emph default
.
 Solitamente è impostato a 
\bar under

\begin_inset Formula $\frac{1}{3}$
\end_inset

 di 
\emph on
HoldTimer
\emph default
\bar default
.
\end_layout

\begin_layout Itemize

\series bold
MinRouteAdvertisementIntervalTimer
\series default
: è il tempo minimo tra due update dello stesso prefisso.
 Solitamente è raccomandato a 
\bar under
5 secondi per iBGP
\bar default
, 
\bar under
20 secondi per eBGP
\bar default
.
\end_layout

\begin_layout Itemize

\series bold
MinASOriginationIntervalTimer
\series default
: è il tempo minimo tra due UPDATE per lo stesso prefisso se il prefisso
 è interno all'AS.
 Solitamente è 
\bar under
15 secondi
\bar default
.
\end_layout

\end_deeper
\begin_layout Itemize
Per evitare la sincronizzazione tra le sessioni, i timer (a parte HoldTimer)
 sono randomizzati.
\end_layout

\begin_layout Subsection*
Messaggi BGP
\end_layout

\begin_layout Itemize

\series bold
Open
\end_layout

\begin_deeper
\begin_layout Itemize
Contiene il 
\begin_inset Quotes eld
\end_inset


\emph on
Waiting time
\emph default

\begin_inset Quotes erd
\end_inset

: il tempo passato dall'ultimo 
\emph on
keep-alive 
\emph default
o 
\emph on
update
\emph default
.
 Se supera una soglia (
\emph on
HoldTimer
\emph default
), il vicino è inattivo.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Keep-alive
\end_layout

\begin_deeper
\begin_layout Itemize
È già contenuto nell'header
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Notification
\end_layout

\begin_deeper
\begin_layout Itemize
Contiene 
\emph on
error code
\emph default
 e 
\emph on
sub code
\emph default
 che forniscono informazioni dettagliate riguardo all'errore trovato.
\end_layout

\end_deeper
\begin_layout Subsection*
Stati di BGP
\end_layout

\begin_layout Standard
Un router può trovarsi nei seguenti stati:
\end_layout

\begin_layout Itemize

\series bold
Idle
\end_layout

\begin_deeper
\begin_layout Itemize
Dopo essere stato avviato con il comando di start da un operatore
\end_layout

\begin_layout Itemize
Inizializza i contatori e le risorse, cerca connessioni TCP già iniziate
 con un peer.
\end_layout

\begin_layout Itemize
Se ci sono errori resta in idle, altrimenti passa a 
\series bold
connect
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Connect
\end_layout

\begin_deeper
\begin_layout Itemize
Attende per il setup completo delle connessioni TCP
\end_layout

\begin_layout Itemize
Se ci sono errori va in 
\series bold
active
\end_layout

\begin_layout Itemize
In caso di successo invia un messaggio 
\series bold
\emph on
Open
\series default
\emph default
 e passa nello stato di 
\series bold
open sent
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Active
\end_layout

\begin_deeper
\begin_layout Itemize
Tenta di stabilire una connessione TCP con un 
\emph on
peer
\emph default
.
\end_layout

\begin_layout Itemize
Se c'è un timeout torna allo stato di 
\series bold
connect
\end_layout

\begin_layout Itemize
In caso di successo invia un messaggio 
\series bold
\emph on
Open
\series default
\emph default
 e passa nello stato di 
\series bold
open sent
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Open sent
\end_layout

\begin_deeper
\begin_layout Itemize
Attende un messaggio di 
\emph on
Open
\end_layout

\begin_layout Itemize
Si controllano eventuali errori sul messaggio di Open ricevuto
\end_layout

\begin_layout Itemize
Se è andato a successo, si invia un 
\emph on
Keep-alive
\emph default
, si resetta il contatore e si passa a 
\series bold
\emph on
open confirm
\end_layout

\begin_layout Itemize
Se ci sono errori nel messaggio di 
\emph on
Open
\emph default
 viene inviata una 
\emph on
Notification
\emph default
 e si passa allo stato 
\series bold
\emph on
idle
\end_layout

\begin_layout Itemize
Se cade la connessione si torna nello stato 
\series bold
\emph on
active
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Open confirm
\end_layout

\begin_deeper
\begin_layout Itemize
Si attende un 
\emph on
keep-alive
\emph default
 o una 
\emph on
notification
\emph default
 mentre vengono trasmessi periodicamente dei 
\emph on
keep-alive
\end_layout

\begin_layout Itemize
Quando ricevo un 
\emph on
keep-alive 
\emph default
o un 
\emph on
update
\emph default
, resetto il timer counter e passo nello stato 
\series bold
\emph on
established
\end_layout

\begin_layout Itemize
Se ricevo delle 
\emph on
notification
\emph default
 o cade la connessione, torno nello stato 
\series bold
\emph on
idle
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Established
\end_layout

\begin_deeper
\begin_layout Itemize
Scambio messaggi di 
\emph on
Update
\emph default
 e 
\emph on
keep-alive
\emph default
 con il 
\emph on
peer
\emph default
.
\end_layout

\begin_layout Itemize
Resetto il contatore di tempo ogni volta che ricevo un 
\emph on
Update
\emph default
 e 
\emph on
keep-alive
\emph default
.
\end_layout

\begin_layout Itemize
Continuo ad inviare 
\emph on
keep-alive
\emph default
 periodicamente.
\end_layout

\begin_layout Itemize
Controllo errori nell'
\emph on
update 
\emph default
ricevuto.
\end_layout

\begin_layout Itemize
Se ci sono errori nell'update invio una 
\emph on
notification 
\emph default
e torno in stato 
\series bold
\emph on
idle
\series default
\emph default
.
\end_layout

\begin_layout Itemize
Se ricevo una 
\emph on
notification
\emph default
 o cade la connessione, torno in stato 
\series bold
\emph on
idle
\series default
\emph default
.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Graphics
	filename BGP_FSM.svg
	scale 30

\end_inset


\end_layout

\begin_layout Subsection*
Problemi generali con BGP
\end_layout

\begin_layout Itemize
Sicurezza
\end_layout

\begin_deeper
\begin_layout Itemize
È troppo facile 
\begin_inset Quotes eld
\end_inset

rubare
\begin_inset Quotes erd
\end_inset

 dei blocchi di indirizzi IP
\end_layout

\begin_layout Itemize
È difficile verificare le informazioni ricevute (come ad esempio l'AS path
 che potrebbe essere modificato da chi lo manda)
\end_layout

\end_deeper
\begin_layout Itemize
Modello di business
\end_layout

\begin_deeper
\begin_layout Itemize
La connettività mondiale dipende dalla cooperazione di più operatori (perché
 dovrebbe essere un problema?)
\end_layout

\end_deeper
\end_body
\end_document
