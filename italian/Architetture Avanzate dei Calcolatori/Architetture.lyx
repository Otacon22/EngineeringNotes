#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Architetture Avanzate dei Calcolatori"
\pdf_author "Daniele Iamartino"
\pdf_subject "Riassunto del corso di Architetture Avanzate dei Calcolatori c/o Politecnico di Milano, a.a. 2013-14, prof.ssa Cristina Silvano"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1cm
\rightmargin 1cm
\bottommargin 1cm
\headheight 1cm
\headsep 1cm
\footskip 1.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Architetture Avanzate dei Calcolatori
\begin_inset Foot
status open

\begin_layout Plain Layout
Quest'opera è sotto licenza Creative Commons Attribuzione - Condividi allo
 stesso modo 2.5 Italia License.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Author
Daniele Iamartino
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduzione
\end_layout

\begin_layout Standard
In questo corso vedremo alcuni dei problemi 
\begin_inset Quotes eld
\end_inset

avanzati
\begin_inset Quotes erd
\end_inset

 nelle architetture dei calcolatori:
\end_layout

\begin_layout Itemize
Come possiamo aumentare le performance riducendo il costo finale del design
 architetturale?
\end_layout

\begin_deeper
\begin_layout Itemize
RISC
\end_layout

\begin_layout Itemize
Pipeline
\end_layout

\end_deeper
\begin_layout Itemize
Possiamo guadagnare ancora di più?
\end_layout

\begin_deeper
\begin_layout Itemize
Branch prediction 
\end_layout

\begin_layout Itemize
Instruction level parallelism
\end_layout

\begin_layout Itemize
Multithreading
\end_layout

\begin_layout Itemize
Multiprocessors
\end_layout

\end_deeper
\begin_layout Itemize
Soluzioni ancora più avanzate
\end_layout

\begin_deeper
\begin_layout Itemize
Memory hierarchy
\end_layout

\begin_layout Itemize
Cache organization
\end_layout

\end_deeper
\begin_layout Subsection
Riferimenti
\end_layout

\begin_layout Itemize
"
\emph on
Computer Architecture, A Quantitative Approach
\emph default
", John Hennessy, David Patterson, Morgan Kaufmann, Fourth Edition
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Pipeline
\end_layout

\begin_layout Section
Caratteristiche della architettura MIPS
\end_layout

\begin_layout Itemize
MIPS è una architettura 
\series bold
RISC
\series default
 (Reduced Instruction Set Computer), è basata quindi sul concetto di eseguire
 solo semplici istruzioni.
\end_layout

\begin_layout Itemize
Utilizza una architettura 
\series bold
LOAD
\series default
/
\series bold
STORE
\end_layout

\begin_deeper
\begin_layout Itemize

\bar under
Tutti
\bar default
 gli operandi delle operazioni vengono spostati in registri 
\emph on
general purpose
\emph default
 della CPU e 
\series bold
non
\series default
 possono arrivare direttamente dalla memoria.
\end_layout

\begin_layout Itemize
Quindi, si utilizza la 
\series bold
LOAD
\series default
 per spostare dati dalla memoria ai registri e la 
\series bold
STORE
\series default
 per spostare dati dai registri alla memoria
\end_layout

\end_deeper
\begin_layout Itemize
MIPS è basato su una 
\series bold
architettura a pipeline
\series default
 che è una tecnica di ottimizzazione che si basa sulla sovrapposizione dell'esec
uzione di istruzioni multiple derivate da un flusso di esecuzione sequenziale
\end_layout

\begin_layout Itemize
MIPS utilizza 32 registri
\end_layout

\begin_layout Subsection
Instruction Set Architecture (base) del processore MIPS
\end_layout

\begin_layout Itemize
Istruzioni di 
\series bold
ALU
\series default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code
add $s1, $s2, $s3         # $s1 ← $s2 + $s3
\end_layout

\begin_layout LyX-Code
addi $s1, $s2, 4          # $s1 ← $s2 + 4
\end_layout

\end_deeper
\begin_layout Itemize
Istruzioni 
\series bold
load
\series default
/
\series bold
store
\series default
 (di 
\series bold
\emph on
w
\series default
ord
\emph default
) da 
\series bold
M
\series default
emoria (
\bar under
attenzione all'ordine degli operandi
\bar default
):
\end_layout

\begin_deeper
\begin_layout LyX-Code
lw $s1, offset ($s2)      # $s1 ← M[$s2+offset]
\end_layout

\begin_layout LyX-Code
sw $s1, offset ($s2)      # M[$s2+offset] ← $s1
\end_layout

\end_deeper
\begin_layout Itemize
Istruzioni di 
\series bold
branch condizionali
\series default
 (controllo di flusso):
\end_layout

\begin_deeper
\begin_layout LyX-Code
beq $s1, $s2, L1          # go to L1 if ($s1 == $s2)
\end_layout

\begin_layout LyX-Code
bne $s1, $s2, L1          # go to L1 if ($s1 != $s2)
\end_layout

\end_deeper
\begin_layout Itemize
Istruzioni di 
\series bold
branch incondizionati
\series default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code
j L1                      # jump to L1
\end_layout

\begin_layout LyX-Code
jr $s1                    # jump to address contained in $s1
\end_layout

\end_deeper
\begin_layout Subsection
Formato delle istruzioni MIPS a 32 bit
\end_layout

\begin_layout Itemize

\series bold
Tipo R
\series default
 (Register):
\end_layout

\begin_deeper
\begin_layout Itemize
Istruzioni ALU
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Tipo I 
\series default
(Immediate):
\end_layout

\begin_deeper
\begin_layout Itemize
Istruzioni immediate
\end_layout

\begin_layout Itemize
Istruzioni load/store
\end_layout

\begin_layout Itemize
Branch condizionali
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Tipo J 
\series default
(Jump):
\end_layout

\begin_deeper
\begin_layout Itemize
Istruzioni di jump incondizionato
\end_layout

\end_deeper
\begin_layout Subsubsection
Formato R per istruzioni ALU Register-Register 
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opcode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
shamt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
funct
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 bit
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Description

\series bold
Opcode
\series default
 Identifica il tipo di istruzione ALU
\end_layout

\begin_layout Description

\series bold
rs
\series default
 Primo operando 
\series bold
sorgente
\end_layout

\begin_layout Description

\series bold
rt
\series default
 Secondo operando 
\series bold
sorgente
\end_layout

\begin_layout Description

\series bold
rd
\series default
 Registro di destinazione
\end_layout

\begin_layout Description

\series bold
shamt
\series default
 Quantità di shift
\end_layout

\begin_layout Description

\series bold
funct
\series default
 Identifica diversi tipi di istruzioni ALU
\end_layout

\begin_layout Subsubsection
Formato I per istruzioni LOAD/STORE
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opcode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rt
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
offset
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Description

\series bold
Opcode
\series default
 Identifica il tipo di istruzione ALU
\end_layout

\begin_layout Description

\series bold
rs
\series default
 Registro base
\end_layout

\begin_layout Description

\series bold
rt
\series default
 Registro destinazione o sorgente per i dati caricati o salvati in memoria
\end_layout

\begin_layout Description

\series bold
offset
\series default
 Viene utilizzato (estendendolo in segno) sommato con l'indirizzo del base
 register
\end_layout

\begin_layout Subsubsection
Formato I per istruzioni immediate ALU
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opcode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rt
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
immediate
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Description

\series bold
Opcode
\series default
 Identifica il tipo di istruzione ALU
\end_layout

\begin_layout Description

\series bold
rs
\series default
 Registro sorgente
\end_layout

\begin_layout Description

\series bold
rt
\series default
 Registro destinazione
\end_layout

\begin_layout Description

\series bold
immediate
\series default
 Contiene il valore dell'operando immediato (nel range 
\begin_inset Formula $-2^{15}$
\end_inset

 e 
\begin_inset Formula $2^{15}-1$
\end_inset

 a causa del primo bit di segno)
\end_layout

\begin_layout Subsubsection
Formato I per istruzioni di branch condizionale
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opcode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rt
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
address
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Description

\series bold
Opcode
\series default
 Identifica il tipo di istruzione branch
\end_layout

\begin_layout Description

\series bold
rs
\series default
 Primo registro da comparare
\end_layout

\begin_layout Description

\series bold
rt
\series default
 Secondo registro da comparare
\end_layout

\begin_layout Description

\series bold
address
\series default
 Indica l'offset di parole relative alla posizione del program counter (PC-relat
ive word address)
\end_layout

\begin_layout Subsubsection
Formato J per i Jump incondizionati
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opcode
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
address
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
26 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Description

\series bold
Opcode
\series default
 Identifica il tipo di istruzione Jump
\end_layout

\begin_layout Description

\series bold
address
\series default
 Contiene i 26 bit più significativi dei 32 dell'indirizzo assoluto della
 parola di memoria
\end_layout

\begin_layout Subsection
Esecuzione delle istruzioni MIPS
\end_layout

\begin_layout Standard
Ogni istruzione del subset MIPS può essere implementata in 
\series bold
\bar under
al massimo 5 cicli di clock
\series default
\emph on
 
\emph default
\bar default
come segue:
\end_layout

\begin_layout Enumerate

\series bold
Instruction Fetch Cycle
\series default
 (
\series bold
IF
\series default
):
\end_layout

\begin_deeper
\begin_layout Enumerate
Invia il contenuto del 
\emph on
program counter
\emph default
 register alla 
\emph on
instruction memory
\emph default
 e legge l'istruzione corrente.
\end_layout

\begin_layout Enumerate

\emph on
Aggiorna il program counter
\emph default
 aggiungendo 4 all'indirizzo corrente (ogni istruzione sono 4 Bytes = 32
 bits)
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Instruction Decode and Register Read Cycle 
\series default
(
\series bold
ID
\series default
)
\end_layout

\begin_deeper
\begin_layout Enumerate

\emph on
Decodifica
\emph default
 l'istruzione corrente e 
\emph on
legge i vari registri
\bar under
 
\emph default
\bar default
specificati nell'istruzione.
 La lettura avviene dal register file.
\end_layout

\begin_layout Enumerate
L'
\emph on
estensione del segno
\emph default
 nel campo offset dell'istruzione viene fatta in questo punto
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Execution Cycle
\series default
 (
\series bold
EX
\series default
)
\end_layout

\begin_deeper
\begin_layout Enumerate
La ALU opera sugli operandi preparati nei cicli precedenti a seconda del
 tipo di istruzione:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Register-Register ALU Instructions
\series default
: L'ALU esegue le operazioni specificate dagli operandi
\end_layout

\begin_layout Itemize

\series bold
Register-Immediate ALU Instructions
\series default
: L'ALU esegue l'operazione sul primo operando
\end_layout

\begin_layout Itemize

\series bold
Memory Reference
\series default
: L'ALU aggiunge il registro base e l'offset per calcolare l'indirizzo effettivo
\end_layout

\begin_layout Itemize

\series bold
Conditional branches
\series default
: Vengono comparati i due registri specificati e computati possibili indirizzi
 di salto (
\series bold
Branch Target Address
\series default
) aggiungendo l'estensione del segno al PC.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
Memory Access 
\series default
(
\series bold
ME
\series default
)
\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
Le istruzioni di LOAD richiedono un 
\emph on
accesso in lettura alla Data Memory
\emph default
 utilizzando l'indirizzo effettivo
\end_layout

\begin_layout Enumerate
Le istruzioni di STORE richiedono un 
\emph on
accesso in scrittura alla Data Memory 
\emph default
utilizzando l'indirizzo effettivo per scrivere i dati dall'indirizzo sorgente
\end_layout

\begin_layout Enumerate
I branch condizionali possono 
\emph on
aggiornare il 
\emph default
contenuto del 
\emph on
Program Counter 
\emph default
con i branch target address, se il risultato è 
\emph on
true
\end_layout

\begin_layout Standard
Questa fase di memory access non è presente in tutte le istruzioni! Alcune
 non hanno bisogno di questa fase.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Write Back Cycle
\series default
 (
\series bold
WB
\series default
):
\end_layout

\begin_deeper
\begin_layout Enumerate
Le istruzioni di LOAD scrivono i dati letti dalla memoria nel registro di
 destinazione
\end_layout

\begin_layout Enumerate
Le istruzioni ALU scrivono i risultati della ALU nel registro di destinazione
\end_layout

\end_deeper
\begin_layout Subsection
Dettagli tecnici delle istruzioni MIPS
\end_layout

\begin_layout Subsubsection
Latenza delle istruzioni
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tipo di istruzione
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Instruct.
 Mem.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Register read
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
ALU op.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Data Memory
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Write Back
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Total Latency
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
ALU Instr.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 ns
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Load
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 ns
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Store
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7 ns
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Cond.Branch
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 ns
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Jump
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 ns
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Operazioni MIPS riassunte fase per fase
\end_layout

\begin_layout Itemize

\series bold
ALU instructions:
\end_layout

\begin_deeper
\begin_layout Itemize
IF: Fetch e incremento PC
\end_layout

\begin_layout Itemize
ID: Lettura dei registri sorgente ed eventuale estensione di segno dell'offset
\end_layout

\begin_layout Itemize
EX: Operazione ALU sui dati
\end_layout

\begin_layout Itemize
ME:
\end_layout

\begin_layout Itemize
WB: Scrittura del risultato nel register file
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
LOAD instructions
\series default
:
\end_layout

\begin_deeper
\begin_layout Itemize
IF: Fetch e incremento PC
\end_layout

\begin_layout Itemize
ID: Lettura del registro base
\end_layout

\begin_layout Itemize
EX: Operazione di ALU per somma degli indirizzi
\end_layout

\begin_layout Itemize
ME: Operazione di lettura da memoria del valore
\end_layout

\begin_layout Itemize
WB: Scrittura del valore letto nel register file
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
STORE instructions
\series default
:
\end_layout

\begin_deeper
\begin_layout Itemize
IF: Fetch e incremento PC
\end_layout

\begin_layout Itemize
ID: Lettura del registro base e valore sorgente 
\end_layout

\begin_layout Itemize
EX: Operazione di ALU per somma degli indirizzi
\end_layout

\begin_layout Itemize
ME: Scrittura in memoria del valore
\end_layout

\begin_layout Itemize
WB: 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Conditional branch instructions
\series default
:
\end_layout

\begin_deeper
\begin_layout Itemize
IF: Fetch e incremento PC
\end_layout

\begin_layout Itemize
ID: Lettura dei due registri da confrontare
\end_layout

\begin_layout Itemize
EX: Operazione ALU di confronto e somma del program counter in caso di branch
\end_layout

\begin_layout Itemize
ME: Scrittura del PC (non è nel register file)
\end_layout

\begin_layout Itemize
WB: 
\end_layout

\end_deeper
\begin_layout Subsubsection
Schema delle implementazioni
\end_layout

\begin_layout Paragraph
Implementazione base del data path MIPS
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/001.svg
	scale 50

\end_inset


\end_layout

\begin_layout Itemize
La 
\series bold
instruction memory
\series default
 (read-only memory) è separata dalla 
\series bold
data memory
\end_layout

\begin_layout Itemize
I 32 registri 
\emph on
general purpose
\emph default
 sono organizzati in un 
\series bold
register file
\series default
 (
\series bold
RF
\series default
) con due porte in lettura e una porta in scrittura
\end_layout

\begin_layout Paragraph
Implementazione della fase di Instruction Fetch
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/002.svg
	scale 40

\end_inset


\end_layout

\begin_layout Paragraph
Implementazione delle istruzioni ALU
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/003.svg
	scale 35

\end_inset


\end_layout

\begin_layout Paragraph
Implementazione delle istruzioni LOAD/STORE
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/004.svg
	scale 35

\end_inset


\end_layout

\begin_layout Paragraph
Implementazione dei branch condizionali
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/005.svg
	scale 40

\end_inset


\end_layout

\begin_layout Paragraph
Implementazione del data path MIPS
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/006.svg
	scale 40

\end_inset


\end_layout

\begin_layout Paragraph
Implementazione del data path MIPS con unità di controllo
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/007.svg
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection
Implementazione multi-cycle
\end_layout

\begin_layout Itemize
Abbiamo detto che l'esecuzione di una istruzione viene distribuita su più
 cicli (5 per MIPS)
\end_layout

\begin_layout Itemize
Il ciclo base è lungo 
\begin_inset Formula $5\, ns$
\end_inset

, quindi la durata massima di una istruzione è 
\begin_inset Formula $10\, ns$
\end_inset


\end_layout

\begin_layout Itemize
Implementazione di una CPU multi-cycle:
\end_layout

\begin_deeper
\begin_layout Itemize
Ogni fase della esecuzione di una istruzione richiede un ciclo di clock
\end_layout

\begin_layout Itemize
Ogni modulo può essere utilizzato più di una volta per ogni istruzione in
 diversi cicli di clock.
 
\series bold
Quindi
\series default
 è possibile 
\series bold
condividere dei moduli
\series default
.
\end_layout

\begin_layout Itemize
Abbiamo bisogno di registri interni per salvare i valori da utilizzare nei
 cicli di clock seguenti.
\end_layout

\end_deeper
\begin_layout Subsection
Pipelining
\end_layout

\begin_layout Standard
È una tecnica per l'ottimizzazione delle performance, basata sulla sovrapposizio
ne dell'esecuzione di istruzioni multiple derivanti da un flusso di esecuzione
 sequenziale.
\end_layout

\begin_layout Standard
Il pipelining 
\bar under
utilizza il parallelismo tra le istruzioni in uno stream sequenziale
\bar default
.
\end_layout

\begin_layout Itemize

\series bold
Idea base:
\series default
 L'esecuzione di una istruzione viene divisa in più fasi (pipeline stages)
 che richiedono una frazione del tempo necessario per completare l'istruzione.
\end_layout

\begin_layout Itemize
Gli stages sono collegati tra di loro dalla pipeline: l'istruzione entra
 nella pipeline da una parte, passa per vari stages e esce dall'altra parte,
 come su una catena d'assemblaggio.
\end_layout

\begin_layout Itemize

\series bold
Vantaggio
\series default
: È una tecnica di 
\begin_inset Quotes eld
\end_inset

parallelismo
\begin_inset Quotes erd
\end_inset

 trasparente al programmatore.
\end_layout

\begin_layout Itemize
Come su una catena d'assemblaggio di automobili, in un ciclo entra una automobil
e e ne esce una nuova, non modifichiamo il tempo necessario per completare
 una automobile, ma aumentiamo il numero di automobili prodotte simultaneamente
 e la frequenza per completarle.
\end_layout

\begin_layout Subsubsection
Esecuzione sequenziale vs.
 pipelining
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
IF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
EX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
ME
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instruction Fetch
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instruction Decode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Execution
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Memory Access
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write Back
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/008.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
I vari stage della pipeline 
\bar under
devono
\bar default
 essere 
\series bold
sincronizzati
\series default
: la durata di un ciclo di clock è definita dal tempo necessario allo stage
 più lento della pipeline.
\end_layout

\begin_layout Itemize
Se gli stages sono perfettamente bilanciati, lo 
\series bold
speedup ideale
\series default
 che otteniamo ad utilizzare la pipeline invece dell'esecuzione sequenziale
 è pari al numero di stage da attraversare (in questo caso 5, quindi x5).
\end_layout

\begin_layout Itemize
Se consideriamo una CPU senza pipelining, con ciclo di clock di 8 ns e la
 CPU2 con 5 stages da 2ns:
\end_layout

\begin_deeper
\begin_layout Itemize
La 
\series bold
latenza
\series default
 di ogni istruzione peggiora (da 8 a 10 ns)
\end_layout

\begin_layout Itemize
Però il 
\series bold
throughput
\series default
 (numero di istruzioni completate nell'unità di tempo) aumenta di 4 volte
\end_layout

\end_deeper
\begin_layout Itemize
Se consideriamo una CPU senza pipelining, con 5 cicli di clock di 2 ns e
 la CPU2 con 5 stages da 2ns:
\end_layout

\begin_deeper
\begin_layout Itemize
La 
\series bold
latenza
\series default
 di ogni istruzione 
\bar under
resta invariata
\end_layout

\begin_layout Itemize
Il 
\series bold
throughput
\series default
 (numero di istruzioni completate nell'unità di tempo) aumenta di 5 volte
\end_layout

\end_deeper
\begin_layout Subsubsection
Le varie fasi della pipeline riviste per i vari tipi di istruzione
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/009.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection
Implementazione della pipeline MIPS
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/010.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Paragraph
Schema di utilizzo delle risorse nella pipeline
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/011.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
IM = Instruction Memory
\end_layout

\begin_layout Itemize
REG = Register File
\end_layout

\begin_layout Itemize
DM = Data Memory
\end_layout

\begin_layout Subsection
Hazards (pericoli)
\end_layout

\begin_layout Subsubsection
Il problema
\end_layout

\begin_layout Itemize
Un 
\emph on
hazard
\emph default
 viene creato quando c'è una dipendenza tra istruzioni, le istruzioni sono
 vicine e quindi la pipeline cambia l'ordine di accesso agli operandi coinvolti
 nella dipendenza (compromettendo il risultato)
\end_layout

\begin_layout Itemize
L'
\emph on
hazard
\emph default
 impedisce alla prossima istruzione della pipeline di essere eseguita nel
 suo ciclo di clock previsto
\end_layout

\begin_layout Itemize
Gli 
\emph on
hazards
\emph default
 
\series bold
riducono le performance
\series default
 dello speedup ideale guadagnato dalla pipeline.
\end_layout

\begin_layout Paragraph
Tipi di hazards
\end_layout

\begin_layout Itemize

\series bold
Structural Hazards
\series default
: Tentativo di utilizzare la stessa risorsa da diverse istruzioni simultaneament
e
\end_layout

\begin_deeper
\begin_layout Itemize
Ad esempio: memoria singola per istruzioni e dati
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Data Hazards
\series default
: Tentativo di utilizzare un risultato prima che sia pronto
\end_layout

\begin_deeper
\begin_layout Itemize
Ad esempio: istruzione dipendente dal risultato di una precedente istruzione
 ancora in pipeline
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Control Hazards
\series default
: Tentativo di fare una decisione riguardo alla prossima istruzione da eseguire,
 prima che la condizione sia valutata
\end_layout

\begin_layout Subsubsection
Structural Hazards
\end_layout

\begin_layout Standard
Non ce ne sono nella architettura MIPS:
\end_layout

\begin_layout Itemize
La 
\emph on
instruction memory
\emph default
 è separata dalla 
\emph on
data memory.
\end_layout

\begin_layout Itemize
Il register file è utilizzato nello stesso ciclo di clock: Accesso in lettura
 da parte di una istruzione e accesso in scrittura da parte di un'altra
 istruzione.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/011.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection
Data Hazards: introduzione
\end_layout

\begin_layout Standard
Se le istruzioni eseguite nella pipeline sono 
\series bold
dipendenti
\series default
, ci possono essere data hazards nel caso in cui siano troppo vicine fra
 loro.
\end_layout

\begin_layout Standard
Esempio:
\end_layout

\begin_layout LyX-Code
sub $2, $1, $3      # Reg.
 $2 scritto da sub
\end_layout

\begin_layout LyX-Code
and $12, $2, $5     # 1° operando ($2) dipende da un sub
\end_layout

\begin_layout LyX-Code
or $13, $6, $2      # 2° operando ($2) dipende da un sub
\end_layout

\begin_layout LyX-Code
add $14, $2, $2     # 1° ($2) & 2° ($2) dipende da un sub
\end_layout

\begin_layout LyX-Code
sw $15, 100($2)     # Registro base ($2) dipende da un sub
\end_layout

\begin_layout Standard
La situazione risulta abbastanza chiara dalla figura seguente.
 Le prime tre dipendenze costituiscono un problema in quanto richiedono
 che sia pronto un dato che la pipeline sta ancora lavorando.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/013.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection
Data Hazards: Possibili soluzioni
\end_layout

\begin_layout Itemize

\series bold
Compilation Techniques 
\series default
(in fase di compilazione):
\end_layout

\begin_deeper
\begin_layout Itemize
Inserire delle istruzioni 
\series bold
NOP
\series default
 (
\series bold
n
\series default
o 
\series bold
op
\series default
eration)
\end_layout

\begin_layout Itemize
Fare scheduling delle istruzioni (scambiare l'ordine etc...) per evitare che
 istruzioni correlate siano troppo vicine
\end_layout

\begin_deeper
\begin_layout Itemize
Il compilatore tenta di inserire istruzioni indipendenti tra quelle correlate
\end_layout

\begin_layout Itemize
Quando il compilatore non trova istruzioni indipendenti, inserisce 
\series bold
NOP
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Hardware Techniques
\series default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Inserimento di 
\begin_inset Quotes eld
\end_inset

bubbles
\begin_inset Quotes erd
\end_inset

 o 
\emph on
stalls 
\emph default
(stalli) nella pipeline.
\end_layout

\begin_layout Itemize
Data 
\emph on
forwarding
\emph default
 o 
\emph on
bypassing
\emph default
.
\end_layout

\end_deeper
\begin_layout Paragraph
Inserimento di NOPs
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/014.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Paragraph
Scheduling
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/015.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Paragraph
Inserimento di 
\emph on
stalls
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/016.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection
Forwarding
\end_layout

\begin_layout Standard
Il data forwarding utilizza risultati temporanei memorizzati nei registri
 della pipeline invece di aspettare il write back dei risultati nel register
 file.
\end_layout

\begin_layout Standard
Quindi con il forwarding abbiamo la possibilità di passare informazioni
 da uno stadio della pipeline ad un altro 
\series bold
direttamente
\series default
, senza aspettare che il dato venga riscritto (e riletto) tramite il register
 file (esterno alla pipeline).
\end_layout

\begin_layout Standard
Dobbiamo aggiungere multiplexers agli inputs dell'ALU per prendere input
 dai registri della pipeline per evitare l'inserimento di stalli.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/017.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/018.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Ci sono tre forwarding paths:
\end_layout

\begin_layout Itemize
EX / EX path
\end_layout

\begin_layout Itemize
MEM / EX path
\end_layout

\begin_layout Itemize
MEM / ID path
\end_layout

\begin_layout Paragraph
Implementazione di MIPS con la forwarding unit
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/019.svg
	scale 45

\end_inset


\end_layout

\begin_layout Paragraph
Esempi di Data Hazards: il caso Load/Use
\end_layout

\begin_layout Standard
Un tipico esempio di Data Hazard è il 
\emph on
load/use hazard
\emph default
: rientrano in questa categoria tutti gli schedule in cui l'utilizzo di
 un registro avviene poco dopo la sua inizializzazione tramite load.
 Le immagini che seguono mostrano esempi di questa situazione.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/020.svg
	lyxscale 50
	scale 35

\end_inset


\end_layout

\begin_layout Standard
Facendo forwarding utilizzando il percorso MEM / EX è 
\series bold
necessario 1 stallo
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/021.svg
	lyxscale 50
	scale 35

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/022.svg
	lyxscale 50
	scale 35

\end_inset


\end_layout

\begin_layout Standard
Con un forwarding su MEM / MEM path si risolve:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/023.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Paragraph
Schema riassuntivo 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/024.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Standard
I percorsi di forwarding sono:
\end_layout

\begin_layout Itemize
EX / EX
\end_layout

\begin_layout Itemize
MEM / EX
\end_layout

\begin_layout Itemize
MEM / ID
\end_layout

\begin_layout Itemize
MEM / MEM (per LOAD/STORE)
\end_layout

\begin_layout Subsubsection
Ottimizzazione della pipeline
\end_layout

\begin_layout Itemize
Il register file viene utilizzato in due stages: Accesso in read durante
 fase ID e accesso in write durante la fase WB
\end_layout

\begin_layout Itemize
Cosa succede se read e write si riferiscono allo stesso register nello 
\series bold
stesso
\series default
 ciclo di clock? È necessario 
\series bold
inserire una stall
\series default
.
\end_layout

\begin_layout Itemize
Pipeline ottimizzata: assumiamo che le read del register file accadono nella
 seconda metà del ciclo di clock e che le write del register file accadono
 nella prima metà del ciclo di clock.
\end_layout

\begin_deeper
\begin_layout Itemize
Potremmo aver bisogno di un clock a frequenza doppia di quello normale della
 pipeline
\end_layout

\begin_layout Itemize
Evitiamo così di dover inserire degli stalli.
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/025.svg
	lyxscale 50
	scale 45

\end_inset


\end_layout

\begin_layout Itemize
IM = Instruction Memory
\end_layout

\begin_layout Itemize
REG = Register File
\end_layout

\begin_layout Itemize
DM = Data Memory
\end_layout

\begin_layout Subsubsection
Data Hazards nella pipeline ottimizzata
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/026.svg
	lyxscale 50
	scale 45

\end_inset


\end_layout

\begin_layout Standard
In questo caso è necessario inserire 
\series bold
due
\series default
 stalli, oppure usare i forwarding paths
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/027.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
I forwarding paths sono:
\end_layout

\begin_deeper
\begin_layout Itemize
EX / EX path
\end_layout

\begin_layout Itemize
MEM / EX path
\end_layout

\begin_layout Itemize
MEM / MEM path (for LOAD/STOREs)
\end_layout

\end_deeper
\begin_layout Subsubsection
Classificazione dei Data Hazards (RAW - WAW - WAR)
\end_layout

\begin_layout Paragraph

\series bold
RAW - Read After Write
\series default
 
\end_layout

\begin_layout Standard
Istruzione 
\begin_inset Formula $n+1$
\end_inset

 tenta di leggere un registro sorgente scritto prima che l'istruzione 
\emph on
n
\emph default
 lo abbia scritto nel register file.
\end_layout

\begin_layout Itemize
Esempio:
\end_layout

\begin_deeper
\begin_layout LyX-Code
add $r1, $r2, $r3
\end_layout

\begin_layout LyX-Code
sub $r4, $r1, $r5
\end_layout

\end_deeper
\begin_layout Standard
Utilizzando il forwarding è sempre possibile risolvere questo conflitto
 senza introdurre stalls, eccetto per i load/use hazards 
\end_layout

\begin_layout Paragraph
WAW - Write After Write
\end_layout

\begin_layout Standard
L'istruzione 
\begin_inset Formula $n+1$
\end_inset

 tenta di scrivere un operando di destinazione prima che sia stato scritto
 dall'istruzione precedente 
\begin_inset Formula $n$
\end_inset

 .
\end_layout

\begin_layout Standard
Quindi le operazioni di write vengono eseguite nell'ordine sbagliato
\end_layout

\begin_layout Itemize
Questo tipo di hazard può presentarsi sula pipeline MIPS quando si estendono
 operazioni multi-ciclo per eseguire o accedere alla memoria dati.
\end_layout

\begin_layout Standard
Ad esempio, se assumiamo che la scrittura su registro delle istruzioni ALU
 avvenga nel quarto stage e che le istruzioni di LOAD richiedano 2 stages
 (MEM1 e MEM2) per accedere alla memoria dati, possiamo avere:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/028.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
Se assumiamo che le operazioni ALU floating point richiedano una esecuzione
 multi-ciclo, abbiamo:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/029.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Paragraph
WAR - Write After Read
\end_layout

\begin_layout Standard
L'istruzione 
\begin_inset Formula $n+1$
\end_inset

 tenta di scrivere un operando di destinazione prima che venga letto dall'istruz
ione precedente 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Standard
Quindi l'istruzione 
\begin_inset Formula $n$
\end_inset

 legge il valore sbagliato.
\end_layout

\begin_layout Itemize
Esempio:
\end_layout

\begin_deeper
\begin_layout LyX-Code
sw $y, 0($x)         # sw deve leggere $x
\end_layout

\begin_layout LyX-Code
addi $x, $x, 4       # addi scrive $x
\end_layout

\end_deeper
\begin_layout Standard
Gli hazards di tipo WAR non possono accadere nella pipeline MIPS perché
 le operazioni di read avvengono sempre nello stage ID, mentre le operazioni
 di write avvengono sempre nello stage WB
\end_layout

\begin_layout Itemize
Come prima, se assumiamo che la scrittura di registri delle istruzioni ALU
 avviene nel quarto stage e che abbiamo bisogno due stages per accedere
 alla memoria dati, alcune operazioni possono leggere gli operandi troppo
 tardi nella pipeline.
\end_layout

\begin_layout Subsection
Problemi di performance nella Pipeline
\end_layout

\begin_layout Standard
Come abbiamo visto la Pipeline aumenta il throughput ma non la latenza delle
 istruzioni.
 
\end_layout

\begin_layout Standard
In realtà il pipelining aumenta leggermente la latenza di tutte le istruzioni
 a causa di overhead e sbilanciamento tra le latenze delle istruzioni.
 
\end_layout

\begin_layout Subsubsection
Metriche base di Performance
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
IC=\text{Instruction Count}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\#Clock\, Cycles=IC\,+\,\#Stall\, Cycles\,+\,4
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
CPI\,=\, Clock\, Per\, Instruction\,=\,\frac{\#Clock\, Cycles}{IC}=\frac{\left(IC+\#Stall\, Cycles+4\right)}{IC}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
MIPS=\frac{f_{clock}}{\left(CPI\cdot10^{6}\right)}
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
MIPS
\series default
: Million Instructions Per Second, è una unità di misura delle performance
\end_layout

\begin_layout Paragraph
Esempio
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
IC=\text{Instruction Count}=5
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\#Clock\, Cycles=12
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
CPI\,=\,2.4
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
MIPS=208.3
\]

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/030.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection
Altre metriche di performance
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
IC_{\text{per iterazione}}=m
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\#Clock\, Cycles_{\text{per iterazione}}=IC_{\text{per iterazione}}+\#Stall\, Cycles_{\text{per iterazione}}+4
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
CPI_{\text{per iterazione}}=\frac{\left(IC_{\text{per iterazione}}+\#Stall\, Cycles_{\text{per iterazione}}+4\right)}{IC_{\text{per iterazione}}}=\frac{\left(m+k+4\right)}{m}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
MIPS_{\text{per iterazione}}=\frac{f_{clock}}{CPI_{\text{per iterazione}}\cdot10^{6}}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Metriche di performance asintotiche
\end_layout

\begin_layout Standard
Consideriamo 
\begin_inset Formula $n$
\end_inset

 iterazioni di un ciclo composto da 
\begin_inset Formula $m$
\end_inset

 istruzioni per iterazione che richiedono 
\begin_inset Formula $k$
\end_inset

 stalli per iterazione (nel seguito 
\begin_inset Formula $AS$
\end_inset

 starà per 
\begin_inset Quotes eld
\end_inset


\emph on
asintotico
\emph default

\begin_inset Quotes erd
\end_inset

):
\begin_inset Formula 
\[
IC_{AS}=Instruction\, Count_{AS}=m\cdot n
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\#Clock\, Cycles=IC_{AS}+\#Stall\, Cycles_{AS}+4
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
CPI_{AS}=lim_{n\rightarrow\infty}\frac{\left(IC_{AS}+\#Stall\, Cycles_{AS}+4\right)}{IC_{AS}}=\frac{\left(m+k\right)}{m}
\]

\end_inset


\begin_inset Formula 
\[
MIPS_{AS}=\frac{f_{clock}}{CPI_{AS}\cdot10^{6}}
\]

\end_inset


\end_layout

\begin_layout Standard
Il CPI ideale per un processore con pipeline sarebbe 1, ma gli stalli fanno
 degradare le performance, quindi abbiamo:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
CPI_{medio}PIPE\,=\, CPI\, Ideal+Pipe\, Stall\, Cycles_{\text{per istruzione}}=1+Pipe\, Stall\, Cycles_{\text{per istruzione}}
\]

\end_inset


\end_layout

\begin_layout Standard
I cicli di stallo per iterazione sono dovuti a structural hazards, data
 hazards, control hazards e memory stalls
\end_layout

\begin_layout Subsubsection
Speedup della pipeline
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Pipeline\, speedup\,=\frac{Avarage\, execution\, time_{\text{senza pipeline}}}{Avarage\, execution\, time_{\text{con pipeline}}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Pipeline\, speedup\,=\frac{Avarage\, CPI_{\text{senza pipeline}}}{Avarage\, CPI_{\text{con pipeline}}}\cdot\frac{Clock\, Cycle_{\text{senza pipeline}}}{Clock\, Cycle_{\text{con pipeline}}}
\]

\end_inset


\end_layout

\begin_layout Standard
Se ignoriamo l'overhead sul tempo di clock a causa del pipelining e assumiamo
 che i vari stage sono perfettamente bilanciati, il tempo di clock di due
 processori può essere uguale, quindi:
\begin_inset Formula 
\[
Pipeline\, speedup\,=\,\frac{Avarage\, CPI_{\text{senza pipeline}}}{1+Pipe\, Stalls\, per\, instruction}
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Caso semplice
\series default
: Tutte le istruzioni prendono lo stesso numero di cicli, che deve essere
 uguale al numero di stadi della pipeline (chiamata 
\emph on
profondità della pipeline
\emph default
):
\begin_inset Formula 
\[
Pipeline\, speedup\,=\,\frac{Pipeline\, depth}{1+Pipeline\, Stalls\, per\, instruction}
\]

\end_inset


\end_layout

\begin_layout Standard
Se non ci sono stalli nella pipeline (caso ideale), questo ci porta al risultato
 intuitivo che il pipelining può aumentare le performance man mano che aumenta
 la profondità della pipeline.
\end_layout

\begin_layout Itemize
Qual'è l'impatto di performance dei 
\series bold
branch condizionali
\series default
?
\begin_inset Formula 
\[
Pipeline\, speedup\,=\,\frac{Pipeline\, depth}{1+Pipe\, Stall\, Cycles\, per\, instruction\, due\, to\, branches}=\frac{Pipeline\, depth}{1+Branch\, Frequency\cdot Branch\, Penality}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Tecniche di predizione dei branch
\end_layout

\begin_layout Subsection
Istruzioni di branch condizionali
\end_layout

\begin_layout Standard
Il branch viene preso soltanto se una certa 
\series bold
condizione 
\series default
viene 
\series bold
soddisfatta
\series default
.
\end_layout

\begin_layout Standard
L'
\series bold
indirizzo di destinazione
\series default
 del 
\emph on
branch
\emph default
 viene salvato nel 
\emph on
program counter
\emph default
 (PC) al posto dell'indirizzo dell'istruzione successiva (nello stream sequenzia
le di istruzioni).
\end_layout

\begin_layout Itemize

\series bold
Esempi
\series default
 di branch per il processore MIPS: 
\series bold
bne
\series default
 e 
\series bold
beq
\end_layout

\begin_deeper
\begin_layout LyX-Code
beq $s1, $s2, L1              # Vai a L1 se $s1 == $s2
\end_layout

\begin_layout LyX-Code
bne $s1, $s2, L1              # Vai a L1 se $s1 != $s2
\end_layout

\end_deeper
\begin_layout Standard
Abbiamo già visto com'è strutturata l'istruzione di branch in memoria (è
 una istruzione di tipo I).
 Le fasi per la sua esecuzione sono:
\end_layout

\begin_layout Itemize

\series bold
Fetch delle istruzioni e modifica di PC
\end_layout

\begin_layout Itemize

\series bold
Lettura dei registri dal register file
\end_layout

\begin_layout Itemize

\series bold
ALU operation
\series default
: per confrontare i registri e derivare il 
\series bold
\bar under
Branch Outcome
\series default
\bar default
 (branch 
\begin_inset Quotes eld
\end_inset

taken
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

not taken
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Itemize
Computazione del 
\series bold
\bar under
branch target address 
\series default
\bar default
(
\begin_inset Formula $PC+4+offset$
\end_inset

) (ricordiamoci che offset viene esteso in segno).
\end_layout

\begin_layout Itemize
Il valore di 
\series bold
PC viene scritto
\series default
.
\end_layout

\begin_layout Standard
Abbiamo già visto che in MIPS ogni istruzione si divide in 5 stages:
\end_layout

\begin_layout Enumerate

\series bold
IF - Instruction Fetch
\end_layout

\begin_layout Enumerate

\series bold
ID - Instruction Decode
\end_layout

\begin_layout Enumerate

\series bold
EX - Execution
\end_layout

\begin_layout Enumerate

\series bold
ME - Memory Access
\end_layout

\begin_layout Enumerate

\series bold
WB - Write Back
\end_layout

\begin_layout Standard
Nel caso della nostra istruzione di branch, il 
\series bold
\bar under
branch outcome
\series default
\bar default
 e il 
\series bold
\bar under
branch target address
\series default
\bar default
 saranno pronti alla fine dello stage EX (stage 3).
\end_layout

\begin_layout Standard
I branch condizionali vengono completati quando il PC è stato riscritto,
 nello stage 4.
\end_layout

\begin_layout Itemize

\series bold
Le risorse del processore per eseguire i branch condizionali
\series default
:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 031.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Implementazione della pipeline a 5 stage MIPS
\series default
:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 032.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection
Il problema dei control hazards
\end_layout

\begin_layout Standard
Un 
\series bold
\emph on
\bar under
control hazard
\series default
\emph default
\bar default
 è un tentativo di prendere una decisione sulla prossima istruzione da leggere
 prima che la condizione del branch venga valutata.
\end_layout

\begin_layout Itemize
I 
\emph on
control hazards
\emph default
 nascono quando branch condizionali e altre istruzioni che 
\series bold
modificano il valore di PC
\series default
 vengono messe all'interno della 
\series bold
pipeline
\end_layout

\begin_layout Itemize
I 
\emph on
control hazards 
\emph default
riducono le performance dallo speedup ideale guadagnato dal pipelining perché
 potrebbero rendere necessari degli stalli nella pipeline.
\end_layout

\begin_layout Standard
Per far funzionare la pipeline dobbiamo prendere una nuova istruzione ad
 ogni ciclo di clock, ma la decisione di branch (cambiare o non cambiare
 PC per la 
\series bold
\bar under
prossima
\series default
\bar default
 istruzione) viene presa durante lo stadio MEM (stadio 4).
\end_layout

\begin_layout Standard
Questo 
\series bold
ritardo
\series default
 per determinare la prossima istruzione è chiamato appunto 
\series bold
\emph on
control hazard
\series default
\emph default
 o 
\series bold
\emph on
conditional branch hazard
\series default
\emph default
.
\end_layout

\begin_layout Standard
Se il branch decide di cambiare il valore di PC si dice 
\series bold
\emph on
branch taken
\series default
\emph default
, altrimenti è un 
\series bold
\emph on
untaken
\series default
\emph default
.
\end_layout

\begin_layout Subsubsection*
Esempio
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 033.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
Nel momento in cui il branch decide se deve cambiare o non cambiare PC,
 ci sono già le 3 istruzioni seguenti caricate nella pipeline.
\end_layout

\begin_layout Itemize
Se il branch è 
\series bold
not taken
\series default
 non c'è nessun problema.
 Se però è taken ho già eseguito parte delle 3 istruzioni seguenti! Quindi
 è necessario fare un 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
flush
\series default
\emph default

\begin_inset Quotes erd
\end_inset

 delle successive 3 istruzioni 
\end_layout

\begin_layout Subsection
Soluzioni al problema del control hazard
\end_layout

\begin_layout Itemize
Assunzione 
\series bold
conservativa
\series default
: Metto in stallo la pipeline fino a quando la decisione non è stata presa
 (si chiama anche 
\series bold
\emph on
stalling until resolution
\series default
\emph default
) e poi prendo il flusso corretto di istruzioni
\end_layout

\begin_deeper
\begin_layout Itemize
Se utilizziamo il forwarding: lo faccio in 3 cicli di clock
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 035.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Senza forwarding: in 2 cicli di clock
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 034.png
	scale 30

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Se però il branch era 
\series bold
untaken
\series default
 abbiamo sprecato 3 preziosi cicli di clock che ci causano una grossa riduzione
 del throughput.
\end_layout

\begin_layout Itemize
Possiamo 
\series bold
\bar under
assumere
\series default
\bar default
 che il branch sia 
\series bold
untaken
\series default
 e fare flush delle successive 3 istruzioni solo se 
\series bold
\bar under
pensiamo
\series default
\bar default
 che sia 
\series bold
taken
\series default
.
\end_layout

\begin_layout Subsubsection
Early evaluation del PC
\end_layout

\begin_layout Standard
Per aumentare le performance nel caso di hazards dovuti ai branch, dobbiamo
 aggiungere nuove risorse hardware per:
\end_layout

\begin_layout Itemize
Confrontare registri per derivare il 
\series bold
\emph on
branch outcome
\series default
\emph default
 (risultato del branch)
\end_layout

\begin_layout Itemize
Computare il 
\series bold
\emph on
branch target address
\end_layout

\begin_layout Itemize
Aggiornare il registro PC
\end_layout

\begin_layout Standard
Tutte queste 3 operazioni devono essere fatte 
\series bold
\bar under
appena possibile
\series default
\bar default
 nella pipeline.
\end_layout

\begin_layout Standard
I processori MIPS comparano registri, computano indirizzi di branch e aggiornand
o il PC durante lo 
\series bold
stadio ID
\series default
.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 036.png
	scale 30

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Assunzione conservativa
\series default
: Ogni branch costa 
\bar under
uno stallo
\bar default
 per fetchare il corretto flusso di istruzioni
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 037.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Quali sono le conseguenze di fare questa 
\begin_inset Quotes eld
\end_inset


\emph on
early evaluation
\emph default

\begin_inset Quotes erd
\end_inset

 ?
\end_layout

\begin_deeper
\begin_layout Itemize
Nel caso della istruzione di 
\series bold
add
\series default
 (o 
\series bold
load
\series default
) seguita da una 
\series bold
branch
\series default
 che testa il risultato della add: dobbiamo introdurre uno stallo prima
 dello stadio ID del branch per permettere il forwarding del risultato dallo
 stadio EX della istruzione precedente.
\end_layout

\begin_layout Itemize

\series bold
Esempio
\series default
:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 038.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Con la decisione di branch fatta durante lo stadio ID c'è una 
\series bold
riduzione dei costi
\series default
 associati ad ogni branch (
\series bold
branch penalty
\series default
)
\end_layout

\begin_deeper
\begin_layout Itemize
Abbiamo bisogno 
\bar under
solo un ciclo di clock di stallo
\bar default
 dopo ogni branch
\end_layout

\begin_layout Itemize
Oppure il flush di 
\series bold
una
\series default
 sola istruzione che segue il branch
\end_layout

\end_deeper
\begin_layout Itemize
Il ritardo di un ciclo per ogni branch comporta comunque una perdita dal
 10% al 30% a seconda della frequenza del branch
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Pipeline\, stall\, cycles\, per\, instruction_{\text{a causa dei branch}}=Branch\, frequency\,\cdot\, Branch\, penality
\]

\end_inset


\end_layout

\begin_layout Itemize
Esamineremo alcune tecniche per affrontare questa perdita di performance
\end_layout

\end_deeper
\begin_layout Subsection
Tecniche di predizione dei branch
\end_layout

\begin_layout Standard
In generale il problema dei branch diventa più importante per processori
 con pipeline profonda perché il costo delle predizioni scorrette aumenta
 (i branch vengono risolti diversi stage dopo lo stadio ID).
\end_layout

\begin_layout Itemize

\series bold
Le performance 
\series default
delle tecniche di predizione di branch dipendono da:
\end_layout

\begin_deeper
\begin_layout Itemize
L'
\series bold
accuratezza
\series default
 misurata in termini di performance di predizioni scorrette date dal predittore
\end_layout

\begin_layout Itemize
Il 
\series bold
costo
\series default
 di una predizione scorretta misurata in termini di tempo perso per eseguire
 
\series bold
istruzioni inutili
\end_layout

\end_deeper
\begin_layout Itemize
Dobbiamo anche considerare la 
\series bold
frequenza dei branch
\series default
 all'interno del flusso di codice da eseguire.
 Ovviamente se ci sono poche branch per istruzione avremo poca perdita di
 performance.
\end_layout

\begin_layout Standard
Ci sono fondamentalmente 
\series bold
\bar under
due metodi di predizione
\series default
\bar default
 dei branch:
\end_layout

\begin_layout Itemize

\series bold
Tecniche di predizione 
\bar under
statica
\series default
\bar default
: A compile time decidiamo quale politica attuare in corrispondenza di ciascun
 branch
\end_layout

\begin_deeper
\begin_layout Itemize
Questo tipo di predizione viene utilizzata nei processori dove si riesce
 a prevedere l'esito dei branch a compile time
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Tecniche di predizione 
\bar under
dinamica
\series default
\bar default
: A runtime prendiamo decisioni sulle predizioni dei branch, che possono
 cambiare durante l'esecuzione del programma.
\end_layout

\begin_layout Standard
In entrambi i casi è necessario fare molta attenzione e tenersi pronti ad
 attuare una procedura di recovery quando l'esito effettivo del branch rivela
 una misprediction (predizione errata).
\end_layout

\begin_layout Subsubsection
Tecniche di predizione statica
\end_layout

\begin_layout Enumerate
Branch 
\series bold
always not taken
\series default
 (
\series bold
Predicted Not Taken
\series default
)
\end_layout

\begin_layout Enumerate
Branch 
\series bold
always taken 
\series default
(
\series bold
Predicted Taken
\series default
)
\end_layout

\begin_layout Enumerate

\series bold
Backward taken forward not taken
\series default
 (
\series bold
BTFNT
\series default
)
\end_layout

\begin_layout Enumerate

\series bold
Profile-Driven Prediction
\end_layout

\begin_layout Enumerate

\series bold
Delayed Branch
\end_layout

\begin_layout Paragraph
Branch always (not) taken
\end_layout

\begin_layout Standard
Assumiamo che il branch non sia mai taken, quindi lasciamo continuare il
 flusso di istruzioni come se la condizione di branch non fosse soddisfatta.
\end_layout

\begin_layout Itemize
Se la predizione è 
\series bold
corretta
\series default
 preserviamo le performance:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 039.png
	scale 30

\end_inset


\end_layout

\begin_layout Itemize
Se la predizione è 
\series bold
errata
\series default
: dobbiamo fare flush della prossima istruzione già fetchata (trasformiamo
 l'istruzione letta in precedenza in una NOP) e riavviamo l'esecuzione prendendo
 l'istruzione al 
\emph on
branch target address
\emph default
.
 Abbiamo quindi una 
\series bold
penalità di un ciclo
\series default
.
 Si ricorda che l'architettura MIPS implementa l'ottimizzazione Early Evaluation
 del PC.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 040.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
Uno schema alternativo è quello di considerare ogni branch come 
\series bold
taken
\series default
.
 
\end_layout

\begin_layout Standard
Non appena il branch target address viene computato, assumiamo il branch
 come 
\series bold
taken
\series default
 e iniziamo a fare fetch e esecuzione del branch target.
\end_layout

\begin_layout Subparagraph*
Note sulla Branch Always Taken
\end_layout

\begin_layout Itemize
Questo tipo di predizione 
\bar under
ha senso per pipelines dove il branch target address è noto prima di conoscere
 il risultato
\bar default
 del branch.
\end_layout

\begin_layout Itemize
Nella pipeline MIPS 
\series bold
non conosciamo 
\series default
il 
\emph on
branch target address
\series bold
 
\emph default
prima
\series default
 di conoscere il 
\series bold
branch outcome
\series default
.
 Quindi per MIPS questa tecnica non è utile.
\end_layout

\begin_layout Paragraph
Backward Taken Forward Not Taken (BTFNT)
\end_layout

\begin_layout Standard
La predizione viene fatta sulla 
\begin_inset Quotes eld
\end_inset


\emph on
direzione
\emph default

\begin_inset Quotes erd
\end_inset

 dei branch (cioè se l'indirizzo destinazione a cui puntano è prima o dopo
 l'indirizzo dell'istruzione attuale):
\end_layout

\begin_layout Itemize

\series bold
\emph on
backward-going branches
\series default
\emph default
: considerati 
\emph on
taken
\end_layout

\begin_layout Itemize

\series bold
\emph on
forward-going branches
\series default
\emph default
: considerati 
\emph on
not taken
\end_layout

\begin_layout Standard
L'idea alla base è che quando abbiamo dei branch che puntano 
\emph on
forward
\emph default
 stiamo eseguendo degli if e quindi stiamo valutando eccezioni nel codice
 che si presume vengano effettivamente eseguite meno di frequente; in presenza
 di branch che puntano 
\emph on
backward
\emph default
 significa che siamo all'interno di un loop
\begin_inset Foot
status open

\begin_layout Plain Layout
si ricorda che nella maggior parte dei casi anche i cicli con controllo
 in testa (while, for) vengono tradotti con cicli a controllo in coda
\end_layout

\end_inset

, e quindi (nella maggior parte dei casi), il branch sarà taken per proseguire
 il loop.
\end_layout

\begin_layout Paragraph
Profile-driven prediction
\end_layout

\begin_layout Standard
La tecnica profile-driven consiste nel raccogliere statistiche sul numero
 di volte che ciascun branch viene preso e non preso.
 A valle di questo profiling svolto su un sufficiente numero di simulazioni
 (o esecuzioni) del software ogni branch viene marcato con il valore di
 predizione più probabile.
\end_layout

\begin_layout Standard
Questo metodo può anche integrarsi con 
\begin_inset Quotes eld
\end_inset

consigli
\begin_inset Quotes erd
\end_inset

 del compilatore.
\end_layout

\begin_layout Paragraph
Delayed Branch Technique
\end_layout

\begin_layout Standard
Il compilatore riordina il codice e inserisce staticamente negli slot di
 
\begin_inset Quotes eld
\end_inset

delay
\begin_inset Quotes erd
\end_inset

 dei branch istruzioni indipendenti dal branch stesso, le quali vengono
 eseguite sia che il branch risulti taken sia che risulti untaken.
\end_layout

\begin_layout Itemize
Se assumiamo che il branch delay sia 1 ciclo (come nel caso di MIPS ottimizzato)
, abbiamo solo 1 slot di delay.
\end_layout

\begin_deeper
\begin_layout Itemize
In realtà è possibile avere processori con pipeline che utilizzano degli
 slot di delay più lunghi.
\end_layout

\begin_layout Itemize
Però quasi tutti i processori che utilizzano la tecnica di delayed branch
 hanno un singolo slot di delay.
 Ciò avviene perché è particolarmente difficile per il compilatore trovare
 più istruzioni da inserire in più di uno slot.
\end_layout

\end_deeper
\begin_layout Itemize
Il compilatore MIPS schedula sempre una istruzione indipendente dopo una
 istruzione di branch.
\end_layout

\begin_layout Itemize
Esempio: una istruzione di add viene schedulata dopo una istruzione beq,
 per essere eseguita nel 
\emph on
branch delay slot
\emph default
.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 041.png
	scale 30

\end_inset


\end_layout

\begin_layout Itemize
Ci sono 
\series bold
4 modi
\series default
 in cui il branch delay slot può essere schedulato dal compilatore:
\end_layout

\begin_deeper
\begin_layout Enumerate
From before
\end_layout

\begin_layout Enumerate
From target
\end_layout

\begin_layout Enumerate
From fall-through
\end_layout

\begin_layout Enumerate
From after
\end_layout

\end_deeper
\begin_layout Subparagraph
Delayed branch technique: from before
\end_layout

\begin_layout Standard
Il branch delay slot viene schedulato con una istruzione indipendente che
 era prima dell'istruzione bi branch.
\end_layout

\begin_layout Standard
L'istruzione nel branch delay slot viene sempre eseguita (perché in ogni
 caso la dobbiamo eseguire non essendo una istruzione che è dopo).
\end_layout

\begin_layout Itemize
Esempio:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 042.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Subparagraph
Delayed branch technique: from target
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 043.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
In questo caso non possiamo spostare l'istruzione di 
\series bold
add
\series default
 dopo l'if perché il risultato ($1) viene utilizzato per prendere decisioni
 sul branch.
 Però in questo caso possiamo mettere nel branch delay slot l'istruzione
 da eseguire in caso di branch taken se il branch target address è backward
 (come nel caso dei loop).
\end_layout

\begin_layout Subparagraph
Delayed branch technique: from fall-through
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 044.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
È la tecnica duale del 
\begin_inset Quotes eld
\end_inset


\emph on
from target
\emph default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Anche in questo caso non possiamo spostare l'istruzione di 
\series bold
add
\series default
 perché il branch utilizza $1 che è già presente nella add.
\end_layout

\begin_layout Standard
In questa strategia iniziamo ad eseguire il comando dopo il branch (quindi
 come se fosse a priori 
\series bold
not taken
\series default
).
 Questo è utile quando abbiamo alta probabilità di branch non presi.
\end_layout

\begin_layout Itemize
Per 
\series bold
\bar under
rendere l'ottimizzazione legale 
\series default
\bar default
nei casi 
\begin_inset Quotes eld
\end_inset

from target
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

from fall-through
\begin_inset Quotes erd
\end_inset

 deve essere consentito eseguire l'istruzione spostata quando il branch
 va nella direzione opposta a quella prevista.
 Per 
\begin_inset Quotes eld
\end_inset

consentito
\begin_inset Quotes erd
\end_inset

 intendiamo che l'istruzione inserita nel branch delay slot può essere eseguita
 ma il 
\begin_inset Quotes eld
\end_inset

lavoro
\begin_inset Quotes erd
\end_inset

 viene soltanto sprecato e il programma può continuare correttamente anche
 dopo aver eseguito quella istruzione inutile, ovvero l'istruzione nel delay
 slot non ha sporcato lo stato dell'esecuzione.
 Per esempio va bene se il registro destinazione dell'operazione inutile
 è un registro utilizzato solo nel ramo errato del flusso di esecuzione.
\end_layout

\begin_deeper
\begin_layout Itemize
In generale, i compilatori sono in grado di riempire circa il 50% dei delayed
 branch slots con istruzioni valide e utili.
 Gli slot rimanenti sono riempiti con operazioni 
\series bold
NOP
\series default
.
\end_layout

\begin_layout Itemize
Nelle pipelines più profonde il delayed branch è più lungo di un ciclo,
 quindi è necessario trovare altre istruzioni ed è ancora più difficile.
\end_layout

\end_deeper
\begin_layout Itemize
Le principali 
\series bold
limitazioni
\series default
 del delayed branch scheduling nascono da:
\end_layout

\begin_deeper
\begin_layout Itemize
Restrizioni sulle istruzioni che possiamo inserire nel branch delay slot.
\end_layout

\begin_layout Itemize
L'abilità del compilatore di predire staticamente il risultato dei branch.
\end_layout

\end_deeper
\begin_layout Itemize
Per migliorare le predizioni del compilatore molti processori hanno introdotto
 la 
\series bold
canceling 
\series default
o
\series bold
 
\series default

\begin_inset Quotes eld
\end_inset


\series bold
\emph on
nullifying branch
\series default
\emph default

\begin_inset Quotes erd
\end_inset

.
 In questo 
\bar under
tipo speciale di branch
\bar default
 l'istruzione include al suo interno anche un 
\bar under
bit che indica la direzione
\bar default
 in cui è previsto che il branch vada.
 Così facendo abbiamo che:
\end_layout

\begin_deeper
\begin_layout Itemize
Quando il branch agisce come previsto: l'istruzione nel branch delay slot
 è eseguita normalmente.
\end_layout

\begin_layout Itemize
Quando il branch non agisce come previsto: l'istruzione nel branch delay
 slot viene trasformata in una NOP.
\end_layout

\end_deeper
\begin_layout Itemize
L'architettura MIPS ha l'istruzione 
\series bold
branch-likely
\series default
 che si comporta come una branch 
\series bold
\emph on
cancel-if-not-taken
\series default
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize
L'istruzione nel branch delay slot viene eseguita se il branch è taken.
\end_layout

\begin_layout Itemize
L'istruzione nel branch delay slot non viene eseguita (viene trasformata
 in NOP) se il branch è untaken
\end_layout

\begin_layout Itemize
È un approccio utile per backward branches (come i branch utilizzati per
 nei loop)
\end_layout

\end_deeper
\begin_layout Subsubsection
Tecniche di predizione dinamica dei branch
\end_layout

\begin_layout Standard

\series bold
Idea base
\series default
: utilizzare i 
\bar under
comportamenti dei branch precedenti
\bar default
 per 
\bar under
prevedere il futuro
\bar default
.
\end_layout

\begin_layout Standard
Utilizziamo hardware per prevedere dinamicamente il risultato di un branch.
 La predizione dipenderà sul comportamento del branch a runtime e cambierà
 se il branch cambia il suo comportamento durante l'esecuzione.
\end_layout

\begin_layout Standard
Partiamo con uno schema di predizione di branch semplice e poi esaminiamo
 approcci che aumentano l'accuratezza.
\end_layout

\begin_layout Standard
I meccanismi principali di predizione sono due:
\end_layout

\begin_layout Itemize

\series bold
Branch outcome predictor
\series default
: per prevedere la direzione di un branch (taken o not taken)
\end_layout

\begin_layout Itemize

\series bold
Branch target predictor
\series default
 (BTP) o 
\series bold
branch target buffer
\series default
 : per prevedere il branch target address in caso di branch taken
\end_layout

\begin_layout Standard
Questi moduli sono utilizzati dall'unità di 
\emph on
instruction fetch
\emph default
 per prevedere la prossima istruzione da leggere nella cache delle istruzioni
 (I-cache)
\end_layout

\begin_layout Itemize
Se il branch è not taken → PC viene incrementato
\end_layout

\begin_layout Itemize
Se il branch è taken → BTP (il predittore) dà l'indirizzo di destinazione
\end_layout

\begin_layout Paragraph
Branch History Table - BHT (o Branch Prediction Buffer)
\end_layout

\begin_layout Standard
È una tabella che contiene 1 bit per ogni entry che dice se il branch è
 stato 
\series bold
taken
\series default
 recentemente o untaken.
 Questa tabella è indicizzata, come indice si usa la parte meno significativa
 del campo indirizzo dell'istruzione di branch.
\end_layout

\begin_layout Itemize
Predizione: abbiamo un indizio che si assume essere corretto e iniziamo
 a fare il fetch nella direzione prevista.
\end_layout

\begin_deeper
\begin_layout Itemize
Se scopriamo che la predizione era sbagliata, il bit di predizione viene
 invertito e ri-salvato.
 La pipeline viene ripulita e la sequenza corretta viene eseguita.
\end_layout

\end_deeper
\begin_layout Itemize
La tabella non ha tags (ogni accesso è un 
\begin_inset Quotes eld
\end_inset

HIT
\begin_inset Quotes erd
\end_inset

) e il bit di predizione può essere messo da un'altra branch con lo stesso
 indice, ma non importa.
 La predizione 
\series bold
fornisce solo una traccia
\series default
.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 045.png
	scale 40

\end_inset


\end_layout

\begin_layout Subparagraph

\series bold
Accuratezza della Branch History Table
\end_layout

\begin_layout Standard
Abbiamo una predizione errata quando: 
\end_layout

\begin_layout Itemize
la predizione è sbagliata per quel branch OPPURE 
\end_layout

\begin_layout Itemize
se lo stesso indice è stato utilizzato per due branch diversi.
 
\end_layout

\begin_layout Standard
Per risolvere il secondo problema è sufficiente aumentare il numero di righe
 nella tabella o utilizzare una buona funzione di hash.
\end_layout

\begin_layout Subparagraph

\series bold
Altri problemi si hanno
\end_layout

\begin_layout Itemize
In una branch che fa parte di un loop, poiché utilizziamo un solo bit per
 la tabella, abbiamo una predizione errata due volte quando il loop termina
 (invece di una volta sola).
\end_layout

\begin_layout Itemize
Nell'ultimo ciclo del loop, poiché la predizione dice 
\begin_inset Quotes eld
\end_inset

taken
\begin_inset Quotes erd
\end_inset

 mentre noi dobbiamo uscire dal loop.
\end_layout

\begin_layout Itemize
Quando ri-entriamo di nuovo nello stesso loop, sbagliamo di nuovo a prevedere
 il branch perché avevamo cambiato il bit quando eravamo usciti.
\end_layout

\begin_layout Standard
Sembra un problema trascurabile, ma se consideriamo che, per esempio, abbiamo
 2 predizioni scorrette e 8 corrette significa che l'accuratezza della predizion
e è solo dell'80%!
\end_layout

\begin_layout Subparagraph

\series bold
Modifica utilizzando 2 bit
\end_layout

\begin_layout Itemize
Se utilizziamo due bit invece di uno possiamo fare che per modificare la
 predizione sono necessari due 
\begin_inset Quotes eld
\end_inset

errori
\begin_inset Quotes erd
\end_inset

 invece di uno solo.
 
\end_layout

\begin_layout Itemize
In questo modo nel caso precedente del loop sbagliamo solo 1 volta la predizione
 → 90% di accuratezza.
\end_layout

\begin_layout Itemize
I due bit vengono utilizzati per memorizzare uno dei 4 stati di una macchina
 a stati finiti.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 046.png
	scale 40

\end_inset


\end_layout

\begin_layout Subparagraph

\series bold
Branch History Table a n-bit
\end_layout

\begin_layout Itemize
I valori vanno da 
\begin_inset Formula $0$
\end_inset

 a 
\begin_inset Formula $2^{n}-1$
\end_inset

.
 Quando il contatore rappresentato dagli 
\begin_inset Formula $n$
\end_inset

 bit è superiore o uguale a 
\begin_inset Formula $2^{n}-1$
\end_inset

, il branch viene previsto come 
\series bold
taken
\series default
, altrimenti 
\series bold
untaken
\end_layout

\begin_layout Itemize
Il contatore viene incrementato quando il branch è taken e decrementato
 quando il branch è untaken.
\end_layout

\begin_layout Itemize
Diversi studi su predittori a 
\emph on
n-bit
\emph default
 mostrano come il caso a 2-bit sia comunque sufficiente e abbastanza performante.
\end_layout

\begin_layout Paragraph
Correlare i predittori dei branch
\end_layout

\begin_layout Standard

\series bold
Idea:
\series default
 i comportamenti dei branch sono correlati, cioè c'è correlazione tra le
 varie branch oltre che tra la stessa branch.
\end_layout

\begin_layout Paragraph
Esempio
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 047.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
Il branch 
\series bold
bb3 
\series default
è correlato ai branch precedenti 
\series bold
bb1 
\series default
e
\series bold
 bb2
\series default
.
 Se i branch precedenti sono entrambi 
\emph on
not taken
\emph default
, allora 
\series bold
bb3
\series default
 sarà taken (a!=b).
\end_layout

\begin_layout Itemize
Questo tipo di predittori sono chiamati 
\series bold
\emph on
correlating branch predictors
\series default
\emph default
 o 
\series bold
\emph on
2-level predictors
\series default
\emph default
.
\end_layout

\begin_layout Itemize
Un 
\emph on
correlating predictor 
\emph default
(1,1) è un predittore ad 1 bit con 1 bit di correlazione.
 Il comportamento dell'ultimo branch è utilizzato per scegliere da quale
 predittore osservare la predizione finale.
\end_layout

\begin_layout Itemize
Esempio:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 048.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
Registro se gli ultimi 
\begin_inset Formula $k$
\end_inset

 branch sono stati taken o not taken.
\end_layout

\begin_layout Itemize
Il branch viene previsto in base a quello che è successo nel branch precedente
 selezionando appropriatamente un bit dalla tabella:
\end_layout

\begin_deeper
\begin_layout Itemize
Una predizione viene utilizzata se l'ultima branch eseguita (non necessariamente
 la stessa branch) era taken.
\end_layout

\begin_layout Itemize
L'altra predizione viene utilizzata se l'ultima branch eseguita (non necessariam
ente la stessa branch) era not taken.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Più in generale, un 
\emph on
correlating branch predictor
\emph default
 
\series bold
(m, n)
\series default
 registra le ultime 
\begin_inset Formula $m$
\end_inset

 branch in 
\begin_inset Formula $2^{m}$
\end_inset

Branch History Tables, ognuna delle quali è un predittore a 
\begin_inset Formula $n$
\end_inset

 bit.
 Il buffer di predizione dei branch può essere indirizzato utilizzando una
 concatenazione di bits meno significativi del branch address insieme con
 
\begin_inset Formula $m$
\end_inset

 bit della history globale (quindi delle ultime 
\begin_inset Formula $m$
\end_inset

 branch).
\end_layout

\begin_layout Itemize
Esempio: Correlating Branch Predictor (2,2): Abbiamo 
\begin_inset Formula $2^{2}=4$
\end_inset

 Branch History Tables da 2 bit ciascuna.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 049.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
64 entries, indice di 6 bit composto da 2 bit di history globale e 4 bit
 per la parte meno significativa dell'indirizzo del branch.
\end_layout

\begin_layout Itemize
Ogni BHT è composta da 16 entries di 2 bit ciascuna.
 Il branch address di 4 bit viene utilizzato per scegliere 4 entries (una
 riga).
\end_layout

\begin_layout Itemize
I 2 bit di history globale vengono utilizzati per scegliere una di 4 entries
 in una riga (una delle 4 BHTs).
\end_layout

\end_deeper
\begin_layout Itemize
Un predittore a 2 bit senza global history lo possiamo vedere come un predittore
 (0,2).
\end_layout

\begin_layout Paragraph

\series bold
Accuratezza dei correlating predictors
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 050.png
	scale 40

\end_inset


\end_layout

\begin_layout Paragraph
Two-level Adaptive Branch Predictors
\end_layout

\begin_layout Itemize
Il primo livello della history è registrato in uno o più registri da 
\begin_inset Formula $k$
\end_inset

 bit, chiamati 
\series bold
Branch History Register (BHR)
\series default
, che registra i risultati delle ultime 
\begin_inset Formula $k$
\end_inset

 branch.
\end_layout

\begin_layout Itemize
Il secondo livello di history è registrato in uno (o più) tabelle chiamate
 
\series bold
Pattern History Table (PHT)
\series default
, di contatori a 2 bit
\end_layout

\begin_layout Itemize
La BHR viene utilizzata per indirizzare il PHT per selezionare quale contatore
 a 2 bit utilizzare.
\end_layout

\begin_layout Itemize
Una volta che il contatore a 2 bit viene selezionato, la predizione viene
 fatta con lo stesso metodo come nello schema del contatore a 2 bit.
\end_layout

\begin_layout Paragraph
Global Adaptive Predictor
\end_layout

\begin_layout Itemize

\series bold
BHT
\series default
: Predittore locale
\end_layout

\begin_deeper
\begin_layout Itemize
Indirizzato dai bit meno significativi del PC (branch address)
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
GAs
\series default
: Predittore locale e globale
\end_layout

\begin_deeper
\begin_layout Itemize
Predittore a 2 livelli: PHT indirizzata dal contenuto di BHR (history globale)
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 051.png
	scale 30

\end_inset


\end_layout

\begin_layout Itemize

\series bold
GShare
\series default
: Local XOR Global information
\end_layout

\begin_deeper
\begin_layout Itemize
È indirizzato dallo 
\series bold
XOR
\series default
 tra i bit meno significativi del PC (
\series bold
branch address
\series default
) e il contenuto di 
\series bold
BHR
\series default
 (history globale)
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 052.png
	scale 30

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Paragraph
Branch Target Buffer
\end_layout

\begin_layout Standard

\series bold
BTB - 
\series default
Branch Target Buffer (Branch Target Predictor) è una cache che memorizza
 il target address previsto per la prossima istruzione dopo il branch.
\end_layout

\begin_layout Itemize
Possiamo accedere al BTB nello stadio IF utilizzando l'indirizzo istruzione
 dell'istruzione fetchata (un possibile branch) come indice per questa cache.
\end_layout

\begin_layout Itemize
la tipica entry del BTB è:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Exact Address of a Branch
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Predicted Target Address
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
predicted target address è espresso relativamente al PC.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Struttura del Branch Target Buffer
\series default
:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 053.png
	scale 40

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Nella BTB dobbiamo memorizzare il target address previsto solo per i branch
 taken
\begin_inset Note Note
status open

\begin_layout Plain Layout
Perché? Se non presente suppongo Not Taken (?)
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
La entry della BTB è: 
\series bold
tag + Target address previsto
\series default
 (PC-relative) + 
\series bold
Bits per lo stato di predizione
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 054.png
	scale 40

\end_inset


\end_layout

\end_deeper
\begin_layout Paragraph
Commenti sulla branch prediction
\end_layout

\begin_layout Standard
Senza la branch prediction, la quantità di parallelismo è abbastanza limitata
 poiché è possibile agire solo all'interno di un singolo 
\series bold
basic block
\series default
, cioè un pezzo di codice privo di branches.
\end_layout

\begin_layout Standard
Le tecniche di predizione di branch ci aiutano a migliorare il parallelismo.
 Nei metodi di predizione che abbiamo mostrato, facciamo fetch, issue ed
 execute di istruzioni successive come se le predizioni fossero sempre corrette,
 avendo però sempre pronto un metodo per risolvere le situazioni di predizione
 errata.
\end_layout

\begin_layout Standard
Queste speculazioni possono essere supportate dal 
\series bold
compilatore
\series default
 o dall'
\series bold
hardware
\series default
.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
ILP
\end_layout

\begin_layout Section
Instruction Level Parallelism
\end_layout

\begin_layout Subsection
Portare il parallelismo a livello di istruzione
\end_layout

\begin_layout Standard
In una macchina dotata di pipeline, il CPI viene derivato come: 
\begin_inset Formula 
\[
CPI_{pipeline}=CPI_{ideale}+\text{Structural Stalls}+\text{Data Hazards Stalls}+\text{Control Stalls}+\text{Memory Stalls}
\]

\end_inset


\end_layout

\begin_layout Itemize
La riduzione di qualunque termine a destra ci permette di rendere 
\begin_inset Formula $CPI_{pipeline}$
\end_inset

 sempre più vicino a 
\begin_inset Formula $CPI_{ideale}$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
Aumentiamo le istruzioni per clock: 
\begin_inset Formula $IPC=\frac{1}{CPI}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Caso migliore:
\series default
 il throughput massimo dovrebbe essere di una istruzione per clock: 
\begin_inset Formula $IPC_{ideal}=1$
\end_inset

 e 
\begin_inset Formula $CPI_{ideal}=1$
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 055.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection
Riassunto sulla pipeline
\end_layout

\begin_layout Itemize
Gli Hazards limitano le performance
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Hazards strutturali
\series default
: risolviamo con più 
\bar under
risorse hardware
\end_layout

\begin_layout Itemize

\series bold
Hazards dati
\series default
: risolviamo con il 
\bar under
forwarding
\bar default
 e 
\bar under
compiler scheduling
\bar default
.
\end_layout

\begin_layout Itemize

\series bold
Hazards controllo
\series default
: 
\bar under
early evaluation
\bar default
, 
\bar under
branch delay slot
\bar default
, 
\bar under
static branch prediction
\bar default
, 
\bar under
dynamic branch prediction
\bar default
.
\end_layout

\end_deeper
\begin_layout Itemize
Aumentare la lunghezza della pipeline aumenta l'impatto degli hazards
\end_layout

\begin_layout Itemize
La pipeline ci aiuta ad 
\series bold
aumentare il throughput, 
\bar under
non la latenza
\series default
\bar default
.
\end_layout

\begin_layout Subsubsection
Riassunto tipi di Data hazards
\end_layout

\begin_layout Standard
Data una sequenza di istruzioni
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
r_{k}\leftarrow\left(r_{i}\right)\: op\:\left(r_{j}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
Determiniamo i vari tipi di dipendenze che esistono tra di esse:
\end_layout

\begin_layout Description
Data-dependence la seconda istruzione deve aspettare il risultato della
 prima per avere il valore del registro operando.
 Può causare un 
\series bold
RAW hazard
\series default
.
\end_layout

\begin_layout Description
Anti-dependence la prima istruzione utilizza come operando un registro che
 viene usato come destinazione dall'istruzione successiva.
 La prima istruzione deve leggere il registro prima che venga sovrascritto.
 Può causare un 
\series bold
WAR hazard
\series default
.
\end_layout

\begin_layout Description
Output-dependence due istruzioni scrivono sullo stesso registro destinazione.
 Deve essere mantenuto l'ordine di commit delle istruzioni.
 Può causare un 
\series bold
WAW hazard
\series default
.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 056.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection
Evoluzioni della pipeline
\end_layout

\begin_layout Paragraph
Complex pipelining
\end_layout

\begin_layout Standard
Aggiungendo risorse hardware per parallelizzare ulteriormente arriviamo
 a uno schema di questo tipo
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 057.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
Unità floating point con alta latenza o 
\begin_inset Quotes eld
\end_inset

parzialmente pipelined
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Diverse funzioni e unità di memoria
\end_layout

\begin_layout Itemize
Sistemi di memoria con tempo di accesso variabile
\end_layout

\begin_layout Paragraph
Complex In-order Pipeline
\end_layout

\begin_layout Standard
Il precedente schema non garantisce l'
\emph on
in-order commit
\emph default
.
 Aggiungiamo quindi uno stadio allo schema
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 058.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Delay writeback
\series default
 di modo che tutte le operazioni abbiano la stessa latenza nello stage 
\series bold
W
\end_layout

\begin_deeper
\begin_layout Itemize
Le porte di write non sono mai affollate (una istanza in e una istanza out
 per ogni ciclo)
\end_layout

\begin_layout Itemize
Le istruzioni vengono inviate in ordine (di modo da gestire le eccezioni
 in modo preciso)
\end_layout

\end_deeper
\begin_layout Subsubsection
Altri concetti base e definizioni
\end_layout

\begin_layout Itemize
Per raggiungere le performance più elevate (per una data tecnologia), maggior
 parallelismo deve essere estratto dal programma.
 In altre parole: 
\series bold
\bar under
multiple-issue
\end_layout

\begin_layout Itemize
Le dipendenze devono essere individuate e risolte e le istruzioni devono
 essere riordinate (
\series bold
scheduled
\series default
) in modo da ottenere il parallelismo di istruzioni eseguibili più elevato
 possibile con le risorse a disposizione.
\end_layout

\begin_layout Paragraph

\series bold
Instruction Level Parallelism
\end_layout

\begin_layout Description

\series bold
ILP Instruction Level Parallelism
\series default
.

\series bold
 
\series default
\emph on
\bar under
Sfruttare potenziali overlap di esecuzione tra istruzioni non correlate
 tra loro
\series bold
.
\end_layout

\begin_layout Standard
L'overlapping è possibile solo quando:
\end_layout

\begin_layout Itemize
Non ci sono hazards strutturali
\end_layout

\begin_layout Itemize
Non ci sono hazards RAW, WAR o WAW.
\end_layout

\begin_layout Itemize
Non ci sono control hazards.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 059.png
	scale 40

\end_inset


\end_layout

\begin_layout Paragraph
2-issue MIPS Pipeline architecture
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 060.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
Due istruzioni inviate per clock:
\end_layout

\begin_deeper
\begin_layout Itemize
1 istruzione ALU o BR
\end_layout

\begin_layout Itemize
1 istruzione LOAD/STORE
\end_layout

\end_deeper
\begin_layout Itemize
In una pipeline multiple-issue, il CPI ideale dovrebbe essere 
\begin_inset Formula $CPI_{ideal}<1$
\end_inset


\end_layout

\begin_layout Itemize
Se consideriamo per esempio un processore a 2 issue, nel caso migliore il
 throughput massimo sarebbe quello di completare due istruzioni per ciclo
 di clock:
\begin_inset Formula 
\[
IPC_{ideal}=2
\]

\end_inset


\begin_inset Formula 
\[
CPI_{ideale}=0.5
\]

\end_inset


\end_layout

\begin_layout Subsection
Approfondimenti sulle dipendenze
\end_layout

\begin_layout Standard
Determinare le dipendenze tra le istruzioni è un punto critico per riuscire
 a definire la quantità di parallelismo esistente in un programma.
 Se due istruzioni sono dipendenti, non possono essere eseguite in parallelo:
 devono essere seguite in modo da essere solo parzialmente sovrapposte.
\end_layout

\begin_layout Standard
Ci sono 
\series bold
tre diversi tipi di dipendenze
\series default
:
\end_layout

\begin_layout Itemize

\series bold
Name dependences
\end_layout

\begin_layout Itemize

\series bold
Data dependences (or True Data Depencences)
\end_layout

\begin_layout Itemize

\series bold
Control dependences
\end_layout

\begin_layout Subsubsection
Name dependences
\end_layout

\begin_layout Standard
Sono quelle dipendenze che si presentano quando due istruzioni utilizzano
 lo stesso registro o locazione di memoria (da cui il termine 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
name
\series default
\emph default

\begin_inset Quotes erd
\end_inset

), ma non c'è un flusso di dati tra le istruzioni associate a quel 
\emph on
name
\emph default
.
\end_layout

\begin_layout Itemize
Esistono due tipi di name dependences tra una istruzione 
\begin_inset Formula $i$
\end_inset

 che precede una istruzione 
\begin_inset Formula $j$
\end_inset

 nell'ordine del programma sono:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Antidependence
\series default
: Quando 
\begin_inset Formula $j$
\end_inset

 scrive un registro o locazione di memoria che l'istruzione 
\begin_inset Formula $i$
\end_inset

 legge (può generare un 
\series bold
WAR
\series default
).
 L'ordine delle istruzioni originale deve essere preservato per assicurarsi
 che 
\begin_inset Formula $i$
\end_inset

 legga il valore corretto.
\end_layout

\begin_layout Itemize

\series bold
Output Dependence
\series default
: Quando 
\begin_inset Formula $i$
\end_inset

 e 
\begin_inset Formula $j$
\end_inset

 scrivono lo stesso registro o locazione di memoria (può generare un 
\series bold
WAW
\series default
).
 L'ordine originale delle istruzioni deve essere preservato per assicurarsi
 che il valore scritto alla fine corrisponda a quello di 
\begin_inset Formula $j$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Le name dependeces non sono delle vere data dependeces poiché non c'è nessun
 valore (data flow) che viene trasmesso tra le istruzioni.
\end_layout

\begin_layout Itemize
Se il 
\emph on
name
\emph default
 può essere cambiato in base alla semantica del programma, le istruzioni
 non vanno in conflitto
\end_layout

\begin_layout Itemize
Le dipendenze in locazioni di memoria sono difficili da individuare (problema
 della 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
memory disambiguation
\series default
\emph default

\begin_inset Quotes erd
\end_inset

) perché due indirizzi possono riferirsi alla stessa locazione ma possono
 apparire diversi (ad esempio uno a puntamento diretto, un altro per offset).
 I conflitti sui registri invece sono più semplici da individuare.
\end_layout

\begin_layout Itemize
Il 
\series bold
renaming
\series default
 può essere fatto dal compilatore dinamicamente o dall'hardware.
\end_layout

\begin_layout Subsubsection
Data dependences e Hazards
\end_layout

\begin_layout Standard
Una dipendenza dati o name può generare un data hazard (RAW, WAW, WAR) ma
 la presenza o meno di un hazard (e del numero di stalli necessari a risolverlo)
 dipende strettamente dalla pipeline considerata.
\end_layout

\begin_layout Itemize

\series bold
RAW
\series default
 hazards corrispondono a true data dependences.
\end_layout

\begin_layout Itemize

\series bold
WAW
\series default
 hazards corrispondono a dipendenze di output.
\end_layout

\begin_layout Itemize

\series bold
WAR
\series default
 hazards corrispondono a anti-dipendenze.
\end_layout

\begin_layout Standard
Le dipendenze sono una proprietà del programma, mentre gli hazards sono
 una proprietà della pipeline.
\end_layout

\begin_layout Subsubsection
Control dependences
\end_layout

\begin_layout Standard
Le dipendenze di controllo determinano l'ordinamento delle istruzioni.
 L'ordinamento viene preservato con due proprietà:
\end_layout

\begin_layout Itemize
Assicurarsi che nel flusso di istruzioni, le istruzioni che si presentano
 prima di un branch vengano eseguite effettivamente prima del branch
\end_layout

\begin_layout Itemize
Individuare i control hazard per assicurarsi che una istruzione (che è dipendent
e da un branch) 
\bar under
non sia eseguita fino a quando la direzione del branch non è nota
\bar default
.
\end_layout

\begin_layout Standard
Garantendo la control dependence possiamo preservare l'ordine del programma,
 però la 
\series bold
control dependence non è la proprietà critica
\series default
 che deve essere preservata.
\end_layout

\begin_layout Subsubsection
Program Properties
\end_layout

\begin_layout Standard
Ci sono due proprietà
\series bold
 
\series default
che sono critiche per la correttezza di un programma (e sono normalmente
 preservate mantenendo le dipendenze di controllo e dati):
\end_layout

\begin_layout Enumerate

\series bold
Data flow
\series default
: Il flusso corretto di dati tra le varie istruzioni, che produce il risultato
 corretto.
\end_layout

\begin_layout Enumerate

\series bold
Exception behavior
\series default
: Preservare il comportamento delle eccezioni significa che qualunque modifica
 nell'ordine di esecuzione delle istruzioni non deve modificare il modo
 in cui le eccezioni vengono sollevate nel programma.
\end_layout

\begin_layout Section
Evoluzione dello scheduling ILP: processori superscalari
\end_layout

\begin_layout Standard
Ci sono due strategie per supportare ILP:
\end_layout

\begin_layout Itemize

\series bold
Dynamic Scheduling
\series default
: L'hardware si occupa di identificare il parallelismo.
\end_layout

\begin_layout Itemize

\series bold
Static Scheduling
\series default
: Il software si occupa di identificare il parallelismo.
\end_layout

\begin_layout Standard
Gli approcci 
\begin_inset Quotes eld
\end_inset

hardware intensive
\begin_inset Quotes erd
\end_inset

 dominano il mercato desktop e server.
\end_layout

\begin_layout Subsection
Assunzioni
\end_layout

\begin_layout Itemize
Consideriamo dei processori 
\series bold
\emph on
single-issue
\end_layout

\begin_layout Itemize
Lo stadio di 
\series bold
\emph on
instruction fetch
\series default
\emph default
 precede lo stadio di issue e può fare fetch in un 
\series bold
\emph on
instruction register
\emph default
 
\series default
(o direttamente in una coda di istruzioni da eseguire).
\end_layout

\begin_layout Itemize
Le istruzioni sono poi inviate all'
\series bold
\emph on
issue
\series default
\emph default
 dall'instruction register
\series bold
\emph on
 
\series default
\emph default
(o dalla coda).
\end_layout

\begin_layout Itemize
Lo stadio di esecuzione può richiede più di un ciclo, a seconda del tipo
 di operazione.
\end_layout

\begin_layout Subsection
Dynamic Scheduling
\end_layout

\begin_layout Standard
Il problema sono le dipendenze dati che non possono essere nascoste con
 un bypass o forwarding a causa degli stalli della pipeline.
\end_layout

\begin_layout Standard
La 
\series bold
soluzione
\series default
 è quella di permettere alle 
\series bold
istruzioni dietro uno stallo di procedere
\series default
.
 
\bar under
L'hardware ri-arrangia dinamicamente l'esecuzione delle istruzioni per ridurre
 gli stalli.
\end_layout

\begin_layout Itemize
Viene aggiunta la possibilità della 
\series bold
out-of-order execution
\series default
 e 
\series bold
out-of-order completion
\series default
 (
\series bold
commit
\series default
).
\end_layout

\begin_layout Paragraph
Esempio di Dynamic Scheduling
\end_layout

\begin_layout LyX-Code
DIVD F0, F2, F4
\end_layout

\begin_layout LyX-Code
ADDD F10, F0, F8    #RAW F0
\end_layout

\begin_layout LyX-Code
SUBD F12, F8, F14
\end_layout

\begin_layout Itemize
RAW Hazard: ADDD va in stallo per F0 (aspettando che DIVD vada in commit).
\end_layout

\begin_layout Itemize
SUBD dovrebbe andare in stallo anche se non c'è nessuna dipendenza dati
 o altro sulla pipeline (se non ci fosse il dynamic scheduling).
\end_layout

\begin_layout Standard
Ergo la nostra idea è quella di permettere a SUBD di procedere (
\emph on
out-of-order execution
\emph default
).
\end_layout

\begin_layout Subsubsection
Pro e Contro
\end_layout

\begin_layout Itemize
I 
\series bold
vantaggi
\series default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Permette di gestire alcuni casi dove le dipendenze sono sconosciute a 
\emph on
compile time.
\end_layout

\begin_layout Itemize
Permette di semplificare i compilatori.
\end_layout

\begin_layout Itemize
Permette al codice compilato di girare efficientemente su una pipeline diversa
 (portabilità).
\end_layout

\end_deeper
\begin_layout Itemize
Gli 
\series bold
svantaggi
\series default
 (costi):
\end_layout

\begin_deeper
\begin_layout Itemize
Aumenta parecchio la complessità dell'hardware.
\end_layout

\begin_layout Itemize
Aumenta il consumo energetico del processore.
\end_layout

\begin_layout Itemize
Abbiamo il rischio di generare eccezioni (interrupt) 
\begin_inset Quotes eld
\end_inset

imprecise
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_deeper
\begin_layout Subsubsection
Riassumendo
\end_layout

\begin_layout Standard
Nella pipeline semplice abbiamo hazards a causa delle dipendenze dati che
 non possono essere risolti con forwarding nella pipeline.
 Con il dynamic scheduling invece l'hardware riordina l'esecuzione delle
 istruzioni di modo da ridurre gli stalli, mantenere il flusso dati e il
 comportamento delle eccezioni.
 L'esempio tipico è il 
\series bold
\emph on
processore superscalare.
\end_layout

\begin_layout Itemize
Le istruzioni vengono fetchate ed inviate nell'ordine del programma (
\emph on
in-order issue
\emph default
).
\end_layout

\begin_layout Itemize
L'esecuzione inizia appena gli operandi sono disponibili, è possibile avere
 
\emph on
out-of-order execution
\emph default
.
\end_layout

\begin_layout Itemize
L'esecuzione 
\emph on
out-of-order 
\emph default
introduce la possibilità di data (name) hazards di tipo 
\series bold
WAR
\series default
 o 
\series bold
WAW
\series default
.
\end_layout

\begin_layout Itemize
L'esecuzione 
\emph on
out-of-order
\emph default
 implica che anche il completamento sarà 
\emph on
out-of-order
\emph default
, a meno di un buffer che riordina i risultati prima che vengano scritti.
\end_layout

\begin_layout Subsection
Static Scheduling
\end_layout

\begin_layout Standard
I compilatori utilizzano algoritmi sofisticati per lo scheduling del codice
 per ottenere 
\emph on
instruction level parallelism
\emph default
.
\end_layout

\begin_layout Standard
Un 
\series bold
\emph on
basic block
\series default
\emph default
 (una sequenza di codice senza branch, eccetto per l'inizio e la fine) è
 solitamente 
\series bold
piccolo
\series default
 e la quantità disponibile di parallelismo all'interno un basic block è
 comunque poca.
\end_layout

\begin_layout Itemize
Ad esempio per un tipico programma MIPS la frequenza media di branch è da
 15% e 25%, che significa che ci sono tra 4 e 7 istruzioni da eseguire tra
 due branch.
\end_layout

\begin_layout Itemize
Le 
\series bold
dipendenze dati
\series default
 possono limitare ancora di più la quantità di parallelismo che possiamo
 ottenere da un basic block.
\end_layout

\begin_layout Itemize
Quindi, per ottenere dei miglioramenti di performance sostanziali, dobbiamo
 sfruttare il 
\series bold
\bar under
parallelismo tra diversi basic blocks.
\end_layout

\begin_layout Standard
L'esempio tipico sono i processori 
\series bold
VLIW
\series default
 (
\series bold
Very Long Instruction Word
\series default
) che si aspettano un codice privo di dipendenze dal compilatore.
\end_layout

\begin_layout Standard
Abbiamo però alcuni 
\series bold
limiti
\series default
 di utilizzo dello scheduling statico:
\end_layout

\begin_layout Itemize
I branch non sono prevedibili.
\end_layout

\begin_layout Itemize
La latenza della memoria è variabile (non possiamo prevedere i cache miss).
\end_layout

\begin_layout Itemize
Può aumentare la dimensione del segmento codice.
\end_layout

\begin_layout Itemize
Aumenta la complessità del compilatore.
\end_layout

\begin_layout Subsubsection
Evoluzione del parallelismo
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 061.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection
Esecuzione superscalare
\end_layout

\begin_layout Standard
È quello che fanno tutti i processori di fascia alta oggi (PowerPC, Pentium,
 Sparc,...)
\end_layout

\begin_layout Standard
L'idea
\series bold
 
\series default
è
\series bold
 
\series default
iniziare l'esecuzione (
\series bold
issue
\series default
)
\series bold
 di più di una istruzione per ciclo
\series default
.
\end_layout

\begin_layout Standard
I 
\series bold
requisiti 
\series default
per farlo sono:
\end_layout

\begin_layout Itemize
Fare il 
\bar under
fetch di più di una istruzione per ciclo
\bar default
: Non è difficile dato che la cache istruzioni può sostenere la banda.
\end_layout

\begin_layout Itemize
Decidere riguardo alla 
\bar under
dipendenza dati e controllo
\bar default
: Lo scheduling dinamico si prende già cura di questo.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 062.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection
Struttura dello scheduler dinamico
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 063.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 064.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
Ad ogni ciclo, il processore deve decidere quali istruzioni possono iniziare
 l'esecuzione.
\end_layout

\begin_layout Itemize
È necessario controllare tutte le istruzioni entrate in fetch con tutte
 le istruzioni 
\begin_inset Quotes eld
\end_inset

in volo
\begin_inset Quotes erd
\end_inset

, per capire quali sono indipendenti, prima di iniziare l'esecuzione.
\end_layout

\begin_layout Itemize
C'è un 
\series bold
limite
\series default
 su quante istruzioni possono essere verificate durante un ciclo di clock.
\end_layout

\begin_layout Subsubsection
Limiti
\end_layout

\begin_layout Paragraph
Lo scheduling dinamico costa!
\end_layout

\begin_layout Itemize
Abbiamo una quantità enorme di logica e un costo di area elevato.
\end_layout

\begin_deeper
\begin_layout Itemize
Nel PowerPC 750 l'instruction sequencer è circa il 70% dell'area di tutte
 le unità di esecuzione
\end_layout

\end_deeper
\begin_layout Itemize
Il tempo di ciclo è limitato dalla logica di scheduling (dispatcher e la
 logica di controllo associata).
\end_layout

\begin_layout Itemize
La verifica del design è molto complicata e la logica è complessa e irregolare.
\end_layout

\begin_layout Paragraph
Il numero di issue parallele è limitato nella pratica
\end_layout

\begin_layout Itemize
La 
\series bold
\emph on
issue width
\series default
\emph default
 è il numero di istruzioni che possono essere messe in esecuzione in un
 singolo ciclo da un processore 
\emph on
multiple-issue
\emph default
 (chiamato anche ILP).
\end_layout

\begin_layout Itemize
Quando l'architettura superscalare fu inventata, furono realizzati processori
 a 2 e 4 issue
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 065.png
	lyxscale 40
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
Il massimo (raro) numero di issue parallele è 6
\end_layout

\begin_deeper
\begin_layout Itemize
2-issue: UltraSPARC-T2/T3, Cortex-A8, Cortex-A9, Atom, Bobcat
\end_layout

\begin_layout Itemize
3-issue: Pentium-Pro/II/III/M, Athlon, Pentium-4, Athlon 64/Phenom, Cortex-A15
\end_layout

\begin_layout Itemize
4-issue: UltraSPARC-III/IV, PowerPC G4e, Core 2, Core i, Core i2, Bulldozer
\end_layout

\begin_layout Itemize
5-issue: PowerPC G5
\end_layout

\begin_layout Itemize
6-issue: Itanium (ma è un processore VLIW)
\end_layout

\end_deeper
\begin_layout Itemize
Questo perché è estremamente difficile trovare 8 o 16 istruzioni da eseguire
 in ogni ciclo (sono troppe!)
\end_layout

\begin_deeper
\begin_layout Itemize
Richiede troppo tempo la computazione di scheduling (non riesce a restare
 in un ciclo di clock).
\end_layout

\begin_layout Itemize
È necessario ridurre la frequenza del processore (guadagnando quindi in
 parallelismo ma perdendo in latenza e velocità).
\end_layout

\end_deeper
\begin_layout Subsubsection
Riassunto di processori superscalari e scheduling dinamico
\end_layout

\begin_layout Standard
In ogni caso abbiamo il vantaggio principale che il CPI ideale viene ridotto:
\begin_inset Formula 
\[
CPI_{ideal}=\frac{1}{\text{issue width}}
\]

\end_inset


\end_layout

\begin_layout Paragraph

\series bold
Svantaggi
\series default
:
\end_layout

\begin_layout Itemize
È molto costosa la 
\bar under
logica per trovare le dipendenze
\bar default
.
\end_layout

\begin_layout Itemize

\bar under
Non scala
\bar default
: è complicatissimo aumentare la issue a più di 4 (e rischiamo di dover
 rallentare il clock).
\end_layout

\begin_layout Section
Very Long Instruction Word (VLIW)
\end_layout

\begin_layout Subsection
Idea di base
\end_layout

\begin_layout Standard
È un modo alternativo per ottenere l'
\emph on
instruction level parallelism
\emph default
.
\end_layout

\begin_layout Itemize
Aumenta le risorse hardware aumentando il numero di unità pipeline invece
 di complicare la stessa pipeline.
\end_layout

\begin_layout Itemize
Utilizza scheduling statico.
\end_layout

\begin_layout Itemize
Ogni unità in un ciclo esegue ciecamente quello che è già stato deciso a
 compile time.
\end_layout

\begin_deeper
\begin_layout Itemize
Spostiamo dunque la complessità dall'hardware al compilatore.
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/VLIW_01.svg
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Subsubsection
Come funziona
\end_layout

\begin_layout Itemize
Il compilatore raggruppa più istruzioni in un singolo 
\emph on
issue bundle
\emph default
, anche detto 
\series bold
word
\series default
.
 
\end_layout

\begin_layout Itemize
Un bundle si compone di 
\series bold
slot
\series default
.
 
\end_layout

\begin_layout Itemize
Ciascuno slot del bundle viene riempito con un'istruzione, anche detta 
\series bold
sillaba
\series default
.
\end_layout

\begin_layout Itemize
Ad ogni slot corrisponde una fissata 
\series bold
unità funzionale
\series default
 (
\series bold
FU
\series default
)
\series bold
 
\series default
che si farà carico di eseguire quella sillaba.
 
\end_layout

\begin_layout Itemize
Le unità funzionali sono specializzate per eseguire una certa categoria
 di istruzioni: unità per operazioni ALU decimali, unità di branch, unità
 di load/store e così via.
\end_layout

\begin_layout Itemize
L'hardware eseguirà la fetch di una word ad ogni ciclo di clock.
\end_layout

\begin_layout Itemize
Il compilatore deve assicurarsi che non siano presenti 
\emph on
dipendenze
\emph default
 all'interno di un bundle o tra bundle vicini
\begin_inset Foot
status open

\begin_layout Plain Layout
Nei processori 
\emph on

\begin_inset Quotes eld
\end_inset

pure VLIW
\begin_inset Quotes erd
\end_inset


\emph default
 non è ammessa la presenza di dipendenze tuttavia alcune implementazioni
 consentono al compilatore di inserire e segnalare una dipendenza.
 In questi casi la dipendenza verrà gestita dall'hardware attraverso tecniche
 di forwarding semplificate.
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
L'hardware esegue le istruzioni fetchate
\end_layout

\begin_deeper
\begin_layout Itemize
senza controllare la presenza di eventuali dipendenze.
\end_layout

\begin_layout Itemize
senza dover scegliere a quale FU mandare l'istruzione caricata.
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/VLIW_02.svg
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 067.png
	lyxscale 40
	scale 40

\end_inset


\end_layout

\begin_layout Subsection
Caratteristiche
\end_layout

\begin_layout Subsubsection

\series bold
Limiti di VLIW
\end_layout

\begin_layout Paragraph
Parallelismo
\end_layout

\begin_layout Standard
Il compilatore deve trovare molto parallelismo per mantenere le unità funzionali
 del processore occupate.
 Laddove non riesce a trovare sufficienti istruzioni per occupare la pipeline
 riempie il codice di NOP.
\end_layout

\begin_layout Itemize
Aumenta la dimensione del codice.
\end_layout

\begin_layout Standard
Per sfruttare parallelismo tra diversi basic blocks alcune implementazioni
 supportano una funzionalità chiamata 
\emph on
predication via select execution
\emph default
.
\end_layout

\begin_layout Itemize
Il processore esegue entrambi i rami di una branch e quando il risultato
 (predicato) è noto decide quale dei due rami confermare e portare avanti.
\end_layout

\begin_layout Paragraph

\series bold
Incompatibilità binaria
\end_layout

\begin_layout Standard
Perdiamo la 
\begin_inset Quotes eld
\end_inset

portabilità
\begin_inset Quotes erd
\end_inset

 perché il processore è costretto a fare molte scelte strettamente dipendenti
 dalla micro-architettura.
 La compilazione infatti si basa su:
\end_layout

\begin_layout Itemize
ISA.
\end_layout

\begin_layout Itemize
Numero e tipo di FU disponibili.
\end_layout

\begin_layout Itemize
Latenza di ciascuna FU.
\end_layout

\begin_layout Subsubsection
Vantaggi e svantaggi
\end_layout

\begin_layout Standard
Vantaggi:
\end_layout

\begin_layout Itemize
Scheduling statico a compile time:
\end_layout

\begin_deeper
\begin_layout Itemize
Grazie ad una visione globale del codice consente di sfruttare più parallelismo
 di quanto l'hardware non riuscisse a trovare.
\end_layout

\begin_layout Itemize
Non è limitato dal tempo di un ciclo di clock.
\end_layout

\end_deeper
\begin_layout Itemize
L'hardware non deve effettuare alcun controllo su possibili dipendenze e
 hazard.
\end_layout

\begin_layout Itemize
Ogni unità funzionale è specializzata, la decode è molto semplice: i bit
 di ciascun campo sono noti a priori.
\end_layout

\begin_layout Itemize
La pipeline è più semplice:
\end_layout

\begin_deeper
\begin_layout Itemize
si riduce l'area del chip (e quindi anche il prezzo).
\end_layout

\begin_layout Itemize
si riduce il consumo di potenza.
\end_layout

\end_deeper
\begin_layout Standard
Svantaggi:
\end_layout

\begin_layout Itemize
Il compilatore deve fare tutto lui:
\end_layout

\begin_deeper
\begin_layout Itemize
Si perde la portabilità del codice.
\end_layout

\begin_layout Itemize
I compilatori sono molto più complessi.
\end_layout

\end_deeper
\begin_layout Itemize
Invece di inserire stalli, vengono inserite NOP.
\end_layout

\begin_deeper
\begin_layout Itemize
La dimensione del codice aumenta notevolmente.
\end_layout

\end_deeper
\begin_layout Subsubsection
Scheduling Software vs.
 Scheduling Hardware
\end_layout

\begin_layout Itemize

\series bold
Scheduling Software
\series default
 (statico, fatto dal compilatore)
\end_layout

\begin_deeper
\begin_layout Itemize
Codice sorgente disponibile.
\end_layout

\begin_layout Itemize
Analisi 
\begin_inset Quotes eld
\end_inset

globali
\begin_inset Quotes erd
\end_inset

 possibili.
\end_layout

\begin_layout Itemize
C'è più tempo disponibile perché non siamo dentro un ciclo di clock della
 CPU.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Scheduling Hardware
\series default
 (dinamico, fatto dall'instruction scheduler)
\end_layout

\begin_deeper
\begin_layout Itemize
Abbiamo informazioni a runtime (i dati attuali, indirizzi, puntatori, ...).
\end_layout

\begin_layout Itemize
Portabilità del compilato.
\end_layout

\end_deeper
\begin_layout Subsubsection
Processori superscalari vs.
 VLIW
\end_layout

\begin_layout Itemize
I processori superscalari sono lo 
\begin_inset Quotes eld
\end_inset

stato dell'arte
\begin_inset Quotes erd
\end_inset

 commerciale per scopi generali (Intel Core i, Alpha, PowerPC, MIPS e Sparc
 sono superscalari).
\end_layout

\begin_layout Itemize
I processori VLIW hanno successo per dispositivi embedded (TriMedia media
 processors, C600 DSP, STMicroelectronics ST200 family, SHARC DSP, Itanium
 2).
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 066.png
	lyxscale 40
	scale 40

\end_inset


\end_layout

\begin_layout Subsection
Scheduling VLIW
\end_layout

\begin_layout Standard
Come abbiamo visto finora il livello di parallelismo massimo raggiungibile
 è fortemente limitato.
 Le principali ragioni sono:
\end_layout

\begin_layout Itemize
Dipendenze tra le istruzioni.
\end_layout

\begin_layout Itemize
Dimensione ridotta del blocco basico.
\end_layout

\begin_layout Subsubsection
Grafo delle dipendenze
\end_layout

\begin_layout Standard
È possibile costruire un grafo delle dipendenze tra le istruzioni in modo
 da facilitare lo scheduling.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Definire critical path.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dato il frammento di codice
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

  i) A = B + 1;
\end_layout

\begin_layout Plain Layout

  //codeblock
\end_layout

\begin_layout Plain Layout

i+k) X = A + C;
\end_layout

\begin_layout Plain Layout

  //codeblock
\end_layout

\begin_layout Plain Layout

i+n) A = E + C;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
possiamo ricavare il grafo
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/VLIW2_01.svg
	lyxscale 50
	scale 25

\end_inset


\end_layout

\begin_layout Subsubsection
List based scheduling
\end_layout

\begin_layout Standard
Si basa sul grafo delle dipendenze e mira ad ottenere uno schedule 
\emph on
subottimo per un blocco basico
\emph default
.
\end_layout

\begin_layout Standard
Prima di iniziare lo scheduling, si costruisca il grafo delle dipendenze.
 Si definisca inoltre il 
\emph on
ready set
\emph default
 come l'insieme di istruzioni pronte ad andare in esecuzione; si inizializzi
 il ready set con le istruzioni radice del grafo (quelle senza alcuna dipendenza
).
 Inoltre ad ogni ciclo:
\end_layout

\begin_layout Itemize
schedulare istruzioni che:
\end_layout

\begin_deeper
\begin_layout Itemize
sono contenute nel ready set.
\end_layout

\begin_layout Itemize
a parità di altro, hanno priorità maggiore (percorso più lungo verso il
 fondo del grafo).
\end_layout

\begin_layout Itemize
non impegnano una risorsa (FU) già impegnata in questo ciclo.
\end_layout

\end_deeper
\begin_layout Itemize
Aggiungere al ready set tutte le istruzioni che hanno:
\end_layout

\begin_deeper
\begin_layout Itemize
tutti i predecessori già schedulati.
\end_layout

\begin_layout Itemize
tutti gli operandi pronti.
\end_layout

\end_deeper
\begin_layout Subsubsection
Loop unrolling
\end_layout

\begin_layout Standard
Per aumentare ulteriormente il parallelismo è necessario andare oltre la
 dimensione del blocco basico.
 Una tecnica non speculativa è il loop unrolling.
\end_layout

\begin_layout Standard
Il 
\emph on
compilatore
\emph default
 riconosce i cicli e, 
\emph on
\bar under
laddove è possibile determinare staticamente il numero di iterazioni del
 loop
\emph default
\bar default
, srotola il ciclo.
 Quando viene srotolato un ciclo viene 
\series bold
aumentata la dimensione del blocco basico
\series default
 formato istruzioni contenute nel ciclo 
\series bold
accorpando più iterazioni 
\series default
tra loro indipendenti.
 
\end_layout

\begin_layout Standard
In un blocco basico di dimensione maggiore è possibile trovare maggiore
 parallelismo riordinando le istruzioni.
\end_layout

\begin_layout Paragraph
I problemi del loop unrolling
\end_layout

\begin_layout Itemize
dipendenze tra una iterazione e la successiva.
\end_layout

\begin_layout Itemize
terminazione del ciclo.
\end_layout

\begin_layout Standard
Possono esistere dipendenze tra le istruzioni di una iterazione e la successiva
 (
\series bold
loop carried dependences
\series default
).
 In questo caso si può gestire le dipendenze introdotte oppure rinunciare
 ad eseguire l'unrolling.
\end_layout

\begin_layout Standard
La condizione di terminazione del ciclo deve essere adattata in modo da
 eseguire lo stesso numero di istruzioni per cui il ciclo era stato scritto.
 È possibile che srotolare il ciclo su base 4 (fondere 4 iterazioni assieme)
 possa portare ad avere 
\series bold
iterazioni residue
\series default
 se l'originale numero di iterazioni non era multiplo di 4.
 In questo caso è necessario gestire come caso particolare le iterazioni
 residue accodandole al ciclo srotolato.
\end_layout

\begin_layout Subsubsection
Loop peeling & fusion
\end_layout

\begin_layout Standard
Una tecnica simile allo srotolamento dei cicli è 
\emph on
sbucciare i cicli
\emph default
.
 Questa tecnica consiste nell'
\series bold
eliminare
\series default
 un determinato numero di 
\series bold
iterazioni da un loop
\series default
 aggiungendole poi in coda (o in testa) ad esso.
 Questo consente al compilatore di eseguire altre ottimizzazioni altrimenti
 non fattibili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for(i = 0; i < 102; i++)  b[i] = b[i + 2] + c;  //loop A
\end_layout

\begin_layout Plain Layout

for(j = 0; j < 100; j++)  a[j] = a[j] * 2;      //loop B
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for(i = 0; i < 100; i++){
\end_layout

\begin_layout Plain Layout

     b[i] = b[i + 2] + c;
\end_layout

\begin_layout Plain Layout

     a[i] = a[j] * 2; }             //fused loops
\end_layout

\begin_layout Plain Layout

b[100] = b[102] + c;
\end_layout

\begin_layout Plain Layout

b[101] = b[103] + c;                //peeled from loop A
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nell'esempio qui sopra è possibile vedere come sbucciare due iterazioni
 dal primo loop consenta di fondere assieme i due loop.
 Il compilatore può inoltre decidere di srotolare il ciclo per aumentare
 ulteriormente la dimensione del blocco basico.
\end_layout

\begin_layout Subsubsection
Software pipelining
\end_layout

\begin_layout Standard
Questa tecnica si applica a cicli nei quali vengono riconosciute istruzioni
 tra loro indipendenti inserite in diverse iterazioni.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/VLIW2_04.svg
	scale 50

\end_inset


\end_layout

\begin_layout Standard
Se una situazione simile viene individuata allora è possibile riorganizzare
 il ciclo in modo che le istruzioni tra loro indipendenti facciano parte
 della stessa iterazione del nuovo ciclo.
\end_layout

\begin_layout Standard
Per avere un esempio di applicazione si consideri il seguente frammento
 di codice.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (i = 0; i < 100; i++) {
\end_layout

\begin_layout Plain Layout

	A[i] = B[i];       //stage X
\end_layout

\begin_layout Plain Layout

	A[i] = A[i+1];     //stage Y
\end_layout

\begin_layout Plain Layout

	C[i] = A[i];       //stage Z
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Analizzando le diverse iterazioni di questo ciclo possiamo osservare blocchi
 di istruzioni tra loro indipendenti a cavallo di iterazioni successive
 (nell'immagine seguente sono evidenziate in diversi riquadri).
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/VLIW2_05.svg
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Cercando una ricorrenza in queste indipendenze possiamo creare un nuovo
 loop riscrivendo in modo ottimizzato il codice dato.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/VLIW2_06.svg
	lyxscale 40
	scale 50

\end_inset


\end_layout

\begin_layout Standard
Si noti che in confronto al loop unrolling questa tecnica presenta il vantaggio
 di creare un binario più compatto (non necessita di duplicare il corpo
 del ciclo) e vengono gestite anche le dipendenze loop carried.
\end_layout

\begin_layout Subsubsection
Trace scheduling
\end_layout

\begin_layout Standard
Trace scheduling è una tecnica di 
\series bold
global scheduling
\series default
, differente dalle tecniche viste finora che si limitavano ad eseguire un
 local scheduling (scheduling limitato a un blocco basico o a un ciclo).
 Fare global scheduling significa andare ad analizzare il software nel suo
 complesso e non limitandosi ad un blocco basico.
\end_layout

\begin_layout Standard
Trace scheduling si compone di due fasi:
\end_layout

\begin_layout Enumerate

\series bold
Trace Selection
\series default
.
 In base al grafo di flusso del programma identifica la 
\emph on
traccia
\emph default
 di esecuzione più probabile.
 La sequenza di blocchi basici più probabile può essere determinata per:
\end_layout

\begin_deeper
\begin_layout Itemize
predizione statica.
\end_layout

\begin_layout Itemize
predizione per profiling.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Trace Compaction
\series default
.
 Compatta la traccia individuata in un ristretto numero di istruzioni VLIW.
\end_layout

\begin_deeper
\begin_layout Itemize
necessita di mantenere una procedura di 
\emph on
recovery
\emph default
 in caso di predizione mancata (necessita di altri registri in più).
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/VLIW2_08.svg
	scale 60

\end_inset


\end_layout

\begin_layout Subsubsection
Superblock scheduling
\end_layout

\begin_layout Standard
Evoluzione della tecnica trace scheduling.
 Si definisce 
\series bold
superblocco
\series default
 un insieme di blocchi basici collegati con un singolo punto di ingresso
 e multiple uscite.
\end_layout

\begin_layout Standard
L'obiettivo è ottimizzare l'esecuzione del superblocco e trattare il resto
 del flusso di esecuzione come una eccezione.
 Il superblocco viene mantenuto il più compatto possibile, eventuali porzioni
 di codice con multipli ingressi vengono duplicate per mantenere la compattezza
 il più elevata possibile.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/VLIW2_09.svg
	lyxscale 40
	scale 20

\end_inset


\end_layout

\begin_layout Standard
Vantaggi:
\end_layout

\begin_layout Itemize
ottimizzazione più semplice da realizzare.
\end_layout

\begin_layout Itemize
gestione delle eccezioni limitata alle uscite (in ingresso non ci sono mai
 problemi)
\end_layout

\begin_layout Subsubsection
Predicated execution
\end_layout

\begin_layout Standard
Questa tecnica richiede una apposita estensione dell'ISA.
 Vengono introdotte 
\emph on
istruzioni condizionali
\emph default
 nel formato
\end_layout

\begin_layout LyX-Code
(p)      op Rd, Ra, Rb
\end_layout

\begin_layout Standard
dove p è un predicato o un registro a cui viene affiancata una normale operazion
e ternaria.
 Nella semantica delle istruzioni condizionali l'istruzione viene va in
 fase di commit solo se il predicato è true altrimenti viene trasformata
 in NOP.
\end_layout

\begin_layout Standard
L'introduzione di questo tipo di operazioni consente di tradurre costrutti
 di selezione in blocchi basici contenti istruzioni condizionali.
\end_layout

\begin_layout Standard
Vantaggi:
\end_layout

\begin_layout Itemize
è possibile applicare riorganizzazione del codice in base alle dipendenze.
\end_layout

\begin_layout Itemize
non è necessario predire il risultato del branch per un if.
\end_layout

\begin_layout Itemize
la dimensione del blocco basico aumenta.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Algoritmi e tecniche di dynamic scheduling
\end_layout

\begin_layout Section
Scoreboard
\end_layout

\begin_layout Standard
Per realizzare la funzionalità hardware di dynamic scheduling utilizziamo
 un algoritmo chiamato 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
scoreboard dynamic scheduling algorithm
\series default
\emph default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
Caratteristiche generali della scoreboard
\end_layout

\begin_layout Itemize
La scoreboard rimpiazza gli stadi ID, EX, WB con 4 stadi:
\end_layout

\begin_deeper
\begin_layout Itemize
Lo stadio 
\series bold
ID
\series default
 viene suddiviso in:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Issue
\series default
: Decodifica le istruzioni, controlla gli hazards strutturali.
\end_layout

\begin_layout Itemize

\series bold
Read Operands
\series default
 (aka 
\series bold
R
\series default
ead 
\series bold
R
\series default
egister): Aspetta fino a quando non ci sono data hazards, poi leggi gli
 operandi dai registri.
\end_layout

\end_deeper
\begin_layout Itemize
Una istruzione è nello stadio di 
\series bold
esecuzione
\series default
 (EX) nell'intervallo di tempo tra quando 
\emph on
inizia
\emph default
 l'esecuzione e quando la 
\emph on
completa
\emph default
.
 La scoreboard registra quindi:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Execution completed
\series default
: l'istante in cui l'esecuzione viene completata.
\end_layout

\begin_layout Itemize

\series bold
Write Result
\series default
: si accerta dell'assenza di hazard e finalizza il risultato.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
La 
\series bold
\emph on
scoreboard
\series default
\emph default
 (tabella dei punteggi) permette alle istruzioni di essere eseguite se i
 primi due stadi sono pronti, senza aspettare altre istruzioni.
\end_layout

\begin_deeper
\begin_layout Itemize
Le istruzioni vengono eseguite se non sono dipendenti da altre precedenti
 e non ci sono hazards.
\end_layout

\begin_layout Itemize
Le istruzioni 
\bar under
senza dipendenze
\bar default
 vanno 
\bar under
subito in esecuzione
\bar default
.
\end_layout

\end_deeper
\begin_layout Itemize
Anche se l'issue è 
\emph on
in-order
\emph default
, se abbiamo una lettura 
\emph on
out-of-order
\emph default
 degli operandi, avremo una esecuzione e completamento 
\emph on
out-of-order
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize
Tutte le istruzioni passano 
\emph on
in-order 
\emph default
attraverso lo stage 
\series bold
\emph on
issue
\series default
\emph default
, ma possono andare in stallo o sorpassarsi a vicenda nello stadio 
\series bold
\emph on
read operands
\series default
\emph default
 e quindi iniziare l'esecuzione 
\emph on
out-of-order
\emph default
 e (avendo latenze diverse) arrivare a completamento 
\emph on
out-of-order
\emph default
.
\end_layout

\end_deeper
\begin_layout Itemize
Assumiamo che la pipeline permetta l'esecuzione di più istruzioni allo stesso
 tempo.
 Abbiamo bisogno quindi di 
\series bold
unità funzionali multiple
\series default
 o 
\series bold
unità funzionali in pipeline
\series default
 (o entrambe).
\end_layout

\begin_deeper
\begin_layout Itemize
Nel processore CDC 6600 (il primo ad avere la tecnica di 
\emph on
dynamic scheduling
\emph default
) la issue è 
\emph on
in-order
\emph default
, l'esecuzione e il completamento sono 
\emph on
out-of-order
\emph default
.
 Non c'è forwarding e abbiamo un modello impreciso per la gestione di interrupt
 ed eccezioni.
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 068.png
	lyxscale 60
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection
Hazard e dipendenze
\end_layout

\begin_layout Standard
Se il completamento può essere 
\emph on
out-of-order
\emph default
 significa che gli hazards di tipo 
\series bold
WAR e WAW possono presentarsi
\series default
.
\end_layout

\begin_layout Itemize
Per gli hazards 
\series bold
WAR
\series default
 possiamo risolvere in due modi:
\end_layout

\begin_deeper
\begin_layout Itemize
Generare uno 
\series bold
stallo sulla 
\emph on
write back
\series default
\emph default
 fino a quando i registri non sono stati letti.
\end_layout

\begin_layout Itemize
Leggere i registri solo durante la fase 
\series bold
\emph on
read operands
\series default
.
\end_layout

\end_deeper
\begin_layout Itemize
Per gli hazards 
\series bold
WAW
\series default
 possiamo risolvere mettendo in stallo la issue di nuove istruzioni fino
 a quando l'altra istruzione non ha completato.
\end_layout

\begin_layout Standard
Inoltre:
\end_layout

\begin_layout Itemize
Non facciamo renaming dei registri.
\end_layout

\begin_layout Itemize
La 
\emph on
\bar under
scoreboard
\emph default
\bar default
 tiene traccia delle 
\bar under
dipendenze
\bar default
 e dello 
\bar under
stato delle operazioni
\bar default
.
\end_layout

\begin_layout Itemize

\series bold
Hazard detection 
\series default
e 
\series bold
resolution
\series default
 viene centralizzata nella scoreboard:
\end_layout

\begin_deeper
\begin_layout Enumerate
Ogni istruzione passa per la scoreboard, dove viene costruito un record
 che tiene traccia delle dipendenze di quella istruzione.
\end_layout

\begin_layout Enumerate
La scoreboard determina se l'istruzione può leggere gli operandi e iniziare
 l'esecuzione.
\end_layout

\begin_layout Enumerate
Se la scoreboard decide che l'istruzione non può andare in esecuzione subito,
 controlla ogni modifica e decide quando l'istruzione può partire in esecuzione.
\end_layout

\begin_layout Enumerate
La scoreboard controlla quando l'istruzione può scrivere il suo risultato
 nel registro di destinazione.
\end_layout

\end_deeper
\begin_layout Subsubsection

\series bold
Gestione delle eccezioni
\series default
:
\end_layout

\begin_layout Standard
Il problema del completamento 
\emph on
out-of-order 
\emph default
è che dobbiamo preservare il comportamento delle eccezioni così come se
 fosse stato tutto 
\emph on
in-order
\emph default
.
\end_layout

\begin_layout Itemize
La soluzione è quella di assicurarsi che non ci siano istruzioni che possono
 generare eccezione.
 Quando il processore trova che l'istruzione che lancia l'eccezione viene
 lanciata eseguirà le istruzioni critiche 
\emph on
in-order
\emph default
.
\end_layout

\begin_layout Paragraph

\series bold
Eccezioni 
\begin_inset Quotes eld
\end_inset

imprecise
\begin_inset Quotes erd
\end_inset


\series default
:
\end_layout

\begin_layout Standard
Una eccezione si dice 
\emph on

\begin_inset Quotes eld
\end_inset

imprecise
\emph default

\begin_inset Quotes erd
\end_inset

 se, quando viene sollevata, lo stato del processore non appare esattamente
 come quello di quando le istruzioni vengono eseguite 
\emph on
in-order
\emph default
.
\end_layout

\begin_layout Standard
Possibili cause sono:
\end_layout

\begin_layout Itemize
La pipeline ha 
\bar under
già completato
\bar default
 istruzioni che sono 
\series bold
dopo
\series default
 l'istruzione che causa l'eccezione nell'ordine corretto del programma.
\end_layout

\begin_layout Itemize
La pipeline 
\bar under
non ha ancora completato
\bar default
 istruzioni che sono 
\series bold
prima
\series default
 l'istruzione che causa l'eccezione nell'ordine corretto del programma.
\end_layout

\begin_layout Standard
Le eccezioni 
\begin_inset Quotes eld
\end_inset

imprecise
\begin_inset Quotes erd
\end_inset

 rendono difficile riavviare l'esecuzione dopo aver sollevato l'eccezione
 (perché ci si trova in uno stato non previsto).
\end_layout

\begin_layout Subsection
I 4 stadi di controllo della scoreboard
\end_layout

\begin_layout Enumerate

\series bold
Issue
\series default
: Decodifica l'istruzione e controlla la presenza di hazards strutturali
 e WAW hazards
\end_layout

\begin_deeper
\begin_layout Itemize
Le istruzioni vengono inviate nell'ordine del programma (per controllare
 gli hazards).
\end_layout

\begin_layout Itemize
Se una unità funzionale per l'istruzione è libera e non ci sono altre istruzioni
 con lo stesso registro destinazione (quindi no WAW hazard), la scoreboard
 fa issue delle istruzione all'unità funzionale e aggiorna la sua struttura
 interna.
\end_layout

\begin_layout Itemize
Se un hazard strutturale o un hazards WAW esiste, allora l'issue va in stallo
 e non si fa issue di nessuna istruzione fino a quando l'hazard non è risolto
\end_layout

\begin_deeper
\begin_layout Itemize
Notiamo che quando lo stage di issue va in stallo, il buffer tra lo stadio
 IF e Issue si riempie.
 Se il buffer ha una singola entry va in stallo tutto lo stadio IF, se il
 buffer è una coda allora lo stadio IF va in stallo quando la coda si riempie.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
Read Operands
\series default
: Attendi fino a quando non ci sono più hazard dati, poi leggi gli operandi
\end_layout

\begin_deeper
\begin_layout Itemize
Un operando sorgente è 
\series bold
disponibile
\series default
 se:
\end_layout

\begin_deeper
\begin_layout Itemize
Non c'erano istruzioni attive mandate in issue a scrivere quell'operando
\end_layout

\begin_layout Itemize
Oppure una unità funzionale sta scrivendo il suo valore in un registro
\end_layout

\end_deeper
\begin_layout Itemize
Quando l'operando sorgente è disponibile, la scoreboard dice all'unità funzional
e di procedere a leggere gli operandi dai registri e iniziare l'esecuzione.
\end_layout

\begin_layout Itemize
Gli hazard 
\series bold
RAW
\series default
 vengono 
\series bold
risolti dinamicamente
\series default
 in questo stadio.
 Le istruzioni possono essere inviate in esecuzione 
\emph on
out-of-order
\emph default
.
\end_layout

\begin_layout Itemize
Non c'è forwarding dei dati in questo modello.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Execution
\series default
: L'unità funzionale inizia l'esecuzione quando riceve gli operandi.
 Quando il risultato è pronto notifica la scoreboard che ha completato l'esecuzi
one.
\end_layout

\begin_deeper
\begin_layout Itemize
Le unità funzionali sono caratterizzate da:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Latenza variabile
\series default
 (il tempo effettivo utilizzato per completare una operazione
\end_layout

\begin_layout Itemize
Intervallo di inizializzazione (il numero di cicli che devono passare tra
 l'issue di due operazioni alla stessa unità funzionale).
\end_layout

\begin_layout Itemize
La latenza delle operazioni di load/store dipende dalla data cache (HIT
 o MISS ?).
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
Write result
\series default
: Controllare per hazards di tipo 
\series bold
WAR
\series default
 e completare l'esecuzione
\end_layout

\begin_deeper
\begin_layout Itemize
Una volta che la scoreboard sa che l'unità funzionale ha completato l'esecuzione
, essa stessa si preoccupa di 
\series bold
controllare 
\series default
l'eventuale presenza di 
\series bold
hazards di tipo WAR
\end_layout

\begin_deeper
\begin_layout Itemize
Se non ce ne sono, scrive direttamente il risultato.
\end_layout

\begin_layout Itemize
Se c'è un WAR, allora va in stallo prima di completare l'istruzione.
\end_layout

\end_deeper
\begin_layout Itemize
Esempio:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 069.png
	lyxscale 60
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
La scoreboard deve:
\end_layout

\begin_deeper
\begin_layout Itemize
Andare in stallo su SUBD nello stadio WB, aspettando che ADDD legga F0 e
 F8
\end_layout

\begin_layout Itemize
Inoltre deve andare in stallo su MULD nello stage di issue, fino a quando
 ADDD scrive F6
\end_layout

\end_deeper
\begin_layout Itemize
Si può anche risolvere utilizzando il 
\series bold
\emph on
register renaming
\series default
\emph default
.
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Struttura della scoreboard
\end_layout

\begin_layout Itemize
Instruction status
\end_layout

\begin_layout Itemize
Function Unit status
\end_layout

\begin_deeper
\begin_layout Itemize
Indica lo stato dell'unità funzionale (FU):
\end_layout

\begin_deeper
\begin_layout Itemize
Busy: L'unità è occupata o no
\end_layout

\begin_layout Itemize
Op: Indica l'operazione da effettuare con l'unità (+, -, ...)
\end_layout

\begin_layout Itemize
Fi: Indica il registro di destinazione
\end_layout

\begin_layout Itemize
Fj, Fk: Registri sorgente
\end_layout

\begin_layout Itemize
Qj, Qk: Unità funzionali che producono i registri sorgente Fj, Fk
\end_layout

\begin_layout Itemize
Rj, Rk: Flags che indicano quando Fj e Fk sono pronti.
 I Flags sono impostati su 
\begin_inset Quotes eld
\end_inset

no
\begin_inset Quotes erd
\end_inset

 dopo che gli operandi vengono letti
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Register result status: Indica quale unità funzionale scriverà quale registro.
 Non conterrà nulla se non ci sono istruzioni in coda che scriveranno quel
 registro
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 070.png
	lyxscale 60
	scale 40

\end_inset


\end_layout

\begin_layout Subsection
Esempio di funzionamento della scoreboard
\end_layout

\begin_layout Standard
Struttura generale:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/Scoreboard_passo0.svg
	lyxscale 60
	scale 40

\end_inset


\end_layout

\begin_layout Paragraph
Passo 1
\end_layout

\begin_layout Standard
Supponiamo che il codice inizi l'esecuzione dalla prima LD senza hazard
 di alcun tipo.
 Al ciclo 1 possiamo eseguire la issue dell'istruzione.
 Scriviamo quindi 1 nella colonna Issue in corrispondenza della prima LD.
\end_layout

\begin_layout Standard
LD (
\series bold
L
\series default
oad 
\series bold
D
\series default
ecimal) è una operazione che lavora su dati di tipo 
\emph on
Integer
\emph default
.
 Verrà quindi occupata una FU per operazioni integer.
 Aggiorniamo quindi la tabella delle FU indicando che la FU Integer è 
\emph on
busy
\emph default
 e sta eseguendo una Load.
 Indichiamo inoltre i registri coinvolti (F6 destinazione, F2 registro sorgente
 2).
 Il registro sorgente F2 è inoltre subito disponibile, riportiamo questa
 informazione nell'ultima colonna della tabella.
\end_layout

\begin_layout Standard
Infine procediamo ad aggiornare lo stato dei registri.
 Indichiamo che in F6 è stato 
\begin_inset Quotes eld
\end_inset

prenotato
\begin_inset Quotes erd
\end_inset

 per la scrittura dalla FU integer.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/Scoreboard_passo1.svg
	lyxscale 60
	scale 40

\end_inset


\end_layout

\begin_layout Paragraph
Passo 2
\end_layout

\begin_layout Standard
Al ciclo 2 è possibile iniziare la fase di Read Operands della prima LD.
 Scriviamo 2 nella seconda colonna della prima riga.
 
\end_layout

\begin_layout Standard
Non vi sono variazioni nello stato delle FU né nello stato dei registri.
\end_layout

\begin_layout Standard
La pipeline potrebbe proseguire con la issue della seconda LD tuttavia non
 sono disponibili risorse hardware per poter eseguire questa istruzione
 (l'unica FU integer è già occupata).
 La seconda LD deve quindi attendere.
 Si segnala quindi una issue stall dovuta a uno structural hazard.
\end_layout

\begin_layout Standard
La issue deve essere fatta in-order quindi le seguenti istruzioni non possono
 procedere.
\end_layout

\begin_layout Paragraph
Passo 3 
\end_layout

\begin_layout Standard
La issue della seconda LD deve ancora aspettare per gli stessi motivi del
 ciclo precedente.
 Abbiamo una issue stall dovuta a uno structural hazard.
\end_layout

\begin_layout Standard
La prima LD esegue legge il valore da memoria (cache HIT) e termina la sua
 esecuzione.
 Indichiamo che il completamento della sua esecuzione avviene al ciclo 3
 nella tabella.
 Le altre tabelle non subiscono variazioni.
\end_layout

\begin_layout Paragraph
Passo 4
\end_layout

\begin_layout Standard
La prima LD non ha problemi a eseguire la fase di write back.
 Riportiamo quindi 4 nella tabella dello stato delle istruzioni.
\end_layout

\begin_layout Standard
A questo punto l'istruzione è terminata e libera la FU.
 Puliamo la riga della FU integer prima di passare oltre.
\end_layout

\begin_layout Standard
La successiva LD non può ancora proseguire per consentire all'istruzione
 precedente di eseguire la fase di write back.
\end_layout

\begin_layout Paragraph
Passo 5
\end_layout

\begin_layout Standard
La issue della seconda LD può finalmente procedere.
 Indichiamo 5 nella colonna issue per la seconda LD.
 Come per il passo 1 riserviamo la FU integer per eseguire questa istruzione
 e aggiorniamo le altre tabelle.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/Scoreboard_passo5.svg
	lyxscale 60
	scale 40

\end_inset


\end_layout

\begin_layout Paragraph
Passo 6
\end_layout

\begin_layout Standard
La seconda LD procede e inizia la fase di Read Operands.
\end_layout

\begin_layout Standard
L'istruzione successiva è una MULTD e possiamo mandarla in issue.
 Occupiamo quindi una FU moltiplicatore di quelle libere.
 Aggiorniamo la tabella delle FU riportando i dettagli dell'operazione di
 cui abbiamo fatto issue.
 Notare che questa operazione richiede due registri ma solo uno di questi
 è pronto.
 F2 infatti è il risultato della LD, ora in fase Read Operands (quindi non
 ancora terminata); possiamo notare che quando un registro non è pronto
 viene riportato anche l'id della FU che fornirà quel valore, per F2 si
 tratta della FU integer.
\end_layout

\begin_layout Standard
Aggiorniamo anche la tabella di stato dei registri indicando che F0 è un
 registro prenotato in scrittura dalla FU 
\emph on
mult1
\emph default
.
\end_layout

\begin_layout Paragraph
Passo 7
\end_layout

\begin_layout Standard
La LD continua la sua esecuzione e compie un cache HIT completando la sua
 fase di esecuzione.
\end_layout

\begin_layout Standard
La MULTD ha un registro sorgente (F2) non ancora pronto e deve quindi attendere
 ancora.
 Abbiamo uno stallo della Read Operands dovuto a un 
\emph on
RAW hazard
\emph default
.
\end_layout

\begin_layout Standard
L'istruzione successiva è una SUBD, eseguiamo la sua issue assegnandole
 la FU 
\emph on
add
\emph default
.
 Aggiorniamo quindi le varie tabelle: nello stato delle FU possiamo vedere
 che l'operando F2 è marcato come non pronto; nello stato dei registri è
 riportato che F8 verrà fornito dalla FU add.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/Scoreboard_passo7.svg
	lyxscale 60
	scale 40

\end_inset


\end_layout

\begin_layout Paragraph
Passo 8
\end_layout

\begin_layout Standard
La prossima istruzione del programma è una DIVD e non ci sono problemi nel
 caricarla nella FU 
\emph on
divide
\emph default
.
 Avviene quindi la issue della DIVD.
\end_layout

\begin_layout Standard
Aggiorniamo le tabelle in seguito alla avvenuta issue.
 
\end_layout

\begin_layout Standard
La LD passa alla fase di write back senza problemi.
 Dopo aver scritto il registro F2 è necessario avvisare tutti coloro che
 erano in attesa di quel registro che il valore è pronto.
 Andiamo a cambiare lo stato di un po' di celle 
\emph on
ready
\emph default
 nella tabella dello stato delle FU.
\end_layout

\begin_layout Paragraph
Passo 9 - 10
\end_layout

\begin_layout Standard
Al passo 9 eseguono la fase di Read Operands le istruzioni MULTD e SUBD.
\end_layout

\begin_layout Standard
Al passo 10 le stesse iniziano l'esecuzione.
 Queste FU tuttavia hanno latenza tra loro diversa, maggiore di 1.
 È opportuno annotarsi ad ogni passo quanto manca al termine della fase
 di esecuzione per poter riportare il valore esatto in tabella.
\end_layout

\begin_layout Standard
La continuazione dell'esercizio è lasciata come facile esercizio al lettore.
\end_layout

\begin_layout Paragraph
Alla fine
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/Scoreboard_passo62.svg
	lyxscale 60
	scale 40

\end_inset


\end_layout

\begin_layout Section
Algoritmo di Tomasulo
\end_layout

\begin_layout Subsection
Caratteristiche principali
\end_layout

\begin_layout Standard
Si tratta di un altro algoritmo per effettuare scheduling dinamico.
 L'obiettivo è sempre quello di ottenere elevate performance senza necessità
 di compilatori particolari.
\end_layout

\begin_layout Standard
In particolare, rispetto a scoreboard:
\end_layout

\begin_layout Itemize
I buffer sono distribuiti nelle varie FU e non centralizzati.
\end_layout

\begin_deeper
\begin_layout Itemize
I buffer delle FU vengono chiamati 
\series bold
Reservation Station
\series default
.
\end_layout

\end_deeper
\begin_layout Itemize
Nello stato delle istruzioni i registri vengono rimpiazzati dai valori o
 puntatori alle reservation station (RS) per consentire 
\series bold
register renaming
\series default
.
 
\end_layout

\begin_deeper
\begin_layout Itemize

\bar under
Evita
\bar default
 così 
\bar under
WAW e WAR hazard
\bar default
 rinominando i risultati (usa numeri di RS invece di Register File).
\end_layout

\begin_layout Itemize
Un numero di RS superiore al numero dei registri consente di effettuare
 ottimizzazioni che il compilatore non riesce a vedere.
\end_layout

\end_deeper
\begin_layout Itemize
Utilizza il Common Data Bus invece dei registri per passare i valori da
 una FU ad un'altra (FU broadcast).
\end_layout

\begin_layout Itemize
Anche le istruzioni load e store hanno FU dedicate con RS.
\end_layout

\begin_layout Itemize
Separa istruzioni intere da istruzioni Floating Point (FP ops) su diverse
 code.
\end_layout

\begin_layout Subsection
Schema architetturale
\end_layout

\begin_layout Subsubsection
Schema generale di una architettura
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/Tomasulo_01.svg
	lyxscale 50
	scale 70

\end_inset


\end_layout

\begin_layout Subsubsection
Schema di una Floating Point Unit
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename svg/Tomasulo_02 novectorial.svg
	lyxscale 50
	scale 55

\end_inset


\end_layout

\begin_layout Subsubsection
Componenti di una Reservation Station
\end_layout

\begin_layout Description
Tag identificatore della RS.
\end_layout

\begin_layout Description
Busy indica se la RS è occupata o meno.
\end_layout

\begin_layout Description
OP tipo di operazione da eseguire.
\end_layout

\begin_layout Description
\begin_inset Formula $V_{j}$
\end_inset

,
\begin_inset space ~
\end_inset


\begin_inset Formula $V_{k}$
\end_inset

 valore degli operandi sorgente (per le load 
\begin_inset Formula $V_{j}$
\end_inset

 contiene il valore di offset).
\end_layout

\begin_layout Description
\begin_inset Formula $Q_{j}$
\end_inset

,
\begin_inset space ~
\end_inset


\begin_inset Formula $Q_{k}$
\end_inset

 puntatori alle RS che produrranno i valori 
\begin_inset Formula $V_{j}$
\end_inset

, 
\begin_inset Formula $V_{k}$
\end_inset

 (
\begin_inset Formula $0$
\end_inset

 indica che gli operandi sono già pronti).
\end_layout

\begin_layout Standard
Si noti che solo uno dei valori 
\begin_inset Formula $V$
\end_inset

 o 
\begin_inset Formula $Q$
\end_inset

 è significativo per un dato operando.
\end_layout

\begin_layout Standard
L'accesso in scrittura al register file non avviene mai direttamente per
 evitare conflitti.
\end_layout

\begin_layout Standard
Per le operazioni di Load e Store la RS ha un campo 
\series bold
Address
\series default
 in cui viene memorizzato inizialmente l'offset (intero immediato) caricato
 dall'istruzione, poi l'effettivo indirizzo di memoria a cui l'operazione
 fa riferimento.
\end_layout

\begin_layout Subsection
Gli stadi dell'algoritmo
\end_layout

\begin_layout Subsubsection
Issue
\end_layout

\begin_layout Itemize
Preleva una istruzione dalla coda istruzioni (mantenuta FIFO)
\end_layout

\begin_deeper
\begin_layout Itemize
viene garantita la 
\series bold
in-order issue
\series default
.
\end_layout

\end_deeper
\begin_layout Itemize
Controlla se una RS è disponibile per il tipo di istruzione prelevato.
\end_layout

\begin_deeper
\begin_layout Itemize
se non ce n'è una disponibile si verifica uno 
\series bold
structural hazard
\series default
.
\end_layout

\begin_deeper
\begin_layout Itemize
stallo.
\end_layout

\end_deeper
\begin_layout Itemize
se gli operandi richiesti non sono subito disponibili si tiene traccia di
 quali FU produrranno quei valori tramite i puntatori 
\begin_inset Formula $Q$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Rinomina i registri
\end_layout

\begin_deeper
\begin_layout Itemize
Risoluzione dei 
\series bold
WAR
\series default
, 
\series bold
WAW
\series default
: la issue di una istruzione che legge (o scrive) un registro destinazione
 di un'altra istruzione già caricata salverà il riferimento alla RS dell'istruzi
one che già occupa il registro in scrittura.
\end_layout

\end_deeper
\begin_layout Subsubsection
Execution
\end_layout

\begin_layout Itemize

\series bold
La fase di esecuzione inizia quando entrambi gli operandi sono pronti e
 una FU è disponibile.
\end_layout

\begin_layout Itemize
Se gli operandi non sono pronti 
\series bold
controlla il Common Data Bus 
\series default
(CDB) in attesa degli stessi.
\end_layout

\begin_layout Itemize

\bar under
Ritardando l'esecuzione fino a quando gli operandi non sono pronti si evitano
 i RAW.
\end_layout

\begin_deeper
\begin_layout Itemize
Si noti che gli stalli dovuti ai conflitti RAW hanno durata inferiore in
 quanto il dato quando viene pronto non deve aspettare la write back sul
 Register File ma giunge alla RS tramite il CDB (è una specie di Forwarding).
\end_layout

\end_deeper
\begin_layout Itemize
Prima di mandare in esecuzione una istruzione pronta è necessario verificare
 che sia disponibile una FU.
\end_layout

\begin_deeper
\begin_layout Itemize
A causa degli stalli, è possibile che più di una istruzione diventi pronta
 per essere eseguita nello stesso ciclo di clock causando 
\bar under
conflitto strutturale
\bar default
.
\end_layout

\end_deeper
\begin_layout Paragraph
Gestione dei Branch
\end_layout

\begin_layout Standard
Nessuna istruzione può iniziare la fase di esecuzione prima che il risultato
 di tutti precedenti branch sia noto.
\end_layout

\begin_layout Standard
Nel caso di branch prediction deve essere noto il risultato definitivo.
\end_layout

\begin_layout Paragraph
Esecuzione di una Load / Store
\end_layout

\begin_layout Standard
Avviene in due passi:
\end_layout

\begin_layout Enumerate
Calcola l'effettivo indirizzo target.
\end_layout

\begin_deeper
\begin_layout Enumerate
Aspetta che il valore del registro base sia disponibile.
 
\end_layout

\begin_layout Enumerate
Calcola il valore e lo piazza nel load (o store) buffer.
\end_layout

\end_deeper
\begin_layout Enumerate
Invio all'unità di memoria:
\end_layout

\begin_deeper
\begin_layout Itemize
La load nel load buffer viene eseguita appena una unità di memoria è disponibile.
 
\end_layout

\begin_layout Itemize
La store nello store buffer aspetta che il valore da scrivere venga pronto
 prima di essere inviata all'unità di memoria.
\end_layout

\end_deeper
\begin_layout Standard
Tramite il calcolo preventivo dell'indirizzo target è possibile mantenere
 evitare 
\emph on
conflitti di memoria
\emph default
.
\end_layout

\begin_layout Subsubsection
Write Result
\end_layout

\begin_layout Standard
Quando il risultato è disponibile si passa nella fase di write result.
\end_layout

\begin_layout Itemize
il risultato viene scritto sul CDB.
\end_layout

\begin_layout Itemize
Dal CDB il risultato viene scritto sul Register File.
\end_layout

\begin_layout Itemize
Dal CDB il risultato viene scritto in tutte le RS in attesa di quel dato.
\end_layout

\begin_layout Itemize
Le istruzioni store scrivono il dato in memoria.
\end_layout

\begin_layout Standard
Al termine di tutto ciò le RS liberate vengono marcate disponibili.
\end_layout

\begin_layout Subsection
Altri dettagli
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset


\end_layout

\end_body
\end_document
