#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1cm
\rightmargin 1cm
\bottommargin 1cm
\headheight 1cm
\headsep 1cm
\footskip 1.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Architetture avanzate dei calcolatori
\begin_inset Foot
status open

\begin_layout Plain Layout
Quest'opera è sotto licenza Creative Commons Attribuzione - Condividi allo
 stesso modo 2.5 Italia License.
\end_layout

\end_inset


\end_layout

\begin_layout Author
Daniele Iamartino
\end_layout

\begin_layout Section*
Introduzione
\end_layout

\begin_layout Standard
In questo corso vedremo alcuni dei problemi 
\begin_inset Quotes eld
\end_inset

avanzati
\begin_inset Quotes erd
\end_inset

 nelle architetture dei calcolatori:
\end_layout

\begin_layout Itemize
Come possiamo aumentare le performance riducendo il costo finale del design
 architetturale?
\end_layout

\begin_deeper
\begin_layout Itemize
RISC
\end_layout

\begin_layout Itemize
Pipeline
\end_layout

\end_deeper
\begin_layout Itemize
Possiamo guadagnare ancora di più?
\end_layout

\begin_deeper
\begin_layout Itemize
Branch prediction 
\end_layout

\begin_layout Itemize
Instruction level parallelism
\end_layout

\begin_layout Itemize
Multithreading
\end_layout

\begin_layout Itemize
Multiprocessors
\end_layout

\end_deeper
\begin_layout Itemize
Soluzioni ancora più avanzate
\end_layout

\begin_deeper
\begin_layout Itemize
Memory hearchy
\end_layout

\begin_layout Itemize
Cache organization
\end_layout

\end_deeper
\begin_layout Subsection*
Riferimenti
\end_layout

\begin_layout Itemize
"
\emph on
Computer Architecture, A Quantitative Approach
\emph default
", John Hennessy, David Patterson, Morgan Kaufmann, Fourth Edition
\end_layout

\begin_layout Part*
Concetti base sulla Pipeline
\end_layout

\begin_layout Section*
Caratteristiche della architettura MIPS
\end_layout

\begin_layout Itemize
MIPS è una architettura 
\series bold
RISC
\series default
 (Reduced Instruction Set Computer), è basata quindi sul concetto di eseguire
 solo semplici istruzioni.
\end_layout

\begin_layout Itemize
Utilizza una architettura 
\series bold
LOAD
\series default
/
\series bold
STORE
\end_layout

\begin_deeper
\begin_layout Itemize

\bar under
Tutti
\bar default
 gli operandi delle operazioni vengono spostati in registri 
\emph on
general purpose
\emph default
 della CPU e 
\series bold
non
\series default
 possono arrivare direttamente dalla memoria.
\end_layout

\begin_layout Itemize
Quindi, si utilizza la 
\series bold
LOAD
\series default
 per spostare dati dalla memoria ai registri e la 
\series bold
STORE
\series default
 per spostare dati dai registri alla memoria
\end_layout

\end_deeper
\begin_layout Itemize
MIPS è basato su una 
\series bold
architettura a pipeline
\series default
 che è una tecnica di ottimizzazione che si basa sulla sovrapposizione dell'esec
uzione di istruzioni multiple derivate da un flusso di esecuzione sequenziale
\end_layout

\begin_layout Itemize
MIPS utilizza 32 registri
\end_layout

\begin_layout Subsection*
Instruction Set Architecture (base) del processore MIPS
\end_layout

\begin_layout Itemize
Istruzioni di 
\series bold
ALU
\series default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code
add $s1, $s2, $s3         # $s1 ← $s2 + $s3
\end_layout

\begin_layout LyX-Code
addi $s1, $s2, 4          # $s1 ← $s2 + 4
\end_layout

\end_deeper
\begin_layout Itemize
Istruzioni 
\series bold
load
\series default
/
\series bold
store
\series default
 (di 
\series bold
\emph on
w
\series default
ord
\emph default
) da 
\series bold
M
\series default
emoria (
\bar under
attenzione all'ordine degli operandi
\bar default
):
\end_layout

\begin_deeper
\begin_layout LyX-Code
lw $s1, offset ($s2)      # $s1 ← M[$s2+offset]
\end_layout

\begin_layout LyX-Code
sw $s1, offset ($s2)      # M[$s2+offset] ← $s1
\end_layout

\end_deeper
\begin_layout Itemize
Istruzioni di 
\series bold
branch condizionali
\series default
 (controllo di flusso):
\end_layout

\begin_deeper
\begin_layout LyX-Code
beq $s1, $s2, L1          # go to L1 if ($s1 == $s2)
\end_layout

\begin_layout LyX-Code
bne $s1, $s2, L1          # go to L1 if ($s1 != $s2)
\end_layout

\end_deeper
\begin_layout Itemize
Istruzioni di 
\series bold
branch incondizionali
\series default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code
j L1                      # jump to L1
\end_layout

\begin_layout LyX-Code
jr $s1                    # jump to address contained in $s1
\end_layout

\end_deeper
\begin_layout Subsection*
Formato delle istruzioni MIPS a 32 bit
\end_layout

\begin_layout Itemize

\series bold
Tipo R
\series default
 (Register):
\end_layout

\begin_deeper
\begin_layout Itemize
Istruzioni ALU
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Tipo I 
\series default
(Immediate):
\end_layout

\begin_deeper
\begin_layout Itemize
Istruzioni immediate
\end_layout

\begin_layout Itemize
Istruzioni load/store
\end_layout

\begin_layout Itemize
Branch condizionali
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Tipo J 
\series default
(Jump):
\end_layout

\begin_deeper
\begin_layout Itemize
Istruzioni di jump incondizionato
\end_layout

\end_deeper
\begin_layout Subsubsection*
Formato R per istruzioni ALU Register-Register 
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opcode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
shamt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
funct
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 bit
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Opcode
\series default
: Identifica il tipo di istruzione ALU
\end_layout

\begin_layout Itemize

\series bold
rs
\series default
: Primo operando 
\series bold
sorgente
\end_layout

\begin_layout Itemize

\series bold
rt
\series default
: Secondo operando 
\series bold
sorgente
\end_layout

\begin_layout Itemize

\series bold
rd
\series default
: Registro di destinazione
\end_layout

\begin_layout Itemize

\series bold
shamt
\series default
: Quantità di shift
\end_layout

\begin_layout Itemize

\series bold
funct
\series default
: Identifica diversi tipi di istruzioni ALU
\end_layout

\begin_layout Subsubsection*
Formato I per istruzioni LOAD/STORE
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opcode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rt
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
offset
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Opcode
\series default
: Identifica il tipo di istruzione ALU
\end_layout

\begin_layout Itemize

\series bold
rs
\series default
: Registro base
\end_layout

\begin_layout Itemize

\series bold
rt
\series default
: Registro destinazione o sorgente per i dati caricati o salvati in memoria
\end_layout

\begin_layout Itemize

\series bold
offset
\series default
: Viene utilizzato (estendendolo in segno) sommato con l'indirizzo del base
 register
\end_layout

\begin_layout Subsubsection*
Formato I per istruzioni immediate ALU
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opcode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rt
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
immediate
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Opcode
\series default
: Identifica il tipo di istruzione ALU
\end_layout

\begin_layout Itemize

\series bold
rs
\series default
: Registro sorgente
\end_layout

\begin_layout Itemize

\series bold
rt
\series default
: Registro destinazione
\end_layout

\begin_layout Itemize

\series bold
immediate
\series default
: Contiene il valore dell'operando immediato (nel range 
\begin_inset Formula $-2^{15}$
\end_inset

 e 
\begin_inset Formula $2^{15}-1$
\end_inset

 a causa del primo bit di segno)
\end_layout

\begin_layout Subsubsection*
Formato I per istruzioni di branch condizionale
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opcode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rt
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
address
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Opcode
\series default
: Identifica il tipo di istruzione branch
\end_layout

\begin_layout Itemize

\series bold
rs
\series default
: Primo registro da comparare
\end_layout

\begin_layout Itemize

\series bold
rt
\series default
: Secondo registro da comparare
\end_layout

\begin_layout Itemize

\series bold
address
\series default
: Indica l'offset di parole relative alla posizione del program counter
 (PC-relative word address)
\end_layout

\begin_layout Subsubsection*
Formato J per i Jump incondizionati
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opcode
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
address
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
26 bit
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Opcode
\series default
: Identifica il tipo di istruzione Jump
\end_layout

\begin_layout Itemize

\series bold
address
\series default
: Contiene i 26 bit più significativi dei 32 dell'indirizzo assoluto della
 parola di memoria
\end_layout

\begin_layout Subsection*
Esecuzione delle istruzioni MIPS
\end_layout

\begin_layout Standard
Ogni istruzione del subset MIPS può essere implementata in 
\series bold
\bar under
al massimo 5 cicli di clock
\series default
\emph on
 
\emph default
\bar default
come segue:
\end_layout

\begin_layout Enumerate

\series bold
Instruction Fetch Cycle
\series default
 (
\series bold
IF
\series default
):
\end_layout

\begin_deeper
\begin_layout Enumerate
Invia i contenuti del 
\series bold
program counter
\series default
 register alla 
\series bold
instruction memory
\series default
 e leggi l'istruzione corrente.
\end_layout

\begin_layout Enumerate
Aggiorna il program counter aggiungendo 4 all'indirizzo corrente (ogni istruzion
e sono 4 Bytes / 32 bits)
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Instruction Decode and Register Read Cycle 
\series default
(
\series bold
ID
\series default
)
\end_layout

\begin_deeper
\begin_layout Enumerate
Decodifica l'istruzione corrente e 
\bar under
legge i vari registri
\bar default
 specificati nell'istruzione dal register file.
\end_layout

\begin_layout Enumerate
L'estensione del segno nel campo dell'offset dell'istruzione viene fatta
 in questo punto
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Execution Cycle
\series default
 (
\series bold
EX
\series default
)
\end_layout

\begin_deeper
\begin_layout Enumerate
La 
\series bold
ALU opera sugli operandi
\series default
 preparati nei cicli precedenti a seconda del tipo di istruzione:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Register-Register ALU Instructions
\series default
: L'ALU esegue le operazioni specificate dagli operandi
\end_layout

\begin_layout Itemize

\series bold
Register-Immediate ALU Instructions
\series default
: L'ALU esegue l'operazione sul primo operando
\end_layout

\begin_layout Itemize

\series bold
Memory Reference
\series default
: L'ALU aggiunge il registro base e l'offset per calcolare l'indirizzo effettivo
\end_layout

\begin_layout Itemize

\series bold
Conditional branches
\series default
: Vengono comparati due registri letti e computate possibili indirizzi 
\series bold
branch target address
\series default
 aggiungendo l'estensione di segno al PC.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
Memory Access 
\series default
(
\series bold
ME
\series default
)
\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
Le istruzioni di LOAD richiedono un accesso in lettura alla Data Memory
 utilizzando l'indirizzo effettivo
\end_layout

\begin_layout Enumerate
Le istruzioni di STORE richiedono un accesso in scrittura alla Data Memory
 utilizzando l'indirizzo effettivo per scrivere i dati dall'indirizzo sorgente
\end_layout

\begin_layout Enumerate
I branch condizionali possono aggiornare il contenuto del Program Counter
 con i branch target address, se il risultato è 
\emph on
true
\end_layout

\begin_layout Standard
Questa fase di memory access non è presente in tutte le istruzioni! Alcune
 non hanno bisogno di questa fase.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Write-Back Cycle
\series default
 (
\series bold
WB
\series default
):
\end_layout

\begin_deeper
\begin_layout Enumerate
Le istruzioni di LOAD scrivono i dati letti dalla memoria nel registro di
 destinazione
\end_layout

\begin_layout Enumerate
Le istruzioni ALU scrivono i risultati della ALU nel registro di destinazione
\end_layout

\end_deeper
\begin_layout Subsection*
Latenza delle istruzioni
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tipo di istruzione
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Instruct.
 Mem.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Register read
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
ALU op.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Data Memory
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Write Back
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Total Latency
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
ALU Instr.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 ns
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Load
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 ns
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Store
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7 ns
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Cond.Branch
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 ns
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Jump
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 ns
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection*
Operazioni MIPS fase per fase
\end_layout

\begin_layout Itemize

\series bold
ALU instructions:
\end_layout

\begin_deeper
\begin_layout Itemize
IF: Fetch e incremento PC
\end_layout

\begin_layout Itemize
ID: Lettura dei registri sorgente ed eventuale estensione di segno dell'offset
\end_layout

\begin_layout Itemize
EX: Operazione ALU sui dati
\end_layout

\begin_layout Itemize
ME:
\end_layout

\begin_layout Itemize
WB: Scrittura del risultato nel register file
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
LOAD instructions
\series default
:
\end_layout

\begin_deeper
\begin_layout Itemize
IF: Fetch e incremento PC
\end_layout

\begin_layout Itemize
ID: Lettura del registro base
\end_layout

\begin_layout Itemize
EX: Operazione di ALU per somma degli indirizzi
\end_layout

\begin_layout Itemize
ME: Operazione di lettura da memoria del valore
\end_layout

\begin_layout Itemize
WB: Scrittura del valore letto nel register file
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
STORE instructions
\series default
:
\end_layout

\begin_deeper
\begin_layout Itemize
IF: Fetch e incremento PC
\end_layout

\begin_layout Itemize
ID: Lettura del registro base e valore sorgente 
\end_layout

\begin_layout Itemize
EX: Operazione di ALU per somma degli indirizzi
\end_layout

\begin_layout Itemize
ME: Scrittura in memoria del valore
\end_layout

\begin_layout Itemize
WB: 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Conditional branch instructions
\series default
:
\end_layout

\begin_deeper
\begin_layout Itemize
IF: Fetch e incremento PC
\end_layout

\begin_layout Itemize
ID: Lettura dei due registri da confrontare
\end_layout

\begin_layout Itemize
EX: Operazione ALU di confronto e somma del program counter in caso di branch
\end_layout

\begin_layout Itemize
ME: Scrittura del PC (non è nel register file)
\end_layout

\begin_layout Itemize
WB: 
\end_layout

\end_deeper
\begin_layout Subsection*
Implementazione base del data path MIPS
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 001.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
La 
\series bold
instruction memory
\series default
 (read-only memory) è separata dalla 
\series bold
data memory
\end_layout

\begin_layout Itemize
I 32 registri 
\emph on
general-purpose
\emph default
 sono organizzati in un 
\series bold
register file
\series default
 (
\series bold
RF
\series default
) con due porte in lettura e una porta in scrittura
\end_layout

\begin_layout Subsection*
Implementazione della fase di Instruction Fetch
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 002.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Implementazione delle istruzioni ALU
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 003.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Implementazione dell'ALU e istruzioni LOAD/STORE
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 004.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection*
Implementazione dei branch condizionali
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 005.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Implementazione del data path MIPS
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 006.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Implementazione del data path MIPS con unità di controllo
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 007.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Implementazione multi-cycle
\end_layout

\begin_layout Itemize
Abbiamo detto che l'esecuzione di una istruzione viene distribuita su più
 cicli (5 per MIPS)
\end_layout

\begin_layout Itemize
Il ciclo base è lungo 
\begin_inset Formula $5\, ns$
\end_inset

, quindi la durata massima di una istruzione è 
\begin_inset Formula $10\, ns$
\end_inset


\end_layout

\begin_layout Itemize
Implementazione di una CPU multi-cycle:
\end_layout

\begin_deeper
\begin_layout Itemize
Ogni fase della esecuzione di una istruzione richiede un ciclo di clock
\end_layout

\begin_layout Itemize
Ogni modulo può essere utilizzato più di una volta per ogni istruzione in
 diversi cicli di clock.
 
\series bold
Quindi
\series default
 è possibile 
\series bold
condividere dei moduli
\series default
.
\end_layout

\begin_layout Itemize
Abbiamo bisogno di registri interni per salvare i valori da utilizzare nei
 cicli di clock seguenti.
\end_layout

\end_deeper
\begin_layout Subsection*
Pipelining
\end_layout

\begin_layout Standard
È una tecnica per l'ottimizzazione delle performance, basata sulla sovrapposizio
ne dell'esecuzione di istruzioni multiple derivanti da un flusso di esecuzione
 sequenziale.
\end_layout

\begin_layout Standard
Il pipelining 
\bar under
utilizza il parallelismo tra le istruzioni in uno stream sequenziale
\bar default
.
\end_layout

\begin_layout Itemize

\series bold
Idea base:
\series default
 L'esecuzione di una istruzione viene divisa in più fasi (pipelines stages)
 che richiedono una frazione del tempo necessario per completare l'istruzione.
\end_layout

\begin_layout Itemize
Gli stages sonocollegati tra di loro dalla pipeline: l'istruzione entra
 nella pipeline da una parte, passa per vari stages e esce dall'altra parte,
 come su una catena d'assemblaggio.
\end_layout

\begin_layout Itemize

\series bold
Vantaggio
\series default
: È una tecnica di 
\begin_inset Quotes eld
\end_inset

parallelismo
\begin_inset Quotes erd
\end_inset

 trasparente al programmatore.
\end_layout

\begin_layout Itemize
Come su una catena d'assemblaggio di automobili, in un ciclo entra una automobil
e e ne esce una nuova, non modifichiamo il tempo necessario per completare
 una automobile, ma aumentiamo il numero di automobili prodotte simultaneamente
 e la frequenza per completarle.
\end_layout

\begin_layout Subsubsection*
Esecuzione sequenziale vs.
 pipelining
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
IF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
EX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
ME
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instruction Fetch
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instruction Decode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Execution
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Memory Access
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write Back
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 008.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
I vari stage della pipeline 
\bar under
devono
\bar default
 essere 
\series bold
sincronizzati
\series default
: la durata di un ciclo di clock è definita dal tempo necessario allo stage
 più lento della pipeline.
\end_layout

\begin_layout Itemize
Se gli stages sono perfettamente bilanciati, lo 
\series bold
speedup ideale
\series default
 che otteniamo ad utilizzare la pipeline invece dell'esecuzione sequenziale
 è pari al numero di stage da attraversare (in questo caso 5, quindi x5).
\end_layout

\begin_layout Itemize
Se consideriamo una CPU senza pipelining, con ciclo di clock di 8 ns e la
 CPU2 con 5 stages da 2ns:
\end_layout

\begin_deeper
\begin_layout Itemize
La 
\series bold
latenza
\series default
 di ogni istruzione peggiora (da 8 a 10 ns)
\end_layout

\begin_layout Itemize
Però il 
\series bold
throughput
\series default
 (numero di istruzioni completate nell'unità di tempo) aumenta di 4 volte
\end_layout

\end_deeper
\begin_layout Itemize
Se consideriamo una CPU senza pipelining, con 5 cicli di clock di 2 ns e
 la CPU2 con 5 stages da 2ns:
\end_layout

\begin_deeper
\begin_layout Itemize
La 
\series bold
latenza
\series default
 di ogni istruzione 
\bar under
resta invariata
\end_layout

\begin_layout Itemize
Il 
\series bold
throughput
\series default
 (numero di istruzioni completate nell'unità di tempo) aumenta di 5 volte
\end_layout

\end_deeper
\begin_layout Subsubsection*
Le varie fasi della pipeline riviste per i vari tipi di istruzione
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 009.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Implementazione della pipeline MIPS
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 010.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection*
Risorse utilizzate nella pipeline
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 011.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
IM = Instruction Memory
\end_layout

\begin_layout Itemize
REG = Register File
\end_layout

\begin_layout Itemize
DM = Data Memory
\end_layout

\begin_layout Subsection*
Il problema degli 
\begin_inset Quotes eld
\end_inset

hazards
\begin_inset Quotes erd
\end_inset

 (pericoli)
\end_layout

\begin_layout Itemize
Un 
\emph on
hazard
\emph default
 viene creato quando c'è una dipendenza tra istruzioni, le istruzioni sono
 vicine e quindi la pipeline cambia l'ordine di accesso agli operandi coinvolti
 nella dipendenza (compromettendo il risultato)
\end_layout

\begin_layout Itemize
L'
\emph on
hazard
\emph default
 impedice alla prossima istruzione della pipeline di essere eseguita nel
 suo ciclo di clock previsto
\end_layout

\begin_layout Itemize
Gli 
\emph on
hazards
\emph default
 
\series bold
riducono le performance
\series default
 dello speedup ideale guadagnato dalla pipeline.
\end_layout

\begin_layout Subsection*
Tipi di hazards
\end_layout

\begin_layout Itemize

\series bold
Structural Hazards
\series default
: Tentativo di utilizzare la stessa risorsa da diverse istruzioni simultaneament
e
\end_layout

\begin_deeper
\begin_layout Itemize
Ad esempio: memoria singola per istruzioni e dati
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Data Hazards
\series default
: Tentativo di utilizzare un risultato prima che sia pronto
\end_layout

\begin_deeper
\begin_layout Itemize
Ad esempio: istruzione dipendente dal risultato di una precedente istruzione
 ancora in pipeline
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Control Hazards
\series default
: Tentativo di fare una decisone riguardo alla prossima istruzione da eseguire,
 prima che la condizione sia valutata
\end_layout

\begin_layout Subsubsection*
Structural Hazards
\end_layout

\begin_layout Standard
Non ce ne sono nella architettura MIPS:
\end_layout

\begin_layout Itemize
La 
\emph on
instruction memory
\emph default
 è separata dalla 
\emph on
data memory
\end_layout

\begin_layout Itemize
Il register file è utilizzato nello stesso ciclo di clock: Accesso in lettura
 da una istruzione e accesso in lettura da parte di un'altra istruzione
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 012.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection*
Data Hazards
\end_layout

\begin_layout Standard
Se le istruzioni eseguite nella pipeline sono 
\series bold
dipendenti
\series default
, ci possono essere data hazards se le istruzioni sono troppo vicine.
\end_layout

\begin_layout Standard
Esempio:
\end_layout

\begin_layout LyX-Code
sub $2, $1, $3      # Reg.
 $2 scritto da sub
\end_layout

\begin_layout LyX-Code
and $12, $2, $5     # 1° operando ($2) dipende da un sub
\end_layout

\begin_layout LyX-Code
or $13, $6, $2      # 2° operando ($2) dipende da un sub
\end_layout

\begin_layout LyX-Code
add $14, $2, $2     # 1° ($2) & 2° ($2) dipende da un sub
\end_layout

\begin_layout LyX-Code
sw $15, 100($2)     # Registro base ($2) dipende da un sub
\end_layout

\begin_layout Standard
La situazione risulta abbastanza chiara dalla figura seguente:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 013.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Data Hazards: Possibili soluzioni
\end_layout

\begin_layout Itemize

\series bold
Compilation Techniques 
\series default
(in fase di compilazione):
\end_layout

\begin_deeper
\begin_layout Itemize
Inserire delle istruzioni 
\series bold
nop
\series default
 (no operation)
\end_layout

\begin_layout Itemize
Fare scheduling dele istruzioni (scambiare l'ordine etc...) per evitare che
 istruzioni correlate siano troppo vicine
\end_layout

\begin_deeper
\begin_layout Itemize
Il compilatore tenta di inserire istruzioni indipendenti tra quelle correlate
\end_layout

\begin_layout Itemize
Quando il compilatore non trova istruzioni indipendenti, inserisce 
\series bold
nop
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Hardware Techniques
\series default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Inserimento di 
\begin_inset Quotes eld
\end_inset

bubbles
\begin_inset Quotes erd
\end_inset

 o 
\emph on
stalls 
\emph default
(stalli) nella pipeline.
\end_layout

\begin_layout Itemize
Data 
\emph on
forwarding
\emph default
 o 
\emph on
bypassing
\emph default
.
\end_layout

\end_deeper
\begin_layout Subsubsection*
Inserimento di nops
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 014.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection*
Scheduling
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 015.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection*
Inserimento di 
\emph on
stalls
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 016.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection*
Forwarding
\end_layout

\begin_layout Standard
Il data forwarding utilizza risultati temporanei memorizzati nei registri
 della pipeline invece di aspettare il write back dei risultati nel register
 file.
\end_layout

\begin_layout Standard
Quindi con il forwarding abbiamo la possibilità di passare informazioni
 da uno stadio della pipeline ad un altro 
\series bold
direttamente
\series default
, senza aspettare che il dato venga riscritto (e riletto) tramite il register
 file (esterno alla pipeline).
\end_layout

\begin_layout Standard
Dobbiamo aggiungere multiplexers agli inputs dell'ALU per prendere input
 dai registri della pipeline per evitare l'inserimento di stalli.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 017.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 018.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Ci sono tre forwarding paths:
\end_layout

\begin_layout Itemize
EX/EX path
\end_layout

\begin_layout Itemize
MEM/EX path
\end_layout

\begin_layout Itemize
MEM/ID path
\end_layout

\begin_layout Subsubsection*
Implementazione di MIPS con la forwarding unit
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 019.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection*
Data Hazards: Load/Use hazard
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 020.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Facendo forwarding utilizzando il percorso MEM/EX è 
\series bold
necessario 1 stallo
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 021.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 022.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Con un forwarding su MEM/MEM path si risolve:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 023.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection*
Forwarding paths
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 024.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
I percorsi di forwarding sono:
\end_layout

\begin_layout Itemize
EX/EX
\end_layout

\begin_layout Itemize
MEM/EX
\end_layout

\begin_layout Itemize
MEM/ID
\end_layout

\begin_layout Itemize
MEM/MEM (per LOAD/STORE)
\end_layout

\begin_layout Subsubsection*
Pipeline ottimizzata
\end_layout

\begin_layout Itemize
Il register file viene utilizzato in due stages: Accesso in read durante
 fase ID e accesso in write durante la fase WB
\end_layout

\begin_layout Itemize
Cosa succede se read e write si riferiscono allo stesso register nello 
\series bold
stesso
\series default
 ciclo di clock? È necessario 
\series bold
inserire una stall
\series default
.
\end_layout

\begin_layout Itemize
Pipeline ottimizzata: assumiamo che le read del register file accadono nella
 seconda metà del ciclo di clock e che le write del register file accadono
 nella prima metà del ciclo di clock.
\end_layout

\begin_deeper
\begin_layout Itemize
Potremmo aver bisogno di un clock a frequenza doppia di quello normale della
 pipeline
\end_layout

\begin_layout Itemize
Evitiamo così di dover inserire delle stall.
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 025.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
IM = Instruction Memory
\end_layout

\begin_layout Itemize
REG = Register File
\end_layout

\begin_layout Itemize
DM = Data Memory
\end_layout

\begin_layout Subsubsection*
Data Hazards nella pipeline ottimizzata
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 026.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
In questo caso è necessario inserire 
\series bold
due
\series default
 stalls, oppure usare i forwarding paths
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 027.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
I forwarding paths sono:
\end_layout

\begin_deeper
\begin_layout Itemize
EX/EX path
\end_layout

\begin_layout Itemize
MEM/EX path
\end_layout

\begin_layout Itemize
MEM/MEM path (for LOAD/STOREs)
\end_layout

\end_deeper
\begin_layout Subsubsection*
Data Hazards
\end_layout

\begin_layout Itemize

\series bold
RAW (READ AFTER WRITE) hazards
\series default
: Istruzione n+1 tenta di leggere un registro sorgente scritto prima che
 l'istruzione 
\emph on
n
\emph default
 lo abbia scritto nel register file.
\end_layout

\begin_deeper
\begin_layout Itemize
Esempio:
\end_layout

\begin_layout LyX-Code
add $r1, $r2, $r3
\end_layout

\begin_layout LyX-Code
sub $r4, $r1, $r5
\end_layout

\begin_layout Itemize
Utilizzando il forwarding è sempre possibile questo conflitto senza introdurre
 stalls, eccetto per i load/use hazards 
\end_layout

\end_deeper
\begin_layout Standard
Ci sono anche altri tipi di data hazards nella pipeline:
\end_layout

\begin_layout Itemize

\series bold
WAW (WRITE AFTER WRITE)
\end_layout

\begin_layout Itemize

\series bold
WAR (WRITE AFTER READ)
\end_layout

\begin_layout Subsubsection*
WAW - Write After Write
\end_layout

\begin_layout Standard
L'istruzione 
\begin_inset Formula $n+1$
\end_inset

 tenta di scrivere un operando di destinazione prima che sia stato scritto
 dall'istruzione precedente 
\begin_inset Formula $n$
\end_inset

 .
\end_layout

\begin_layout Standard
Quindi le operazioni di write vengono eseguite nell'ordine sbagliato
\end_layout

\begin_layout Itemize
Questo tipo di hazard può presentarsi sula pipeline MIPS quando si estendono
 operazioni multi-ciclo per eseguire o accedere alla memoria dati.
\end_layout

\begin_layout Standard
Ad esempio, se assumiamo che la scrittura su registro delle istruzioni ALU
 avvenga nel quarto stage e che le istruzioni di LOAD richiedano 2 stages
 (MEM1 e MEM2) per accedere alla memoria dati, possiamo avere:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 028.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
Se assumiamo che le operazioni ALU floating point richiedano una esecuzione
 multi-ciclo, abbiamo:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 029.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection*
WAR - Write After Read
\end_layout

\begin_layout Standard
L'istruzione 
\begin_inset Formula $n+1$
\end_inset

 tenta di scrivere un operando di destinazione prima che venga letto dall'istruz
ione precedente 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Standard
Quindi l'istruzione 
\begin_inset Formula $n$
\end_inset

 legge il valore sbagliato.
\end_layout

\begin_layout Itemize
Esempio:
\end_layout

\begin_deeper
\begin_layout LyX-Code
sw $y, 0($x)         # sw deve leggere $x
\end_layout

\begin_layout LyX-Code
addi $x, $x, 4       # addi scrive $x
\end_layout

\end_deeper
\begin_layout Standard
Gli hazards di tipo WAR non possono accadere nella pipeline MIPS perché
 le operazioni di read avvengono sempre nello stage ID, mentre le operazioni
 di write avvengono sempre nello stage WB
\end_layout

\begin_layout Itemize
Come prima, se assumiamo che la scrittura di registri delle istruzioni ALU
 avviene nel quarto stage e che abbiamo bisogno due stages per accedere
 alla memoria dati, alcune operazioni possono leggere gli operandi troppo
 tardi nella pipeline.
\end_layout

\begin_layout Subsection*
Problemi di performance nella Pipeline
\end_layout

\begin_layout Standard
Come abbiamo visto la Pipeline aumenta il throughput ma non la latenza delle
 istruzioni.
 
\end_layout

\begin_layout Standard
In realtà il pipelineing aumenta leggermente la latenza di tutte le istruzioni
 a causa di overhead e sbilanciamento tra le latenze delle istruzioni.
 
\end_layout

\begin_layout Subsubsection*
Metriche di Performance
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
IC=\text{Instruction Count}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\#Clock\, Cycles=IC\,+\,\#Stall\, Cycles\,+\,4
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
CPI\,=\, Clock\, Per\, Instruction\,=\,\frac{\#Clock\, Cycles}{IC}=\frac{\left(IC+\#Stall\, Cycles+4\right)}{IC}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
MIPS=\frac{f_{clock}}{\left(CPI\cdot10^{6}\right)}
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Esempio
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
IC=\text{Instruction Count}=5
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\#Clock\, Cycles=12
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
CPI\,=\,2.4
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
MIPS=208.3
\]

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 030.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsubsection*
Metriche di performance (2)
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
IC_{\text{per iterazione}}=m
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\#Clock\, Cycles_{\text{per iterazione}}=IC_{\text{per iterazione}}+\#Stall\, Cycles_{\text{per iterazione}}+4
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
CPI_{\text{per iterazione}}=\frac{\left(IC_{\text{per iterazione}}+\#Stall\, Cycles_{\text{per iterazione}}+4\right)}{IC_{\text{per iterazione}}}=\frac{\left(m+k+4\right)}{m}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
MIPS_{\text{per iterazione}}=\frac{f_{clock}}{CPI_{\text{per iterazione}}\cdot10^{6}}
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Metriche di performance asintotiche
\end_layout

\begin_layout Standard
Consideriamo 
\begin_inset Formula $n$
\end_inset

 iterazioni di un ciclo composto da 
\begin_inset Formula $m$
\end_inset

 istruzioni per iterazione che richiedono 
\begin_inset Formula $k$
\end_inset

 stalli per iterazione (nel segutio 
\begin_inset Formula $AS$
\end_inset

 starà per 
\begin_inset Quotes eld
\end_inset


\emph on
asintotico
\emph default

\begin_inset Quotes erd
\end_inset

):
\begin_inset Formula 
\[
IC_{AS}=Instruction\, Count_{AS}=m\cdot n
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\#Clock\, Cycles=IC_{AS}+\#Stall\, Cycles_{AS}+4
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
CPI_{AS}=lim_{n\rightarrow\infty}\frac{\left(IC_{AS}+\#Stall\, Cycles_{AS}+4\right)}{IC_{AS}}=\frac{\left(m+k\right)}{m}
\]

\end_inset


\begin_inset Formula 
\[
MIPS_{AS}=\frac{f_{clock}}{CPI_{AS}\cdot10^{6}}
\]

\end_inset


\end_layout

\begin_layout Standard
Il CPI ideale per un processore con pipeline sarebbe 1, ma gli stalli fanno
 degradare le performance, quindi abbiamo:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
CPI_{medio}PIPE\,=\, CPI\, Ideal+Pipe\, Stall\, Cycles_{\text{per istruzione}}=1+Pipe\, Stall\, Cycles_{\text{per istruzione}}
\]

\end_inset


\end_layout

\begin_layout Standard
I cicli di stallo per iterazione sono dovuti a structural hazards, data
 harzards, control hazards e memory stalls
\end_layout

\begin_layout Subsubsection*
Speedup della pipeline
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Pipeline\, speedup\,=\frac{Avarage\, execution\, time_{\text{senza pipeline}}}{Avarage\, execution\, time_{\text{con pipeline}}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Pipeline\, speedup\,=\frac{Avarage\, CPI_{\text{senza pipeline}}}{Avarage\, CPI_{\text{con pipeline}}}\cdot\frac{Clock\, Cycle_{\text{senza pipeline}}}{Clock\, Cycle_{\text{con pipeline}}}
\]

\end_inset


\end_layout

\begin_layout Standard
Se ignoriamo l'overhead sul tempo di clock a causa del pipelining e assumiamo
 che i vari stage sono perfettamente bilanciati, il tempo di clock di due
 processori può essere uguale, quindi:
\begin_inset Formula 
\[
Pipeline\, speedup\,=\,\frac{Avarage\, CPI_{\text{senza pipeline}}}{1+Pipe\, Stalls\, per\, instruction}
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Caso semplice
\series default
: Tutte le istruzioni prendono lo stesso numero di cicli, che deve essere
 uguale al numero di stadi della pipeline (chiamata 
\emph on
profondità della pipeline
\emph default
):
\begin_inset Formula 
\[
Pipeline\, speedup\,=\,\frac{Pipeline\, depth}{1+Pipeline\, Stalls\, per\, instruction}
\]

\end_inset


\end_layout

\begin_layout Standard
Se non ci sono stalli nella pipeline (caso ideale), questo ci porta al risultato
 intuitivo che il pipelining può aumentare le performance man mano che aumenta
 la profondità della pipeline.
\end_layout

\begin_layout Itemize
Qual'è l'impatto di performance dei 
\series bold
branch condizionali
\series default
?
\begin_inset Formula 
\[
Pipeline\, speedup\,=\,\frac{Pipeline\, depth}{1+Pipe\, Stall\, Cycles\, per\, instruction\, due\, to\, branches}=\frac{Pipeline\, depth}{1+Branch\, Frequency\cdot Branch\, Penality}
\]

\end_inset


\end_layout

\begin_layout Section*
Tecniche di predizione dei branch
\end_layout

\begin_layout Subsection*
Istruzioni di branch condizionali
\end_layout

\begin_layout Standard
La branch viene presa soltanto se una certa 
\series bold
condizione 
\series default
viene 
\series bold
soddisfatta
\series default
.
\end_layout

\begin_layout Standard
L'
\series bold
indirizzo di destinazione
\series default
 della 
\emph on
branch
\emph default
 viene salvato nel 
\emph on
program counter
\emph default
 (PC) al posto dell'indirizzo dell'istruzione successiva (nello stream sequenzia
le di istruzioni).
\end_layout

\begin_layout Itemize

\series bold
Esempi
\series default
 di branch per il processore MIPS: 
\series bold
bne
\series default
 e 
\series bold
beq
\end_layout

\begin_deeper
\begin_layout LyX-Code
beq $s1, $s2, L1              # Vai a L1 se $s1 == $s2
\end_layout

\begin_layout LyX-Code
bne $s1, $s2, L1              # Vai a L1 se $s1 != $s2
\end_layout

\end_deeper
\begin_layout Standard
Abbiamo già visto com'è strutturata l'istruzione di branch in memoria (è
 una istruzione di tipo I).
 Le fasi per la sua esecuzione sono:
\end_layout

\begin_layout Itemize

\series bold
Fetch delle istruzioni e modifica di PC
\end_layout

\begin_layout Itemize

\series bold
Lettura dei registri dal register file
\end_layout

\begin_layout Itemize

\series bold
ALU operation
\series default
: per confrontare i registri e derivare la 
\series bold
\bar under
Branch Outcome
\series default
\bar default
 (branch 
\begin_inset Quotes eld
\end_inset

taken
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

not taken
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Itemize
Computazione del 
\series bold
\bar under
branch target address 
\series default
\bar default
(
\begin_inset Formula $PC+4+offset$
\end_inset

) (ricordiamoci che offset viene esteso in segno).
\end_layout

\begin_layout Itemize
Il valore di 
\series bold
PC viene scritto
\series default
.
\end_layout

\begin_layout Standard
Abbiamo già visto che in MIPS ogni istruzione si divide in 5 stages:
\end_layout

\begin_layout Enumerate

\series bold
IF - Instruction Fetch
\end_layout

\begin_layout Enumerate

\series bold
ID - Instruction Decode
\end_layout

\begin_layout Enumerate

\series bold
EX - Execution
\end_layout

\begin_layout Enumerate

\series bold
ME - Memory Access
\end_layout

\begin_layout Enumerate

\series bold
WB - Write Back
\end_layout

\begin_layout Standard
Nel caso della nostra istruzione di branch, il 
\series bold
\bar under
branch outcome
\series default
\bar default
 e il 
\series bold
\bar under
branch target address
\series default
\bar default
 saranno pronti alla fine dello stage EX (stage 3).
\end_layout

\begin_layout Standard
Le branch condizionali vengono completate quando il PC è stato riscritto,
 nello stage 4.
\end_layout

\begin_layout Itemize

\series bold
Le risorse del processore per eseguire i branch condizionali
\series default
:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 031.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Implementazione della pipeline a 5 stage MIPS
\series default
:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 032.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection*
Il problema dei control hazards
\end_layout

\begin_layout Standard
Un 
\series bold
\emph on
\bar under
control hazard
\series default
\emph default
\bar default
 è un tentativo di prendere una decisione sulla prossima istruzione da leggere
 prima che la condizione della branch venga valutata.
\end_layout

\begin_layout Itemize
I 
\emph on
control hazards
\emph default
 nascono quando branch condizionali e altre istruzioni che 
\series bold
modificano il valore di PC
\series default
 vengono messe all'interno della 
\series bold
pipeline
\end_layout

\begin_layout Itemize
I 
\emph on
control harzard 
\emph default
riducono le performance dallo speedup ideale guadagnato dal pipelining perchè
 potrebbero rendere necessari degli stalli nella pipeline.
\end_layout

\begin_layout Standard
Per far funzionare la pipeline dobbiamo prendere una nuova istruzione ad
 ogni ciclo di clock, ma la decisione di branch (cambiare o non cambiare
 PC per la 
\series bold
\bar under
prossima
\series default
\bar default
 istruzione) viene presa durante lo stadio MEM (stadio 4).
\end_layout

\begin_layout Standard
Questo 
\series bold
ritardo
\series default
 per determinare la prossima istruzione è chiamato appunto 
\series bold
\emph on
control harzard
\series default
\emph default
 o 
\series bold
\emph on
conditional branch hazard
\series default
\emph default
.
\end_layout

\begin_layout Standard
Se la branch decide di cambiare il valore di PC si dice 
\series bold
\emph on
branch taken
\series default
\emph default
, altrimenti è una 
\series bold
\emph on
untaken
\series default
\emph default
.
\end_layout

\begin_layout Subsubsection*
Esempio
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 033.png
	scale 40

\end_inset


\end_layout

\begin_layout Itemize
Nel momento in cui la branch decide se deve cambiare o non cambiare PC,
 ci sono già le 3 istruzioni seguenti caricate nella pipeline.
\end_layout

\begin_layout Itemize
Se la branch è 
\series bold
not taken
\series default
 non c'è nessun problema.
 Se però è taken ho già eseguito parte delle 3 istruzioni seguenti! Quindi
 è necessario fare un 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
flush
\series default
\emph default

\begin_inset Quotes erd
\end_inset

 delle successive 3 istruzioni 
\end_layout

\begin_layout Subsection*
Soluzioni al problema del control hazard
\end_layout

\begin_layout Itemize
Assunzione 
\series bold
conservativa
\series default
: Metto in stallo la pipeline fino a quando la decisione non è stata presa
 (si chiama anche 
\series bold
\emph on
stalling until resolution
\series default
\emph default
) e poi prendo il flusso corretto di istruzioni
\end_layout

\begin_deeper
\begin_layout Itemize
Se utilizzamo il fowarding: lo faccio in 3 cicli di clock
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 035.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Senza forwarding: in 2 cicli di clock
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 034.png
	scale 30

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Se però la branch era 
\series bold
untaken
\series default
 abbiamo sprecato 3 preziosi cicli di clock che ci causano una grossa riduzione
 del throughput.
\end_layout

\begin_layout Itemize
Possiamo 
\series bold
\bar under
assumere
\series default
\bar default
 che la branch sia 
\series bold
untaken
\series default
 e fare flush delle successive 3 istruzioni solo se 
\series bold
\bar under
pensiamo
\series default
\bar default
 che sia 
\series bold
taken
\series default
.
\end_layout

\begin_layout Subsubsection*
Early evaluation del PC
\end_layout

\begin_layout Standard
Per aumentare le performance nel caso di hazards dovuti ai branch, dobbiamo
 aggiungere nuove risorse hardware per:
\end_layout

\begin_layout Itemize
Confrontare registri per derivare il 
\series bold
\emph on
branch outcome
\series default
\emph default
 (risultato del branch)
\end_layout

\begin_layout Itemize
Computare il 
\series bold
\emph on
branch target address
\end_layout

\begin_layout Itemize
Aggiornare il registro PC
\end_layout

\begin_layout Standard
Tutte queste 3 operazioni devono essere fatte 
\series bold
\bar under
appena possibile
\series default
\bar default
 nella pipeline.
\end_layout

\begin_layout Standard
I processori MIPS comparano registri, computano indirizzi di branch e aggiornand
o il PC durante lo 
\series bold
stadio ID
\series default
.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 036.png
	scale 30

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Assunzione conservativa
\series default
: Ogni branch costa 
\bar under
uno stallo
\bar default
 per fetchare il corretto flusso di istruzioni
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 037.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Quali sono le conseguenze di fare questa 
\begin_inset Quotes eld
\end_inset


\emph on
early evaluation
\emph default

\begin_inset Quotes erd
\end_inset

 ?
\end_layout

\begin_deeper
\begin_layout Itemize
Nel caso della istruzione di 
\series bold
add
\series default
 (o 
\series bold
load
\series default
) seguita da una 
\series bold
branch
\series default
 che testa il risultato della add: dobbiamo introdurre uno stallo prima
 dello stadio ID della branch per permettere il forwarding del risultato
 dallo stadio EX della istruzione precedente.
\end_layout

\begin_layout Itemize

\series bold
Esempio
\series default
:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 038.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Con la decisione di branch fatta durante lo stadio ID c'è una 
\series bold
riduzione dei costi
\series default
 associati ad ogni branch (
\series bold
branch penality
\series default
)
\end_layout

\begin_deeper
\begin_layout Itemize
Abbiamo bisogno 
\bar under
solo un ciclo di clock di stallo
\bar default
 dopo ogni branch
\end_layout

\begin_layout Itemize
Oppure il flush di 
\series bold
una
\series default
 sola istruzione che segue il branch
\end_layout

\end_deeper
\begin_layout Itemize
Il ritardo di un ciclo per ogni branch comporta comunque una perdita dal
 10% al 30% a seconda della frequenza della branch
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Pipeline\, stall\, cycles\, per\, instruction_{\text{a causa dei branch}}=Branch\, frequency\,\cdot\, Branch\, penality
\]

\end_inset


\end_layout

\begin_layout Itemize
Esamineremo alcune tecniche per affrontare questa perdita di performance
\end_layout

\end_deeper
\begin_layout Subsection*
Tecniche di predizione dei branch
\end_layout

\begin_layout Standard
In generale il problema dei branch diventa più importante per processori
 con pipeline profonda perché il costo delle predizioni scorrette aumenta
 (i branch vengono risolti diversi stage dopo lo stadio ID).
\end_layout

\begin_layout Itemize

\series bold
Le performance 
\series default
delle tecniche di predizione di branch dipendono da:
\end_layout

\begin_deeper
\begin_layout Itemize
L'
\series bold
accuratezza
\series default
 misurata in termini di performance di predizioni scorrette date dal predittore
\end_layout

\begin_layout Itemize
Il 
\series bold
costo
\series default
 di una predizione scorretta misurata in termini di tempo perso per eseguire
 
\series bold
istruzioni inutili
\end_layout

\end_deeper
\begin_layout Itemize
Dobbiamo anche considerare la 
\series bold
frequenza delle branch
\series default
 all'interno del flusso di codice da eseguire.
 Ovviamente se ci sono poche branch per istruzione avremo poca perdita di
 performance.
\end_layout

\begin_layout Standard
Ci sono fondamentalmente 
\series bold
\bar under
due metodi di predizione
\series default
\bar default
 delle branch:
\end_layout

\begin_layout Itemize

\series bold
Tecniche di predizione 
\bar under
statica
\series default
\bar default
: A compile time decidiamo le operazioni da fare per ogni branch
\end_layout

\begin_deeper
\begin_layout Itemize
Questo tipo di predizione viene utilizzata nei processori dove si riesce
 a prevedere l'esito delle branch a compile time
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Tecniche di predizione 
\bar under
dinamica
\series default
\bar default
: A run time prendiamo decisioni sulle predizioni delle branch, che possono
 cambiare durante l'esecuzione del programma.
\end_layout

\begin_layout Standard
In entrambi i casi è necessario fare molta attenzione a non modificare lo
 stato del processore fino a quando non è chiaramente noto l'esito della
 branch.
\end_layout

\begin_layout Standard
Le tecniche di predizione statica vengono comunque spesso utilizzate anche
 all'interno delle tecniche di predizione statica.
\end_layout

\begin_layout Section*
Tecniche di predizione statica
\end_layout

\begin_layout Enumerate
Branch 
\series bold
always not taken
\series default
 (
\series bold
Predicted-Not-Taken
\series default
)
\end_layout

\begin_layout Enumerate
Branch 
\series bold
always taken 
\series default
(
\series bold
Predicted-Taken
\series default
)
\end_layout

\begin_layout Enumerate

\series bold
Backward taken forward not taken
\series default
 (
\series bold
BTFNT
\series default
)
\end_layout

\begin_layout Enumerate

\series bold
Profile-Driven Prediction
\end_layout

\begin_layout Enumerate

\series bold
Delayed Branch
\end_layout

\begin_layout Subsection*
Branch always not taken
\end_layout

\begin_layout Standard
Assumiamo che il branch non sia mai taken, quindi lasciamo continuare il
 flusso di istruzioni come se la condizione di branch non fosse soddisfatta.
\end_layout

\begin_layout Itemize
Se la predizione è 
\series bold
corretta
\series default
 preserviamo le performance:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 039.png
	scale 30

\end_inset


\end_layout

\begin_layout Itemize
Se la predizione è 
\series bold
errata
\series default
: dobbiamo fare flush della prossima istruzione già fetchata (trasformiamo
 l'instruzione letta in precedenza in una NOP) e riavviamo l'esecuzione
 prendendo l'istruzione al 
\emph on
branch target address
\emph default
.
 Abbiamo quindi una 
\series bold
penalità di un ciclo
\series default
.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 040.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection*
Branch Always taken
\end_layout

\begin_layout Standard
Uno schema alternativo è quello di considerare ogni branch come 
\series bold
taken
\series default
.
\end_layout

\begin_layout Standard
Non appena il branch target address viene computato, assumiamo la branch
 come 
\series bold
taken
\series default
 e iniziamo a fare fetch e esecuzione del branch target.
\end_layout

\begin_layout Standard
Questo tipo di predizione ha senso per pipelines dove il branch target address
 è noto prima di conoscere il risultato della branch.
\end_layout

\begin_layout Standard
Nella pipeline MIPS 
\series bold
non conosciamo 
\series default
il 
\emph on
branch target address
\series bold
 
\emph default
prima
\series default
 di conoscere il 
\series bold
branch outcome
\series default
.
 Quindi per MIPS questa tecnica non è utilizzabile.
\end_layout

\begin_layout Subsection*
Backward Taken Forward Not Taken (BTFNT)
\end_layout

\begin_layout Standard
La predizione viene fatta sulla 
\begin_inset Quotes eld
\end_inset


\emph on
direzione
\emph default

\begin_inset Quotes erd
\end_inset

 dei branch (cioè se l'indirizzo destinazione a cui puntano è prima o dopo
 l'indirizzo dell'istruzione attuale):
\end_layout

\begin_layout Itemize

\series bold
\emph on
backward-going branches
\series default
\emph default
: considerati 
\emph on
taken
\end_layout

\begin_layout Itemize

\series bold
\emph on
forward-going branches
\series default
\emph default
: considerati 
\emph on
not-taken
\end_layout

\begin_layout Standard
L'idea alla base è che quando abbiamo dei branch che puntano 
\emph on
backward
\emph default
, significa che siamo all'interno di un loop, e quindi (nella maggior parte
 dei casi), il branch sarà taken per proseguire il loop.
\end_layout

\begin_layout Subsection*
Profile-driven prediction
\end_layout

\begin_layout Standard
La predizione del branch in questo caso, viene presa in base ad analisi
 di esecuzioni precedenti.
 Questo metodo può anche basarsi su 
\begin_inset Quotes eld
\end_inset

consigli
\begin_inset Quotes erd
\end_inset

 del compilatore.
\end_layout

\begin_layout Subsection*
Delayed Branch Technique
\end_layout

\begin_layout Standard
Il compilatore inserisce staticamente nello slot di 
\begin_inset Quotes eld
\end_inset

delay
\begin_inset Quotes erd
\end_inset

 del branch una istruzione indipendente da esso, che viene eseguita sia
 che il branch sia taken, sia che sia untaken.
\end_layout

\begin_layout Itemize
Se assumiamo che il branch delay sia 1 ciclo (come nel caso di MIPS), abbiamo
 solo 1 slot di delay.
\end_layout

\begin_deeper
\begin_layout Itemize
In realtà è possibile avere processori con pipile che utilizzano degli slot
 di delay più lunghi.
\end_layout

\begin_layout Itemize
Però quasi tutti i processori che utilizzano la tecnica di delayed branch
 hanno un singolo slot di delay (anche perché è difficile per il compilatore
 trovare più istruzioni da inserire in più di uno slot.
\end_layout

\end_deeper
\begin_layout Itemize
Il compilatore MIPS schedula sempre una istruzione indipendente dopo una
 istruzione di branch.
\end_layout

\begin_layout Itemize
Esempio: una istruzione di add viene schedulata dopo una istruzione beq,
 per essere eseguita nel 
\emph on
branch delay slot
\emph default
.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 041.png
	scale 30

\end_inset


\end_layout

\begin_layout Itemize
Ci sono 
\series bold
4 modi
\series default
 in cui il branch delay slot può essere schedulato dal 
\series bold
compilatore
\series default
:
\end_layout

\begin_deeper
\begin_layout Enumerate
From before
\end_layout

\begin_layout Enumerate
From target
\end_layout

\begin_layout Enumerate
From fall-through
\end_layout

\begin_layout Enumerate
From after
\end_layout

\end_deeper
\begin_layout Subsubsection*
Delayed branch technique: from before
\end_layout

\begin_layout Standard
Il branch delay slot viene schedulato con una istruzione indipendente che
 era prima dell'istruzione bi branch.
\end_layout

\begin_layout Standard
L'istruzione nel branch delay slot viene sempre eseguita (perché in ogni
 caso la dobbiamo eseguire non essendo una istruzione che è dopo).
\end_layout

\begin_layout Itemize
Esempio:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename 042.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection*
Delayed branch technique: from target
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 043.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
In questo caso non possiamo spostare l'istruzione di 
\series bold
add
\series default
 dopo l'if perché il risultato ($1) viene utilizzato per prendere decisioni
 sulla branch.
 Però in questo caso possiamo mettere nel branch delay slot l'istruzione
 da eseguire in caso di branch taken se il branch target address è backward
 (come nel caso dei loop).
\end_layout

\begin_layout Subsubsection*
Delayed branch technique: from fall-through
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 044.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
È la tecnica duale del 
\begin_inset Quotes eld
\end_inset


\emph on
from target
\emph default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Anche in questo caso non possiamo spostare l'istruzione di 
\series bold
add
\series default
 perché la branch utilizza $1 che è già presente nella add.
\end_layout

\begin_layout Standard
In questa strategia iniziamo ad eseguire il comando dopo il branch (quindi
 come se fosse a priori 
\series bold
not taken
\series default
).
 Questo è utile quando abbiamo alta probabilità di branch non presi.
\end_layout

\begin_layout Itemize
Per 
\series bold
\bar under
rendere l'ottimizzazione legale 
\series default
\bar default
nei casi 
\begin_inset Quotes eld
\end_inset

target
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

fall-though
\begin_inset Quotes erd
\end_inset

, deve essere permesso eseguire l'istruzione spostata quando la branch va
 nella direzione opposta a quella prevista.
 Per 
\begin_inset Quotes eld
\end_inset

permesso
\begin_inset Quotes erd
\end_inset

 intendiamo che l'istruzione inserita nel branch delay slot viene eseguita
 ma il 
\begin_inset Quotes eld
\end_inset

lavoro
\begin_inset Quotes erd
\end_inset

 è stato sprecato e il programma continua ad eseguire correttamente anche
 dopo aver eseguito quella istruzione inutile.
 Per esempio va bene se il registro destinazione è un registro utilizzato
 temporaneamente quando la branch va nella direzione errata.
\end_layout

\begin_deeper
\begin_layout Itemize
In generale, i compilatori sono in grado di riempire circa il 50% dei delayed
 brach slots con istruzioni valide e utile.
 Gli slot rimanenti sono riempiti con operazioni 
\series bold
nop
\series default
.
\end_layout

\begin_layout Itemize
Nelle pipelines più profonde il delayed branch è più lungo di un ciclo,
 quindi è necessario trovare altre istruzioni, quindi è ancora più difficile
 trovare istruzioni da inserire.
\end_layout

\end_deeper
\begin_layout Itemize
Le principali limitazioni del delayed branch scheduling nascono da:
\end_layout

\begin_deeper
\begin_layout Itemize
Restrizioni sulle istruzioni che possiamo inserire nel branch delay slot
\end_layout

\begin_layout Itemize
L'abilità del compilare di predirre staticamente il risultato delle branch
\end_layout

\end_deeper
\begin_layout Itemize
Per migliorare le predizioni del compilatore molti processori hanno introdotto
 la 
\series bold
canceling 
\series default
o
\series bold
 
\series default

\begin_inset Quotes eld
\end_inset


\series bold
\emph on
nullifying branch
\series default
\emph default

\begin_inset Quotes erd
\end_inset

.
 In questo tipo speciale di branch l'istruzione include al suo interno anche
 un bit che indica la direzione in cui è previsto che la branch vada.
 Così facendo abbiamo che:
\end_layout

\begin_deeper
\begin_layout Itemize
Quando la branch agisce come previsto: l'istruzione nel branch delay slot
 è eseguita normalmente
\end_layout

\begin_layout Itemize
Quando la branch non agisce come previsto: l'istruzione nel branch delay
 slot viene trasformata in una NOP
\end_layout

\end_deeper
\begin_layout Itemize
L'architettura MIPS ha l'istruzione 
\series bold
branch-likely
\series default
 che si comporta come una branche 
\series bold
\emph on
cancel-if-not-taken
\series default
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize
L'istruzione nel branch delay slot viene eseguita se il branch è taken.
\end_layout

\begin_layout Itemize
L'istruzione nel branch delay slot non viene eseguita (viene trasformata
 in nop) se la branch è untaken
\end_layout

\begin_layout Itemize
È un approccio utile per backward branches (come i branch utilizzati per
 costruire i loop)
\end_layout

\end_deeper
\begin_layout Section*
Tecniche di predizione dinamica dei branch
\end_layout

\begin_layout Standard

\series bold
Idea base
\series default
: utilizzare i comportamenti precedenti dei branch per prevedere il futuro.
\end_layout

\begin_layout Standard
Utilizziamo hardware per predirre dinamicamente il risultato di un branch.
 La predizione dipenderà sul comportamento del branch a run time e cambierà
 se la branch cambia il suo comportamento durante l'esecuzione.
\end_layout

\begin_layout Standard
Partiamo con uno schema di predizione di branch semplice e poi esaminiamo
 approcci che aumentano l'accuratezza.
\end_layout

\begin_layout Standard
I meccanismi principali di predizione sono due:
\end_layout

\begin_layout Itemize

\series bold
Branch outcome predictor
\series default
: per predirre la direzione di un branch (taken o not taken)
\end_layout

\begin_layout Itemize

\series bold
Branch target predictor
\series default
 o 
\series bold
branch target buffer
\series default
: per predirre il branch target address in caso di branch taken
\end_layout

\end_body
\end_document
